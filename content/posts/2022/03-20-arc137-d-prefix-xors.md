---
author: "yamate11"
title: "Prefix XORs - AtCoder Regular Contest 137 D"
date: "2022-03-20T00:57:31+09:00"
# date_init: "2022-03-20"
tags: []
# categories: ["topic"]
categories: ["solution"]
summary: "ARC137D の解法です．実験+ビット計算です．"
draft: true
---

AtCoder Regular Contest 137 D - Prefix XORs の解法です．
公式解説はまだちゃんと読んでおらず，コンテスト中に解いた方法です．
実験結果から適当に求めました．

## 問題概要

長さ$N$の整数列 $A = (A_1, \ldots, A_N)$ と整数 $M$ が与えられる．
下の操作を$k$回行ったあとの $A_i$ の値を $A(i, k)$ と書くことにする．
$k = 1, 2, \ldots, M$ について，$A(N, k)$ を求めよ．

操作: 各$i = 1, 2, \ldots, N$ について，
$A_i$ を同時に $A_1 \oplus A_2 \oplus \cdots \oplus A_i$ で置き換える．

制約: $1 \leq N, M \leq 10^6$; $0 \leq A_i < 2^{30}$

## 解法

$A(i, k)$ は，$A_1, \ldots, A_i$ のいくつかのXORをとったものになる．
そこで，$a(i, m, k) \in \\{0, 1\\}$ をとって，
$A(i, k) = \bigoplus_{m=1}^{i} a(i,m,k) A_m$ と書く．
計算してみると分かるとおり，$a(i, m, k)$ は，$i - m$ と $k$ にしか
依存しない．そこで，$b(j, k) := a(j, 0, k)$ と書くことにする．
$A(i, k) = \bigoplus_{m=1}^{i} b(i - m, k) A_m
= \bigoplus \\{ A_{i - j} \mid b(j, k) = 1 \\}$ だから，
各 $k = 1, 2, \ldots, M$ について，$b(j, k) = 1$ となる $j$ を
(高速に) 列挙できれば良い．


計算してみると，$b(j, k)$ は次のようになっている:

```text
   0 11111111111111111111111111111111
   1 10101010101010101010101010101010
  10 11001100110011001100110011001100
  11 10001000100010001000100010001000
 100 11110000111100001111000011110000
 101 10100000101000001010000010100000
 110 11000000110000001100000011000000
 111 10000000100000001000000010000000
1000 11111111000000001111111100000000
1001 10101010000000001010101000000000
1010 11001100000000001100110000000000
1011 10001000000000001000100000000000
1100 11110000000000001111000000000000
```

左端は，k - 1 の値の2進表示．スペースの直後が j = 0 の値,
その次が j = 1 の値，その次が j = 2 の値，... である．

たとえば，$k - 1 = 6 = 110_2$ のとき，$b(k, j) = 1$ となる$j$ は，
$0, 1, 8, 9, 16, 17, 24, 25, \ldots$ であり，2進表記では次のようになる:

```text
00000
00001
01000
01001
10000
10001
11000
11001
```

(下から) 2ビット目と3ビット目は 0 であり，他の
ビットは任意に取れる．0 に固定されているビットは，$k - 1 = 110_2$ の
立っているビットである．
他の$k$についても，すべてそのような関係が成立しており，
(コンテスト中にはできなかったが) 帰納法で証明することもできる．

したがって，ビットごとの AND を & で表記することにして，
$(k - 1) \\;\\&\\; x = 0$ となる $N-1$ 以下の $x$ を列挙できれば良い．
これは，蟻本に載っている，部分集合の列挙と同じ方式で実現できる．
(下の実装コードを参照)

## 実装

[ACコード]()．
主要部分は以下の通り:
