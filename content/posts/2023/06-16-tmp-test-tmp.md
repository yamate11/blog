---
author: "yamate11"
title: "tmp_test_tmp"
date: "2023-06-16T10:30:34+09:00"
# date_init: "2023-06-16"
tags: []
# categories: ["topic"]
# categories: ["solution"]
# summary: "要約を書いておく．ここには問題タイトル等は不要" 
draft: true
---

<!-- タイトルはキーワードがインデックスされないかもしれないので，
     ここに書いておく -->
<!-- AtCoder *** Contest xxx - A*C xxx F - 問題タイトル の解法です．-->


この問題は，「部分列DP」を用いて解くことができます．
この手法は，たとえばけんちょん氏の記事
「[部分列DP \-\-\- 文字列の部分文字列を重複なく操作する DP の特集](https://qiita.com/drken/items/a207e5ae3ea2cf17f4bd)」
にまとめられています．以下では部分列DPの前提知識を仮定せずに説明します．

最初に記号を導入します．

* $i \in \\{1, 2, \ldots, N\\}$ に対して，$S_j = S_i, j < i$ を満たす最大の
  $j$ を $P(i)$ と書きます．
  そのような $j$ が存在しないときには，$P(i) = 0$ とします．
* $f(T)$ の定義に現れる $K$ を，パラメタ $k$ に置き換えて得られる値を
  $g(T, k)$ と書きます．正確には，
  $S$ の部分列 $T = (T_1, \ldots, T_l)$ と
  $k \in \\{0, 1, \ldots, K\\}$ に対し，
  種類が $T_1, \ldots, T_l$ である カードがテーブル上に表面を上にして
  一列に並んでいるときに，
  カードの上面の数の総和が $k$ になるように
  $0$ 枚以上を選んで裏返す選び方の数が $g(T, k)$ です．
  $f(T) = g(T, K)$ が成り立ちます．

$S$ の部分列 $T = (T_1, ..., T_l)$ に対して，$S$ の添字の狭義単調増加列
$(p_1, ..., p_l)$ で，$S_{p_1} = T_1, ..., S_{p_l} = T_l$ を満たす
ものを考えます．
一般には $T$ に対してこのような列は複数ありえますが，それらのうちで，
小さい方から貪欲にとる列を採用します．
正確には，次のように定まる $(p_1, ..., p_l)$ です．

\begin{align*}
  p_1 = & \min \\{ i \mid S_i = T_1 \\}  & \\\\
  p_2 = & \min \\{ i \mid p_1 < i \text{ かつ } S_i = T_2 \\} & \\\\
  & \cdots \\\\
  p_l = & \min \\{ i \mid p_{l - 1} < i \text{ かつ } S_i = T_l \\} \\\\
\end{align*}

この列は，次の性質 (*) を持っています:

> (*) 任意の $i \in \\{1, \ldots, l\\}$ について，
>     $P(p_i) = 0$ であるか，もしくは，
>     $0 < P(p_i) \leq p_m < p_i$ を満たす $m$ が存在する．

逆に，長さが $1$ 以上 $N$ 以下であって，
$1$ 以上 $N$ 以下の値をとる狭義単調増加列のうち，
性質 (*) を持つもの全体の集合を $U$ と書くことにして，
$p = (p_1, ..., p_l) \in U$ に対して 
$S$ の部分列 $(S_{p_1}, ..., S_{p_l})$ を $\text{seq}(p)$ と定義します．
すると，$p, q \in U$ に対して，$p \neq q$ ならば
$\text{seq}(p) \neq \text{seq}(q)$
となります ($p_k \neq q_k$ となる最小の $k$ を考えると示せます)．
上と合わせると，
$\text{seq}$ は，
$U$ と $S$ の部分列全体の集合との間の全単射を与えていることがわかります．
これを用いれば，$S$ の部分列を考える代わりに，
$U$ の要素を考えればよいことになります．
特に $g(\text{seq}(p), k)$ は，各 $i \in \\{1, \ldots, l\\}$ に対して
$A_{p_i}$ か $B_{p_i}$ かのいずれかを割り当てる方法 $w$ であって，
$\sum_{i = 1}^{l} w(i) = k$ を満たすものの数です．

したがって，次の動的計画法を用いることができます．

* $\text{dp}[i][k] = \text{(末尾要素が $i$ である $p \in U$ に対する
  $g(\text{seq}(p), k)$ の総和)}$

求める答えは，
$\sum_{i = 1}^{N} \text{dp}[i][K]$
です．
$\text{dp}$ の値は，再帰的に次のように定められます．
和に現れる $j$ は，性質 (*) における $p_m$ に相当します．


* $\text{dp}[0][0] = 1$
* $\text{dp}[0][k] = 0 \quad (1 \leq k \leq N)$
* $\text{dp}[i][k] = 0 \quad (1 \leq i \text{ かつ } k \leq 0)$
* $\text{dp}[i][k]
   = \sum_{j = P(i)}^{i - 1} (\text{dp}[j][k - A_{S_i}] + \text{dp}[j][k - B_{S_i}])\quad (1 \leq i, k \leq N)$

この式通りに計算したのでは間に合いませんが，
累積和を用いて高速化することにより，
この問題を $O(NK+M)$ で解くことができました。
