<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>二重連結 | yamate11のブログ</title>
<meta name="keywords" content="">
<meta name="description" content="無向グラフの二重連結に関して，辺二重連結，橋，点二重連結，関節点，block-cut tree などに関するまとめです">
<meta name="author" content="yamate11">
<link rel="canonical" href="https://yamate11.github.io/blog/posts/2023/09-05-bridge/">
<link crossorigin="anonymous" href="/blog/assets/css/stylesheet.cfdb0c3379ef447c9f679190e89f76ab7e6d5dc5b725c57799a66e44b92c2d56.css" integrity="sha256-z9sMM3nvRHyfZ5GQ6J92q35tXcW3JcV3maZuRLksLVY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://yamate11.github.io/blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://yamate11.github.io/blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://yamate11.github.io/blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://yamate11.github.io/blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://yamate11.github.io/blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script>
    MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true,
        tags: "ams",
        autoload: {
          color: [],
          colorV2: ['color']
        },
        packages: {'[+]': ['noerrors']}
      },
      chtml: {
        matchFontHeight: false,
          

      },
      loader: {
        load: ['[tex]/noerrors']
      }
    };
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" id="MathJax-script"></script>



<meta property="og:title" content="二重連結" />
<meta property="og:description" content="無向グラフの二重連結に関して，辺二重連結，橋，点二重連結，関節点，block-cut tree などに関するまとめです" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yamate11.github.io/blog/posts/2023/09-05-bridge/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-05T18:13:58+09:00" />
<meta property="article:modified_time" content="2023-09-05T18:13:58+09:00" /><meta property="og:site_name" content="yamate11のブログ" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="二重連結"/>
<meta name="twitter:description" content="無向グラフの二重連結に関して，辺二重連結，橋，点二重連結，関節点，block-cut tree などに関するまとめです"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://yamate11.github.io/blog/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "二重連結",
      "item": "https://yamate11.github.io/blog/posts/2023/09-05-bridge/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "二重連結",
  "name": "二重連結",
  "description": "無向グラフの二重連結に関して，辺二重連結，橋，点二重連結，関節点，block-cut tree などに関するまとめです",
  "keywords": [
    
  ],
  "articleBody": "概要 無向グラフの二重連結に関して，二重辺連結，橋，二重点連結，関節点，block-cut tree などに関するライブラリを書いたので，そのメモです．\n概念 以下，グラフは単純とは限らない，無向グラフとします．\nグラフのある辺を削除すると， 連結成分の数が増えるとき，その辺を 橋 (bridge) と呼ぶ．\n橋の無いグラフは，二重辺連結 (two-edge connected) であるという．\nグラフの点集合の部分集合が，二重辺連結部分グラフを導き， そのようなものの中で極大であるとき，これを二重辺連結成分と呼ぶ．\nグラフのある点 (とその点が端点である辺) を削除すると， 連結成分の数が増えるとき， その点を 関節点 (articulation point) と呼ぶ．\n関節点の無いグラフは，二重点連結 (biconnected) であるという．\nグラフの点集合の部分集合が，二重点連結部分グラフを導き， そのようなものの中で極大であるとき，これを二重点連結成分と呼ぶ．\n命題たち 以下のことがなりたつ (と思うのですが，まだちゃんと証明できていない ものもあります)\n二重点連結グラフは，二重辺連結である． 二重辺連結成分を集めてくると，グラフ点集合の分割になる． 二重辺連結成分$A$, $B$ に，$(A, B) \\in R \\iff \\exists a \\in A \\exists b \\in B (a,b)$は橋．という関係を入れると，森になる． 2つの二重点連結成分の共通部分は，空集合であるか，関節点1点からなる． 二重点連結成分の全体 $C$ と，関節点全部からなる集合 $A$ の和集合 $A \\cup C$ に， $\\{ (a, c) \\mid a \\in A, c \\in C, a \\in c \\}$ で関係を入れると， これは森になります．元のグラフが連結ならば，木です． これを，Block-Cut tree (forest?) と言うそうです． (block は二重点連結成分を指し，cut は関節点を指す)\nライブラリ 以下のような仕様のものを作りました． 一応，自己ループや多重辺があっても，また，連結で無くても動作するはずです．\nstruct bridge { // 二重辺連結に関する機能 bridge(int size); // constructor void add_edge(int u, int v); // もとのグラフの辺の定義 bool is_bridge(int u, int v); // 橋かどうか判定 int num_tecc(); // 連結成分の数 const vector\u003cint\u003e\u0026 tecc(int ccid); // 各連結成分の頂点をあつめたvector int node_tecc_idx(int u); // もとのグラフの点 u が属する連結成分の ID vector\u003cpair\u003cint, int\u003e\u003e tecc_edges(); // 上述の森の辺 (ペアの要素は，連結成分ID) }; struct articulation { // 二重点連結に関する機能 articulation(int size); // constructor void add_edge(int u, int v); // もとのグラフの辺の定義 bool is_articulation(int u); // 関節点かどうか判定 int bcc_size(); // 連結成分の数 (上と整合していないなあ...) const vector\u003cint\u003e\u0026 bcc(int idx); // 各連結成分の頂点をあつめたvector enum kind { BLOCK, CUT }; // block-cut forest でどちらを表しているかを示す enum struct bctree { // block-cut forest (名前が整合的でない...) int size(); // forest の頂点の数 vector\u003cpair\u003cint, int\u003e\u003e edges(); // forest の辺 pair\u003ckind, int\u003e what(int node); // forest の頂点が，もとのグラフでは何か? // {BLOCK, x} なら ID x である連結成分， {CUT, u} なら関節点 u int node(kind w, int i); // what の逆．forest における頂点番号を返す． }; bctree* make_bctree(); // Block Cut Forest を作る．戻り値はポインタであることに注意． }; 典型的な使用法は次のような感じです:\n二重辺連結について:\nint N; cin \u003e\u003e N; bridge bu(N); for (int i = 0; i \u003c N; i++) { int u, v; cin \u003e\u003e u \u003e\u003e v; u--; v--; bu.add_edge(u, v); } int u = ..., v = ...; bu.is_bridge(u, v); // (u, v) は橋か? for (int x = 0; x \u003c bu.num_tecc(); x++) { for (int u : bu.tecc(x)) { ... u ... ; // x 番目の二重辺連結成分 bu.tecc(x) の要素に順にアクセス } } int x = bu.node_tecc_idx[u]; // 頂点 u は x 番目の連結成分に属する for (auto [x, y] : bu.tecc_edges()) { // (x, y) が，上述の森の辺をなしている． } なお，元のグラフが連結でない場合には，bu.tecc_edges() の関係は 木にはならずに森になります．bu.llk.roots は， (型は vector )，もとのグラフの連結成分から1点ずつとった集合に なっています．\n二重点連結について:\nint N; cin \u003e\u003e N; articulation au(N); for (int i = 0; i \u003c N; i++) { int u, v; cin \u003e\u003e u \u003e\u003e v; u--; v--; au.add_edge(u, v); } int u = ...; au.is_articulation(u); // u は関節点か? for (int x = 0; x \u003c au.bcc_size(); x++) { for (int u : au.bcc(x)) { ... u ...; // x 番目の二重点連結成分 au.bcc(x) の要素に順にアクセス } } // Block-Cut tree に，別のライブラリである Tree を使う場合 // この下は，元のグラフが連結であるという前提のコードになっている... // (ライブラリ自体は，そうでなくても動作はする．bctree() という名前になっているが....) auto bctree = au.make_bctree(); ll sz = bctree-\u003esize(); // Block-Cut tree の頂点数 Tree bct(0, sz); for (auto [a, b] : bctree-\u003eedges()) bct.add_edge(a, b); // bctree-\u003eedges() が，Block Cut tree としての辺の関係 for (int a = 0; a \u003c sz; a++) { auto [w, i] = bctree-\u003ewhat(a); // aは BLOCK? それとも CUT? if (w == articulation::BLOCK) { // この連結成分は，au.bcc(i) である． }else if (w == articulation::CUT) { // この関節点は，(もとのグラフの頂点番号で) i である． }else assert(0); // what の逆変換が bctree-\u003enode() である． } 実装は，lowlink を使っています．DFS 木の行きがけ順を表す vector _ord と，back edge を高々1回たどって到達できる点の _ord の値の最小値である vector _low を最初に計算し，これらを用いて 橋や関節点の判定をしています．\n一応，ソースはこちら にあります．\n参考サイト けむさんの 二重連結性と lowlink の話 がたいへん参考になりました．お礼申し上げます．\n",
  "wordCount" : "509",
  "inLanguage": "en",
  "datePublished": "2023-09-05T18:13:58+09:00",
  "dateModified": "2023-09-05T18:13:58+09:00",
  "author":{
    "@type": "Person",
    "name": "yamate11"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://yamate11.github.io/blog/posts/2023/09-05-bridge/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "yamate11のブログ",
    "logo": {
      "@type": "ImageObject",
      "url": "https://yamate11.github.io/blog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://yamate11.github.io/blog/" accesskey="h" title="yamate11のブログ (Alt + H)">yamate11のブログ</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://yamate11.github.io/blog/archives/" title="記事一覧">
                    <span>記事一覧</span>
                </a>
            </li>
            <li>
                <a href="https://yamate11.github.io/blog/search/" title="検索 (Alt &#43; /)" accesskey=/>
                    <span>検索</span>
                </a>
            </li>
            <li>
                <a href="https://yamate11.github.io/blog/pages/about/" title="筆者">
                    <span>筆者</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      二重連結
    </h1>
    <div class="post-meta">2023-09-05&amp;nbsp;·&amp;nbsp;yamate11
</div>
  </header> 
  <div class="post-content"><h2 id="概要">概要<a hidden class="anchor" aria-hidden="true" href="#概要">#</a></h2>
<p>無向グラフの二重連結に関して，二重辺連結，橋，二重点連結，関節点，block-cut tree などに関するライブラリを書いたので，そのメモです．</p>
<h2 id="概念">概念<a hidden class="anchor" aria-hidden="true" href="#概念">#</a></h2>
<p>以下，グラフは単純とは限らない，無向グラフとします．</p>
<p>グラフのある辺を削除すると，
連結成分の数が増えるとき，その辺を <strong>橋</strong> (bridge) と呼ぶ．</p>
<p>橋の無いグラフは，<strong>二重辺連結</strong> (two-edge connected) であるという．</p>
<p>グラフの点集合の部分集合が，二重辺連結部分グラフを導き，
そのようなものの中で極大であるとき，これを二重辺連結成分と呼ぶ．</p>
<p>グラフのある点 (とその点が端点である辺) を削除すると，
連結成分の数が増えるとき，
その点を <strong>関節点</strong> (articulation point) と呼ぶ．</p>
<p>関節点の無いグラフは，<strong>二重点連結</strong> (biconnected) であるという．</p>
<p>グラフの点集合の部分集合が，二重点連結部分グラフを導き，
そのようなものの中で極大であるとき，これを二重点連結成分と呼ぶ．</p>
<h2 id="命題たち">命題たち<a hidden class="anchor" aria-hidden="true" href="#命題たち">#</a></h2>
<p>以下のことがなりたつ (と思うのですが，まだちゃんと証明できていない
ものもあります)</p>
<ul>
<li>二重点連結グラフは，二重辺連結である．</li>
<li>二重辺連結成分を集めてくると，グラフ点集合の分割になる．</li>
<li>二重辺連結成分$A$, $B$ に，$(A, B) \in R \iff \exists a \in A \exists b \in B (a,b)$は橋．という関係を入れると，森になる．</li>
<li>2つの二重点連結成分の共通部分は，空集合であるか，関節点1点からなる．</li>
</ul>
<p>二重点連結成分の全体 $C$ と，関節点全部からなる集合 $A$ の和集合
$A \cup C$ に，
$\{ (a, c) \mid a \in A, c \in C, a \in c \}$ で関係を入れると，
これは森になります．元のグラフが連結ならば，木です．
これを，Block-Cut tree (forest?) と言うそうです．
(block は二重点連結成分を指し，cut は関節点を指す)</p>
<h2 id="ライブラリ">ライブラリ<a hidden class="anchor" aria-hidden="true" href="#ライブラリ">#</a></h2>
<p>以下のような仕様のものを作りました．
一応，自己ループや多重辺があっても，また，連結で無くても動作するはずです．</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#00a8c8">struct</span> <span style="color:#75af00">bridge</span> <span style="color:#111">{</span>  <span style="color:#75715e">// 二重辺連結に関する機能
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#111">bridge</span><span style="color:#111">(</span><span style="color:#00a8c8">int</span> <span style="color:#111">size</span><span style="color:#111">);</span>  <span style="color:#75715e">// constructor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#00a8c8">void</span> <span style="color:#75af00">add_edge</span><span style="color:#111">(</span><span style="color:#00a8c8">int</span> <span style="color:#111">u</span><span style="color:#111">,</span> <span style="color:#00a8c8">int</span> <span style="color:#111">v</span><span style="color:#111">);</span>  <span style="color:#75715e">// もとのグラフの辺の定義
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#00a8c8">bool</span> <span style="color:#75af00">is_bridge</span><span style="color:#111">(</span><span style="color:#00a8c8">int</span> <span style="color:#111">u</span><span style="color:#111">,</span> <span style="color:#00a8c8">int</span> <span style="color:#111">v</span><span style="color:#111">);</span> <span style="color:#75715e">// 橋かどうか判定
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#00a8c8">int</span> <span style="color:#75af00">num_tecc</span><span style="color:#111">();</span>               <span style="color:#75715e">// 連結成分の数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#00a8c8">const</span> <span style="color:#111">vector</span><span style="color:#f92672">&lt;</span><span style="color:#00a8c8">int</span><span style="color:#f92672">&gt;&amp;</span> <span style="color:#111">tecc</span><span style="color:#111">(</span><span style="color:#00a8c8">int</span> <span style="color:#111">ccid</span><span style="color:#111">);</span>  <span style="color:#75715e">// 各連結成分の頂点をあつめたvector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#00a8c8">int</span> <span style="color:#75af00">node_tecc_idx</span><span style="color:#111">(</span><span style="color:#00a8c8">int</span> <span style="color:#111">u</span><span style="color:#111">);</span>     <span style="color:#75715e">// もとのグラフの点 u が属する連結成分の ID
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#111">vector</span><span style="color:#f92672">&lt;</span><span style="color:#111">pair</span><span style="color:#f92672">&lt;</span><span style="color:#00a8c8">int</span><span style="color:#111">,</span> <span style="color:#00a8c8">int</span><span style="color:#f92672">&gt;&gt;</span> <span style="color:#111">tecc_edges</span><span style="color:#111">();</span>  <span style="color:#75715e">// 上述の森の辺 (ペアの要素は，連結成分ID)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#111">};</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00a8c8">struct</span> <span style="color:#75af00">articulation</span> <span style="color:#111">{</span>  <span style="color:#75715e">// 二重点連結に関する機能
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#111">articulation</span><span style="color:#111">(</span><span style="color:#00a8c8">int</span> <span style="color:#111">size</span><span style="color:#111">);</span>  <span style="color:#75715e">// constructor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#00a8c8">void</span> <span style="color:#75af00">add_edge</span><span style="color:#111">(</span><span style="color:#00a8c8">int</span> <span style="color:#111">u</span><span style="color:#111">,</span> <span style="color:#00a8c8">int</span> <span style="color:#111">v</span><span style="color:#111">);</span>  <span style="color:#75715e">// もとのグラフの辺の定義
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#00a8c8">bool</span> <span style="color:#75af00">is_articulation</span><span style="color:#111">(</span><span style="color:#00a8c8">int</span> <span style="color:#111">u</span><span style="color:#111">);</span>  <span style="color:#75715e">// 関節点かどうか判定
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#00a8c8">int</span> <span style="color:#75af00">bcc_size</span><span style="color:#111">();</span>               <span style="color:#75715e">// 連結成分の数  (上と整合していないなあ...)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#00a8c8">const</span> <span style="color:#111">vector</span><span style="color:#f92672">&lt;</span><span style="color:#00a8c8">int</span><span style="color:#f92672">&gt;&amp;</span> <span style="color:#111">bcc</span><span style="color:#111">(</span><span style="color:#00a8c8">int</span> <span style="color:#111">idx</span><span style="color:#111">);</span>  <span style="color:#75715e">// 各連結成分の頂点をあつめたvector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#00a8c8">enum</span> <span style="color:#75af00">kind</span> <span style="color:#111">{</span> <span style="color:#111">BLOCK</span><span style="color:#111">,</span> <span style="color:#111">CUT</span> <span style="color:#111">};</span>     <span style="color:#75715e">// block-cut forest でどちらを表しているかを示す enum
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#00a8c8">struct</span> <span style="color:#75af00">bctree</span> <span style="color:#111">{</span>  <span style="color:#75715e">// block-cut forest (名前が整合的でない...)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">int</span> <span style="color:#75af00">size</span><span style="color:#111">();</span>    <span style="color:#75715e">// forest の頂点の数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#111">vector</span><span style="color:#f92672">&lt;</span><span style="color:#111">pair</span><span style="color:#f92672">&lt;</span><span style="color:#00a8c8">int</span><span style="color:#111">,</span> <span style="color:#00a8c8">int</span><span style="color:#f92672">&gt;&gt;</span> <span style="color:#111">edges</span><span style="color:#111">();</span>  <span style="color:#75715e">// forest の辺
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#111">pair</span><span style="color:#f92672">&lt;</span><span style="color:#111">kind</span><span style="color:#111">,</span> <span style="color:#00a8c8">int</span><span style="color:#f92672">&gt;</span> <span style="color:#111">what</span><span style="color:#111">(</span><span style="color:#00a8c8">int</span> <span style="color:#111">node</span><span style="color:#111">);</span>  <span style="color:#75715e">// forest の頂点が，もとのグラフでは何か?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                  <span style="color:#75715e">// {BLOCK, x} なら ID x である連結成分， {CUT, u} なら関節点 u
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">int</span> <span style="color:#75af00">node</span><span style="color:#111">(</span><span style="color:#111">kind</span> <span style="color:#111">w</span><span style="color:#111">,</span> <span style="color:#00a8c8">int</span> <span style="color:#111">i</span><span style="color:#111">);</span>  <span style="color:#75715e">// what の逆．forest における頂点番号を返す．
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#111">};</span>
</span></span><span style="display:flex;"><span>  <span style="color:#111">bctree</span><span style="color:#f92672">*</span> <span style="color:#75af00">make_bctree</span><span style="color:#111">();</span>   <span style="color:#75715e">// Block Cut Forest を作る．戻り値はポインタであることに注意．
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#111">};</span>
</span></span></code></pre></div><p>典型的な使用法は次のような感じです:</p>
<p>二重辺連結について:</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#00a8c8">int</span> <span style="color:#111">N</span><span style="color:#111">;</span> <span style="color:#111">cin</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#111">N</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#111">bridge</span> <span style="color:#75af00">bu</span><span style="color:#111">(</span><span style="color:#111">N</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00a8c8">for</span> <span style="color:#111">(</span><span style="color:#00a8c8">int</span> <span style="color:#111">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span> <span style="color:#111">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#111">N</span><span style="color:#111">;</span> <span style="color:#111">i</span><span style="color:#f92672">++</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">int</span> <span style="color:#111">u</span><span style="color:#111">,</span> <span style="color:#111">v</span><span style="color:#111">;</span> <span style="color:#111">cin</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#111">u</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#111">v</span><span style="color:#111">;</span> <span style="color:#111">u</span><span style="color:#f92672">--</span><span style="color:#111">;</span> <span style="color:#111">v</span><span style="color:#f92672">--</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">bu</span><span style="color:#111">.</span><span style="color:#111">add_edge</span><span style="color:#111">(</span><span style="color:#111">u</span><span style="color:#111">,</span> <span style="color:#111">v</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00a8c8">int</span> <span style="color:#111">u</span> <span style="color:#f92672">=</span> <span style="color:#111">...,</span> <span style="color:#111">v</span> <span style="color:#f92672">=</span> <span style="color:#111">...;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#111">bu</span><span style="color:#111">.</span><span style="color:#111">is_bridge</span><span style="color:#111">(</span><span style="color:#111">u</span><span style="color:#111">,</span> <span style="color:#111">v</span><span style="color:#111">);</span>  <span style="color:#75715e">// (u, v) は橋か?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#00a8c8">for</span> <span style="color:#111">(</span><span style="color:#00a8c8">int</span> <span style="color:#111">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span> <span style="color:#111">x</span> <span style="color:#f92672">&lt;</span> <span style="color:#111">bu</span><span style="color:#111">.</span><span style="color:#111">num_tecc</span><span style="color:#111">();</span> <span style="color:#111">x</span><span style="color:#f92672">++</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">for</span> <span style="color:#111">(</span><span style="color:#00a8c8">int</span> <span style="color:#111">u</span> <span style="color:#111">:</span> <span style="color:#111">bu</span><span style="color:#111">.</span><span style="color:#111">tecc</span><span style="color:#111">(</span><span style="color:#111">x</span><span style="color:#111">))</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#111">...</span> <span style="color:#111">u</span> <span style="color:#111">...</span> <span style="color:#111">;</span>  <span style="color:#75715e">// x 番目の二重辺連結成分 bu.tecc(x) の要素に順にアクセス
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00a8c8">int</span> <span style="color:#111">x</span> <span style="color:#f92672">=</span> <span style="color:#111">bu</span><span style="color:#111">.</span><span style="color:#111">node_tecc_idx</span><span style="color:#111">[</span><span style="color:#111">u</span><span style="color:#111">];</span>  <span style="color:#75715e">// 頂点 u は x 番目の連結成分に属する
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#00a8c8">for</span> <span style="color:#111">(</span><span style="color:#00a8c8">auto</span> <span style="color:#111">[</span><span style="color:#111">x</span><span style="color:#111">,</span> <span style="color:#111">y</span><span style="color:#111">]</span> <span style="color:#f92672">:</span> <span style="color:#111">bu</span><span style="color:#111">.</span><span style="color:#111">tecc_edges</span><span style="color:#111">())</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// (x, y) が，上述の森の辺をなしている．
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#111">}</span>
</span></span></code></pre></div><p>なお，元のグラフが連結でない場合には，<code>bu.tecc_edges()</code> の関係は
木にはならずに森になります．<code>bu.llk.roots</code> は，
(型は <code>vector&lt;int&gt;</code> )，もとのグラフの連結成分から1点ずつとった集合に
なっています．</p>
<p>二重点連結について:</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#00a8c8">int</span> <span style="color:#111">N</span><span style="color:#111">;</span> <span style="color:#111">cin</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#111">N</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#111">articulation</span> <span style="color:#75af00">au</span><span style="color:#111">(</span><span style="color:#111">N</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00a8c8">for</span> <span style="color:#111">(</span><span style="color:#00a8c8">int</span> <span style="color:#111">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span> <span style="color:#111">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#111">N</span><span style="color:#111">;</span> <span style="color:#111">i</span><span style="color:#f92672">++</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">int</span> <span style="color:#111">u</span><span style="color:#111">,</span> <span style="color:#111">v</span><span style="color:#111">;</span> <span style="color:#111">cin</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#111">u</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#111">v</span><span style="color:#111">;</span> <span style="color:#111">u</span><span style="color:#f92672">--</span><span style="color:#111">;</span> <span style="color:#111">v</span><span style="color:#f92672">--</span><span style="color:#111">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#111">au</span><span style="color:#111">.</span><span style="color:#111">add_edge</span><span style="color:#111">(</span><span style="color:#111">u</span><span style="color:#111">,</span> <span style="color:#111">v</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00a8c8">int</span> <span style="color:#111">u</span> <span style="color:#f92672">=</span> <span style="color:#111">...;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#111">au</span><span style="color:#111">.</span><span style="color:#111">is_articulation</span><span style="color:#111">(</span><span style="color:#111">u</span><span style="color:#111">);</span>  <span style="color:#75715e">// u は関節点か?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#00a8c8">for</span> <span style="color:#111">(</span><span style="color:#00a8c8">int</span> <span style="color:#111">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span> <span style="color:#111">x</span> <span style="color:#f92672">&lt;</span> <span style="color:#111">au</span><span style="color:#111">.</span><span style="color:#111">bcc_size</span><span style="color:#111">();</span> <span style="color:#111">x</span><span style="color:#f92672">++</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">for</span> <span style="color:#111">(</span><span style="color:#00a8c8">int</span> <span style="color:#111">u</span> <span style="color:#111">:</span> <span style="color:#111">au</span><span style="color:#111">.</span><span style="color:#111">bcc</span><span style="color:#111">(</span><span style="color:#111">x</span><span style="color:#111">))</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#111">...</span> <span style="color:#111">u</span> <span style="color:#111">...;</span>  <span style="color:#75715e">// x 番目の二重点連結成分 au.bcc(x) の要素に順にアクセス
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Block-Cut tree に，別のライブラリである Tree を使う場合
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// この下は，元のグラフが連結であるという前提のコードになっている...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//    (ライブラリ自体は，そうでなくても動作はする．bctree() という名前になっているが....)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#00a8c8">auto</span> <span style="color:#111">bctree</span> <span style="color:#f92672">=</span> <span style="color:#111">au</span><span style="color:#111">.</span><span style="color:#111">make_bctree</span><span style="color:#111">();</span>
</span></span><span style="display:flex;"><span>  <span style="color:#111">ll</span> <span style="color:#111">sz</span> <span style="color:#f92672">=</span> <span style="color:#111">bctree</span><span style="color:#f92672">-&gt;</span><span style="color:#111">size</span><span style="color:#111">();</span>  <span style="color:#75715e">// Block-Cut tree の頂点数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#111">Tree</span> <span style="color:#75af00">bct</span><span style="color:#111">(</span><span style="color:#ae81ff">0</span><span style="color:#111">,</span> <span style="color:#111">sz</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00a8c8">for</span> <span style="color:#111">(</span><span style="color:#00a8c8">auto</span> <span style="color:#111">[</span><span style="color:#111">a</span><span style="color:#111">,</span> <span style="color:#111">b</span><span style="color:#111">]</span> <span style="color:#f92672">:</span> <span style="color:#111">bctree</span><span style="color:#f92672">-&gt;</span><span style="color:#111">edges</span><span style="color:#111">())</span> <span style="color:#111">bct</span><span style="color:#111">.</span><span style="color:#111">add_edge</span><span style="color:#111">(</span><span style="color:#111">a</span><span style="color:#111">,</span> <span style="color:#111">b</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">// bctree-&gt;edges() が，Block Cut tree としての辺の関係
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#00a8c8">for</span> <span style="color:#111">(</span><span style="color:#00a8c8">int</span> <span style="color:#111">a</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#111">;</span> <span style="color:#111">a</span> <span style="color:#f92672">&lt;</span> <span style="color:#111">sz</span><span style="color:#111">;</span> <span style="color:#111">a</span><span style="color:#f92672">++</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a8c8">auto</span> <span style="color:#111">[</span><span style="color:#111">w</span><span style="color:#111">,</span> <span style="color:#111">i</span><span style="color:#111">]</span> <span style="color:#f92672">=</span> <span style="color:#111">bctree</span><span style="color:#f92672">-&gt;</span><span style="color:#111">what</span><span style="color:#111">(</span><span style="color:#111">a</span><span style="color:#111">);</span>  <span style="color:#75715e">// aは BLOCK? それとも CUT?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#00a8c8">if</span> <span style="color:#111">(</span><span style="color:#111">w</span> <span style="color:#f92672">==</span> <span style="color:#111">articulation</span><span style="color:#f92672">::</span><span style="color:#111">BLOCK</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// この連結成分は，au.bcc(i) である．
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#111">}</span><span style="color:#00a8c8">else</span> <span style="color:#75af00">if</span> <span style="color:#111">(</span><span style="color:#111">w</span> <span style="color:#f92672">==</span> <span style="color:#111">articulation</span><span style="color:#f92672">::</span><span style="color:#111">CUT</span><span style="color:#111">)</span> <span style="color:#111">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// この関節点は，(もとのグラフの頂点番号で) i である．
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#111">}</span><span style="color:#00a8c8">else</span> <span style="color:#75af00">assert</span><span style="color:#111">(</span><span style="color:#ae81ff">0</span><span style="color:#111">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// what の逆変換が bctree-&gt;node() である．
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#111">}</span>
</span></span><span style="display:flex;"><span>  
</span></span></code></pre></div><p>実装は，lowlink を使っています．DFS 木の行きがけ順を表す
<code>vector&lt;int&gt; _ord</code> と，back edge を高々1回たどって到達できる点の
<code>_ord</code> の値の最小値である <code>vector&lt;int&gt; _low</code> を最初に計算し，これらを用いて
橋や関節点の判定をしています．</p>
<p>一応，ソースは<a href="https://gist.github.com/yamate11/f2b1cdfa626fbf3308e0e0abbc76a226" target="_blank">こちら</a>
にあります．</p>
<h2 id="参考サイト">参考サイト<a hidden class="anchor" aria-hidden="true" href="#参考サイト">#</a></h2>
<p>けむさんの <a href="https://kntychance.hatenablog.jp/entry/2022/09/16/161858" target="_blank">二重連結性と lowlink の話</a>
 がたいへん参考になりました．お礼申し上げます．</p>


  </div>

  <footer class="post-footer">
<nav class="paginav">
  <a class="prev" href="https://yamate11.github.io/blog/posts/2023/11-05-boost-multi-prec/">
    <span class="title">« Prev</span>
    <br>
    <span>boost の多倍長計算</span>
  </a>
  <a class="next" href="https://yamate11.github.io/blog/posts/2023/06-18-abc306g/">
    <span class="title">Next »</span>
    <br>
    <span>Return to 1 - Atcoder Beginner Contest 306 G</span>
  </a>
</nav>

  </footer><p>コメントをどうぞ</p>

<script src="https://y1.is-trm.net/isso/js/embed.min.js"
     data-isso="https://y1.is-trm.net/isso/">
</script>
<section id="isso-thread" data-isso-id="/blog/posts/2023/09-05-bridge/" data-title="二重連結">
</section>

<p>Links to Recent Posts:
  / <a href="https://yamate11.github.io/blog/posts/">Posts</a>
  / <a href="https://yamate11.github.io/blog/posts/2024/04-24-number-of-primes/">素数表</a>
  / <a href="https://yamate11.github.io/blog/posts/2024/04-18-union-find-with-potential/">ポテンシャル付きUnionFind</a>
  / <a href="https://yamate11.github.io/blog/posts/2024/03-30-matrix/">行列ライブラリ</a>
  / <a href="https://yamate11.github.io/blog/posts/2024/03-25-arc175-c/">ARC175-C Jumping Through Intervals</a>
  / <a href="https://yamate11.github.io/blog/posts/2024/03-24-abc346-g/">ABC346-G Alone</a>
  / <a href="https://yamate11.github.io/blog/posts/2024/03-13-tree-lib/">木ライブラリ</a>
  / <a href="https://yamate11.github.io/blog/posts/2024/02-19-binary-search/">二分探索ライブラリ</a>
  / <a href="https://yamate11.github.io/blog/posts/2024/02-14-extended-gcd/">拡張ユークリッドアルゴリズム</a>
  / <a href="https://yamate11.github.io/blog/posts/2022/08-17-rerooting/">全方位木ライブラリ</a>
</p>


</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://yamate11.github.io/blog/">yamate11のブログ</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
