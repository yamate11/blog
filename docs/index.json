[{"content":"Atcoder Beginner Contest 215 (ABC215) H Cabbage Master に関する記事です． 公式解説そのままですけれど，予備知識を一応書きました．\n問題へのリンク https://atcoder.jp/contests/abc215/tasks/abc215_h 経緯 コンテスト中は，そもそもHには到達もしませんでした． コンテスト後に考えましたが，歯が立ちませんでした．\n Hall の定理は，見たことはあったけど，覚えていなかった 高速ゼータ変換や高速メビウス変換のライブラリは持っていたのですが， どう使うか知らなかった．  というわけなので，解けるはずがありませんでした．\n問題概要 正の整数$N$, $M$; 各 $i\\in [1, N]$ と 各 $j \\in [1, M]$ に対して 正の整数 $A_i$, $B_j$, および $C_{ij} \\in \\{0, 1\\}$ が与えられる． ただし，任意の $j$ に対して $i$ が存在して $C_{ij} = 1$ である．\n$i\\in [1, N]$ に対して $|D_i| = A_i$ となる互いに素な集合 $D_i$ を固定し， $D = \\bigcup \\{ D_i \\mid i \\in [1, N] \\}$ と書く． $D$ の部分集合 $E$ と $i \\in [1, N]$ に対して，$E_i := E \\cap D_i$ とする． $E$ に関する次の条件を考える．\n $E$ の $M$ 個の分割 $(F_1, \\ldots, F_M)$ で，以下を満たすものは存在しない  $F_j \\cap E_i \\neq \\emptyset \\implies C_{ij} = 1$ 各 $i \\in [1,N]$ に対して， $ \\bigcup \\{ F_j \\cap E_i \\mid j \\in [1,M] \\} \\geq B_j $    条件を満たす $E$ のうち，$X = |D - E|$ の最小値を求めよ． また，最小値を与える $E$ の個数を，mod 998244353 で求めよ．\n制約: $N \\leq 20$; $M \\leq 10^4$; $A_i, B_j \\leq 10^5$\n予備知識 Hall の定理 $A$, $B$ を有限集合，$G \\subseteq A \\times B$ とするとき， 以下の2条件は同値である．\n 単射 $f: A \\to B$ で，$(a, f(a)) \\in G$ であるものが存在する． 任意の $X \\subseteq A$ に対して，$ |X| \\leq |f[X]|$．  ただし，$f[X] := \\{ b \\in B \\mid \\exists a \\in A. f(a) = b \\}$．\n証明は，たとえば高校数学の美しい物語 に載っています．\nゼータ変換，メビウス変換 $A$ を有限集合とする．$A$の冪集合を $ \\mathcal{P}(A) $ と書く．\n$ f : \\mathcal{P}(A) \\to M $ に対して， $ \\zeta_{U}(f) : \\mathcal{P}(A) \\to M $ と $ \\zeta_{L}(f) : \\mathcal{P}(A) \\to M $ を， 次で定義する．\n $ \\zeta_{U}(f)(X) = \\sum \\{ f(Y) \\mid X \\subseteq Y \\} $ $ \\zeta_{L}(f)(X) = \\sum \\{ f(Y) \\mid Y \\subseteq X \\} $  作り方を考えると，$\\zeta_{U}$, $\\zeta_{L}$ には，逆変換が存在する． これらを，$\\mu_{U}$, $\\mu_L$ と書く．\n高速ゼータ変換，高速メビウス変換 以下のアルゴリズムによって， $(f(X) \\mid X \\subseteq A)$ が与えられた時に $\\alpha = \\zeta_U, \\zeta_L, \\mu_U, \\mu_L$ に対し， $(\\alpha(f)(X) \\mid X \\subseteq A)$ を，$O(|A| \\log|A|)$ で 計算できる．\n 配列 $P := [(X, f(X)) \\mid X \\subseteq A]$ 各 $x \\in A$ に対して以下によって $P$ を更新する．  各 $X \\subseteq A \\setminus \\{x\\}$ に対して $Y := X \\cup \\{x\\}$ とおいて， $(P[X], P[Y]) := (P[X] + u P[Y], v P[X] + P[Y])$    ただし，$u$, $v$ は，以下の値を使う\n $\\zeta_U$ \u0026hellip; $(u, v) = (1, 0)$ $\\zeta_L$ \u0026hellip; $(u, v) = (0, 1)$ $\\mu_U$ \u0026hellip; $(u, v) = (-1, 0)$ $\\mu_L$ \u0026hellip; $(u, v) = (0, -1)$  妥当性の説明は，「高速ゼータ変換」で検索すると，いろいろなところに出ています．\n解法 公式解説 そのままです．\n次のように定める．\n $T_j := \\{ i \\in [1, N] \\mid C_{ij} = 1 \\}\\qquad (j \\in [1, M])$ $f(S) := \\sum \\{ A_i \\mid i \\in S \\} \\qquad S \\subseteq [1, N]$ $g(S) := \\sum \\{ B_j \\mid T_j ⊆ S \\}\\qquad S \\subseteq [1, N]$  $f$ は，愚直に $O(N 2^N)$ で計算できる． $g$ は，$\\zeta_L$ を使って $O(NM + N 2^N)$ で計算できる．\nHall の定理を使うために，$j \\in [1, M]$ に対して $|H_j| = B_j$ なる互いに素な集合を用意して， $H := \\bigcup \\{H_j \\mid j \\in [1, M]\\}$ とする． $G := \\{(d, h) \\in E \\times H \\mid d \\in E_i, h \\in H_j, C_{i,j} = 1 \\}$ Hall の定理から，$E$ が上記の条件を満たすための必要十分条件は\n $f(E, S) \u0026lt; g(S)$ となる $S \\subseteq [1, N]$ が存在する  ことである．ただし，\n $f(E, S) := \\sum \\{ | E_i | \\mid i \\in S \\} \\qquad S \\subseteq [1, N]$  である．したがって，$f(S) \u0026gt; 0$ である 全部の $S \\subseteq [1, N]$ に対する $ f(S) - g(S) + 1 $ の最小値が，求める $X$ の値となる． (ただし，0以下の時にはそもそも$A$が分割できないので，$X=0$)．\n後半は，$X= 0$ なら個数は 1 なので，$X\u0026gt; 0$ とする．\n $F := \\{ S \\subseteq [1, N] \\mid f(S) - g(S) + 1 = X \\}$  とする．$S \\subseteq [1, N]$ に対し，\n $h(S)$ := $D$ から $X$ 個の要素を選ぶ方法のうち，選ばれた要素の添字の 集合がちょうど $S$ となるものの数  とする．求める答は\n $\\sum \\{ h(S) \\mid \\exists S' \\in F.\\; S \\subseteq S' \\}$  である．$S \\subseteq [1, N]$ が $\\exists S' \\in F.\\; S \\subseteq S'$ を満たすかどうかは， $F$ の特性関数を $\\zeta_U$ で変換することで分かる． また，$p := \\zeta_L(h)$ とおくと，\n $p[S] = \\bigcup \\{ D_i \\mid i \\in S \\}$ から X 個の要素を選ぶ方法の数 = $\\binom{f(S)}{X}$  である．したがって，$h$ は，$\\mu_L(p)$ で求めることができる．\nACコード https://atcoder.jp/contests/abc215/submissions/25289505 ","permalink":"https://yamate11.github.io/blog/posts/2021/08-23-cabbage-master/","summary":"Atcoder Beginner Contest 215 (ABC215) H Cabbage Master に関する記事です． 公式解説そのままですけれど，予備知識を一応書きました．\n問題へのリンク https://atcoder.jp/contests/abc215/tasks/abc215_h 経緯 コンテスト中は，そもそもHには到達もしませんでした． コンテスト後に考えましたが，歯が立ちませんでした．\n Hall の定理は，見たことはあったけど，覚えていなかった 高速ゼータ変換や高速メビウス変換のライブラリは持っていたのですが， どう使うか知らなかった．  というわけなので，解けるはずがありませんでした．\n問題概要 正の整数$N$, $M$; 各 $i\\in [1, N]$ と 各 $j \\in [1, M]$ に対して 正の整数 $A_i$, $B_j$, および $C_{ij} \\in \\{0, 1\\}$ が与えられる． ただし，任意の $j$ に対して $i$ が存在して $C_{ij} = 1$ である．\n$i\\in [1, N]$ に対して $|D_i| = A_i$ となる互いに素な集合 $D_i$ を固定し， $D = \\bigcup \\{ D_i \\mid i \\in [1, N] \\}$ と書く． $D$ の部分集合 $E$ と $i \\in [1, N]$ に対して，$E_i := E \\cap D_i$ とする． $E$ に関する次の条件を考える．","title":"Cabbage Master - Atcoder Beginner Contest 215 H"},{"content":"高速アダマール変換によって，xor畳み込みをする方法についての記事 (自分用のメモ) です．\nxor畳み込み 長さ $2^K$ の数列 $X$, $Y$ があるとき， これらのxor畳み込みを，以下を満たす長さ $2^K$ の列 $Z$ として定める． ただし，$x \\oplus y$ は $x$ と $y$ の xor とする．\n $ Z_k = \\sum \\{ X_i Y_j \\mid i \\oplus j = k \\} $  以下では，$Z = X * Y$ と書く．\nアダマール変換 長さ $2^K$ の数列に作用するアダマール変換は，以下の行列 $H_K$ で定義される 1次変換である．\n$$ H_0 = 1 $$\n$$ H_{k + 1} = \\begin{bmatrix} H_k \u0026amp; H_k \\\\\nH_k \u0026amp; -H_k \\end{bmatrix} $$\n本来は，正規化のために定数倍するが， ここでは，結果を整数にするためにそうしていない．\n$ H_k H_k = 2^k I $ が成り立つので，$(H_k)^{-1} = 2^{-k} H_k$ である．\n畳み込みとアダマール変換 以下が成り立つことが，計算することで容易に分かる．\n$$ (H_K X) (H_K Y) = H_K (X * Y) $$\nただし，左辺は，成分ごとの積．したがって，xor 畳み込みは，下のように計算できる．\n$$ X * Y = 2^{-K} H_K ((H_K X) (H_K Y)) $$\nアダマール変換は，定義に従って $O(n \\log n)$ で計算できる．($n = 2^K$)\nメモリを賢く使って計算している例が kazuma8128\u0026#39;s blog に載っている．\nこれを使える問題 ABC212 H Nim Counting ","permalink":"https://yamate11.github.io/blog/posts/2021/08-10-xor-conv/","summary":"高速アダマール変換によって，xor畳み込みをする方法についての記事 (自分用のメモ) です．\nxor畳み込み 長さ $2^K$ の数列 $X$, $Y$ があるとき， これらのxor畳み込みを，以下を満たす長さ $2^K$ の列 $Z$ として定める． ただし，$x \\oplus y$ は $x$ と $y$ の xor とする．\n $ Z_k = \\sum \\{ X_i Y_j \\mid i \\oplus j = k \\} $  以下では，$Z = X * Y$ と書く．\nアダマール変換 長さ $2^K$ の数列に作用するアダマール変換は，以下の行列 $H_K$ で定義される 1次変換である．\n$$ H_0 = 1 $$\n$$ H_{k + 1} = \\begin{bmatrix} H_k \u0026amp; H_k \\\\","title":"xor畳み込み"},{"content":"C++ での型の変換などのいろいろな変換方法を書いておきます． 競技プログラミング用途です．ソース冒頭に次のように書いてあるものとします．\n#include \u0026lt;bits/stdc++.h\u0026gt;typedef long long int ll; using namespace std; 文字列→数値 std::stoi, std::stoll を使う．2進数などを読みたいときは，base を指定すれば良い．\nint stoi( const string\u0026amp; str, size_t* pos=0, int base=10 ); long long stoll( const string\u0026amp; str, size_t* pos=0, int base=10 ); 使用例\nstring s1 = \u0026#34;101\u0026#34;; ll x = stoll(s1); // x == 101  ll y = stoll(s1, 0, 2); // y == 5 似たような名前で std::strtoll などもあるが， これらは引数に const char* を取る． const string\u0026amp; を引数に取る stoll などの方が便利だろう．\n実数への変換は，std::stod, std::stold を使う．\ndouble stod( const string\u0026amp; str, size_t* pos = 0 ); long double stold( const string\u0026amp; str, size_t* pos = 0 ); 数値→文字列 std::to_string を用いる．\nstring to_string( int value ); string to_string( long long value ); string to_string( unsigned value ); string to_string( unsigned long long value ); string to_string( double value ); string to_string( long double value ); 16進表記文字列にしたいとか 8進にしたいとかいう場合には， 1つの関数を適用して終わりというわけにはいかないように思う． 次のような感じだろう．\nll value = 256; stringstream ss; ss \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; value; string s = ss.str(); // s == \u0026#34;100\u0026#34; 8進にするときには hex の代わりに oct を用いる．\n2進の場合はbitsetを用いる． 下の例では，value2 の2進表現が長さ8の文字列になる．\nll value2 = 30; string s2 = bitset\u0026lt;8\u0026gt;(value2).to_string(); // s2 == \u0026#34;00011110\u0026#34; 実数→整数 普通にキャストすれば良い場合も多いが，いろいろ罠がある．\ndouble d = -26.001; ll x = ll(d + 0.5); // x == -25 (!!) これは，dが負の場合には意図したようには動作しない． 0に向かって丸められてしまうからである． 次を用いる．\ndouble d = -26.001; ll x = llround(d); // x == -26 round関数などのsignature は以下のようになっている．\ndouble round ( double arg ); long double roundl( long double arg ); long lround ( double arg ); long lroundl( long double arg ); long long llround ( double arg ); long long llroundl( long double arg ); 定数の 1,000,000,007 などを書くのが面倒で，\nconst ll mod = 1e9 + 7; などと書いてしまうことがある．上の例は意図したように動くようであるが，\nconst ll big1 = 1e18; const ll big2 = 1e18 + 1; については，big1 も big2 も 同じ値になってしまう． (gccの場合) double の精度は十進で15桁くらい，long double は18桁くらいである．\n","permalink":"https://yamate11.github.io/blog/posts/2021/02-07-int-string-trans/","summary":"C++ での型の変換などのいろいろな変換方法を書いておきます． 競技プログラミング用途です．ソース冒頭に次のように書いてあるものとします．\n#include \u0026lt;bits/stdc++.h\u0026gt;typedef long long int ll; using namespace std; 文字列→数値 std::stoi, std::stoll を使う．2進数などを読みたいときは，base を指定すれば良い．\nint stoi( const string\u0026amp; str, size_t* pos=0, int base=10 ); long long stoll( const string\u0026amp; str, size_t* pos=0, int base=10 ); 使用例\nstring s1 = \u0026#34;101\u0026#34;; ll x = stoll(s1); // x == 101  ll y = stoll(s1, 0, 2); // y == 5 似たような名前で std::strtoll などもあるが， これらは引数に const char* を取る． const string\u0026amp; を引数に取る stoll などの方が便利だろう．","title":"文字列，数値変換"},{"content":"経緯 よく考えればもちろん作れるのだけれど，すぐ間違うのでメモをしておきます．\n公式 $d \\in \\mathbb{Z}$，$t \\in \\mathbb{R}$ とする．\n $d \\leq t \\iff d \\leq \\lfloor t \\rfloor$ $d \u0026lt; t \\iff d \u0026lt; \\lceil t \\rceil$ $t \\leq d \\iff \\lceil t \\rceil \\leq d$ $t \u0026lt; d \\iff \\lfloor t \\rfloor \u0026lt; d$  考え方 \\begin{eqnarray*} d\\leq t \u0026amp;\\iff\u0026amp; t \\in \\{ t \\mid d \\leq t \\} \\\\\n\u0026amp;\\iff\u0026amp; t \\in \\bigcup \\{ [e, e+1) \\mid e = d, d+1, \\ldots \\} \\\\\n\u0026amp;\\iff\u0026amp; \\bigvee \\{ t \\in [e, e+1) \\mid e = d, d+1, \\ldots \\} \\\\\n\u0026amp;\\iff\u0026amp; \\bigvee \\{ \\lfloor t \\rfloor = e \\mid e = d, d+1, \\ldots \\} \\\\\n\u0026amp;\\iff\u0026amp; d \\leq \\lfloor t \\rfloor \\hspace{20em} \\end{eqnarray*}\n同様に，\n\\begin{eqnarray*} d\u0026lt;t \u0026amp;\\iff\u0026amp; t \\in \\{ t \\mid d \u0026lt; t \\} \\\\\n\u0026amp;\\iff\u0026amp; \\bigvee \\{ t \\in (e-1, e] \\mid e = d+1, d+2, \\ldots \\} \\\\\n\u0026amp;\\iff\u0026amp; \\bigvee \\{ \\lceil t \\rceil = e \\mid e = d+1, d+2, \\ldots \\} \\\\\n\u0026amp;\\iff\u0026amp; d \u0026lt; \\lceil t \\rceil \\hspace{20em} \\end{eqnarray*}\n\\begin{eqnarray*} t \\leq d \u0026amp;\\iff\u0026amp; \\bigvee \\{ t \\in (e-1, e] \\mid e = d, d - 1, \\ldots \\} \\\\\n\u0026amp;\\iff\u0026amp; \\bigvee \\{ \\lceil t \\rceil = e \\mid e = d, d - 1, \\ldots \\} \\\\\n\u0026amp;\\iff\u0026amp; \\lceil t \\rceil \\leq d \\hspace{20em} \\end{eqnarray*}\n\\begin{eqnarray*} t \u0026lt; d \u0026amp;\\iff\u0026amp; \\bigvee \\{ t \\in [e, e+1) \\mid e = d - 1, d - 2, \\ldots \\} \\\\\n\u0026amp;\\iff\u0026amp; \\bigvee \\{ \\lfloor t \\rfloor = e \\mid e = d - 1, d - 2, \\ldots \\} \\\\\n\u0026amp;\\iff\u0026amp; \\lfloor t \\rfloor \u0026lt; d \\hspace{20em} \\end{eqnarray*}\n","permalink":"https://yamate11.github.io/blog/posts/2021/02-13-int-inequality-floor/","summary":"経緯 よく考えればもちろん作れるのだけれど，すぐ間違うのでメモをしておきます．\n公式 $d \\in \\mathbb{Z}$，$t \\in \\mathbb{R}$ とする．\n $d \\leq t \\iff d \\leq \\lfloor t \\rfloor$ $d \u0026lt; t \\iff d \u0026lt; \\lceil t \\rceil$ $t \\leq d \\iff \\lceil t \\rceil \\leq d$ $t \u0026lt; d \\iff \\lfloor t \\rfloor \u0026lt; d$  考え方 \\begin{eqnarray*} d\\leq t \u0026amp;\\iff\u0026amp; t \\in \\{ t \\mid d \\leq t \\} \\\\\n\u0026amp;\\iff\u0026amp; t \\in \\bigcup \\{ [e, e+1) \\mid e = d, d+1, \\ldots \\} \\\\","title":"整数・実数の大小比較とfloor, ceil"},{"content":"Atcoder Regular Contest 104 (ARC 104) E Random LIS に関する記事です．\n問題文へのリンク https://atcoder.jp/contests/arc104/tasks/arc104_e 経緯 過去問埋めで解いてみようとしましたが，全然わかりませんでした． 公式解説 を読んでもやっぱりわからず， けんちょんさんの解説 を読んで，なんとか理解することができました．\n解法 例えば，N = 4 として，数列 10 7 10 15 と数列 5 1 5 2000 は， 数値の差こそあれ，大小関係は同一である．これらを 1 0 1 2 というパターンとして 1つのグループとしてまとめることにする．以下を実行する．\n 全パターンを列挙する． 各パターンについて，  LISの長さを求める． そのパターンに属する数列の数を数える．    グループがいくつあるかは， Ordered Bell number として知られているということである．N = 6 の場合には，4683個． 丁寧に列挙することもできるであろうが，$6^6 = 46656$ であるから，0 から N-1 までの 数の N 個の並びから，不適なものを弾いても十分速い． 各グループに属する数列では，LIS の長さは同じであり，N \u0026lt;= 6 だからこれを求めるのは容易である． 各グループに属する数列の数を求めるのが主要なタスクとなる．\n$\\{0, 1\\} \\cup \\{A_i + 1\\mid i = 1, \\ldots, N\\}$ を昇順にソートして $p_0, p_1, .., p_M$ とし，$P_i$ を整数の半開区間 $[p_i, p_{i+1})$ とする．\nパターンを1つとる．パターン中に現れる数が $0, 1, \\ldots, D-1$ だとする． 各 $d \\in [0, D)$ について，これが現れる位置を $q_1, \\ldots, q_k$ としたとき，$\\min(A_{q_1}, \\ldots, A_{q_k})$ を $B_d$ とする． たとえば，パターン 2 2 2 0 1 1 については，$B_0 = A_3$, $B_1 = \\min(A_4, A_5)$, $B_2 = \\min(A_0, A_1, A_2)$ である． すると，パターンに属する数列の数は，数列 $( x_d | d \\in [0, D) )$ であって $x_d \\in [1, B_d + 1)$ を満たすものの数に等しいので，これを数えることにする．\n動的計画法による． 「長さ i の列 $( x_d | d \\in [0, i) )$ で $x_d \\in [1, B_d + 1)$ を満たし，$ x_{i-1} \\in P_j $ であるもの」の集合を $S_{i,j}$ とし，dp[i][j] を，$S_{i,j}$ の要素の数とする． 普通に dp[i][j] → dp[i+1][j'] の遷移を書こうとすると， j = j' の時にうまくいかない． そこで，次のことに注目する: 長さ i の列 $(x_d \\mid d \\in [0, i) )$ について，次の2つは同値である．\n $( x_d \\mid d \\in [0, i) ) \\in S_{i,j}$ $k \u0026lt; i$, $u \u0026lt; j$ が存在して，以下が成り立つ．  $(x_d \\mid d \\in [0, k) ) \\in S_{k, u}$ 各 $e \\in [k, i)$ に対して，$B_e + 1 \\geq p_{j+1}$ $i - k \\leq p_{j+1} - p_j$    そこで，以下のように遷移を定義することができる:\ndp[i][j] ← dp[k][u] * binom(p[j+1] - p[j], i - k) where * i \u0026gt; k and * j \u0026gt; u and * i - k \u0026lt;= p[j+1] - p[j] and * forall e in [k, i). B[e] + 1 \u0026gt;= p[j+1] ACコード https://atcoder.jp/contests/arc104/submissions/25160111 ","permalink":"https://yamate11.github.io/blog/posts/2021/08-19-random-lis/","summary":"Atcoder Regular Contest 104 (ARC 104) E Random LIS に関する記事です．\n問題文へのリンク https://atcoder.jp/contests/arc104/tasks/arc104_e 経緯 過去問埋めで解いてみようとしましたが，全然わかりませんでした． 公式解説 を読んでもやっぱりわからず， けんちょんさんの解説 を読んで，なんとか理解することができました．\n解法 例えば，N = 4 として，数列 10 7 10 15 と数列 5 1 5 2000 は， 数値の差こそあれ，大小関係は同一である．これらを 1 0 1 2 というパターンとして 1つのグループとしてまとめることにする．以下を実行する．\n 全パターンを列挙する． 各パターンについて，  LISの長さを求める． そのパターンに属する数列の数を数える．    グループがいくつあるかは， Ordered Bell number として知られているということである．N = 6 の場合には，4683個． 丁寧に列挙することもできるであろうが，$6^6 = 46656$ であるから，0 から N-1 までの 数の N 個の並びから，不適なものを弾いても十分速い． 各グループに属する数列では，LIS の長さは同じであり，N \u0026lt;= 6 だからこれを求めるのは容易である． 各グループに属する数列の数を求めるのが主要なタスクとなる．","title":"Random LIS - Atcoder Regular Contest 104 E"},{"content":"筆者の競プロ用のブログです．\n筆者 yamate11\n Twitter: _yamate11  AtCoder: yamate11  CodeForces: yamate11   Powered by Hugo and PaperMod\n","permalink":"https://yamate11.github.io/blog/pages/about/","summary":"筆者の競プロ用のブログです．\n筆者 yamate11\n Twitter: _yamate11  AtCoder: yamate11  CodeForces: yamate11   Powered by Hugo and PaperMod","title":"このサイトについて"},{"content":"発端 自分で書いた SCC (強連結成分分解) ライブラリを使っているのですが， これが，AC-library の SCC に比べて，4倍くらい遅いのです． どこが遅いのか調べてみたら，意外なところにもネックがありました．\n最初は，主に使っているアルゴリズムのせいだと思ったのです． 深さ優先探索を2回行うアルゴリズム (たとえばここ を参照) を使っていました． AC-library は，Tarjan のアルゴリズム を使っているようなので，合わせれば速くなるだろう，と思って 書きかえました．\nたしかに速くなったのですが，それでもまだAC-libraryより3倍ほど遅いです．\nvector\u0026lt;vector\u0026lt;*\u0026gt; \u0026gt; 部分に分けて測定してみたところ，どうも，グラフの情報を設定しているところも 遅い，ということが分かりました． こんな感じのコードなのですが:\nint N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; // N は頂点数, M は辺の数 vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; edges; for (int i = 0; i \u0026lt; M; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; // 0-indexed で入力されると仮定  edeges.emplace_back(u, v); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; fwd(N); // fwd[i] は，i から直接行ける頂点たち． // (1) for (auto [u, v] : edges) { fwd[u].push_back(v); } // (2) この，(1)から(2)までの部分で，結構時間を食っています． Tarjan のアルゴリズムを実行するのと同程度の時間がかかっているように見えました．\nCSR AC-library はそこをどう処理しているのか，と，見てみましたら， CSR なる構造体を使っていました． おそらく， Compressed Sparse Row のことだと思います． すべて1次元のベクトルでの処理になります．\nたとえば，{(0, 5), (0, 7), (1, 4), (2, 3), (2, 8)} を格納する場合には， まず，遷移先の {5, 7, 4, 3, 8} を vector\u0026lt;int\u0026gt; に格納します． それで，別の vector\u0026lt;int\u0026gt; に，{0, 2, 3, 5} を格納します． これは，遷移元が 0 の遷移先は [0, 2) に格納されており， 遷移元が1 の遷移先は [2, 3) に格納されており，遷移元が2の 遷移先は，[3, 5) に格納されている，ということを示しています．\nちょっと上のリンクで説明されているCSRより簡略になっていますが， 考え方は同じだと思います．\n性能比較 ここで，CSR と vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; を使った場合の SCC の性能比較を書くべきところですが， ちょっといろいろあって，まだできていないので， 代わりに木DPで試してみました．\nランダムに作成した木の辺を与えて，各ノードの子孫のノードの数を 数えるというプログラムです． 木のノード数を$2\\times 10^5$ 程度にしてみると，次のようになりました:\n   Sとして何を使うか vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; CSR     標準入力から vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; への読み込み 47ms 47ms (左と同じコード)   vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; から S への変換 48ms 31ms   S を使って子孫ノード数を数える 47ms 14ms    \u0026hellip;. あっと驚くほどには違っていませんね．羊頭狗肉でした．\n性能比較に使ったファイルは こちら です．(gen.py は，データ生成用スクリプト)\n","permalink":"https://yamate11.github.io/blog/posts/2021/08-15-perf-vect-vect/","summary":"発端 自分で書いた SCC (強連結成分分解) ライブラリを使っているのですが， これが，AC-library の SCC に比べて，4倍くらい遅いのです． どこが遅いのか調べてみたら，意外なところにもネックがありました．\n最初は，主に使っているアルゴリズムのせいだと思ったのです． 深さ優先探索を2回行うアルゴリズム (たとえばここ を参照) を使っていました． AC-library は，Tarjan のアルゴリズム を使っているようなので，合わせれば速くなるだろう，と思って 書きかえました．\nたしかに速くなったのですが，それでもまだAC-libraryより3倍ほど遅いです．\nvector\u0026lt;vector\u0026lt;*\u0026gt; \u0026gt; 部分に分けて測定してみたところ，どうも，グラフの情報を設定しているところも 遅い，ということが分かりました． こんな感じのコードなのですが:\nint N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; // N は頂点数, M は辺の数 vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; edges; for (int i = 0; i \u0026lt; M; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; // 0-indexed で入力されると仮定  edeges.emplace_back(u, v); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; fwd(N); // fwd[i] は，i から直接行ける頂点たち． // (1) for (auto [u, v] : edges) { fwd[u].","title":"vector\u003cvector\u003c*\u003e\u003e はあんまり速くない"},{"content":"JOI 2020/2021 二次予選 「イベント巡り (Event Hopping)」 に関する記事です． 公式解説 を読みきれなかったので\u0026hellip;.\n問題へのリンク https://atcoder.jp/contests/joi2021yo2/tasks/joi2021_yo2_c 解法 ちょっと不思議な感じで，小課題3 を (私の感覚では) 自然に解くと， それが満点解法にもなっているという\u0026hellip; (解説を読むまでわからなかったのですけれど)\nソートして，$S_i$ が昇順になっているとします． ナイーブに考えると，次の DP になります．\n dp[i][j] := i番目のイベントに参加する直前までに参加したイベントの 回数が j であるような方法がある (True/False)  遷移としては，dp[i][j] = True となる j について，\n 町 $P_i$ で行われるイベントで，時刻 $S_i + 1$ 以降最も早いものを i1 町 $3 - P_i$ で行われるイベントで， 時刻 $S_i + 1 + D + K(j + 1)$ 以降最も早いものを i2  として，\n dp[i1][j+1] := True dp[i2][j+1] := True  と設定することになります．でも，これは $\\Omega(N^2)$ なので，間に合いません．\n実は，回数を全部見る必要がなくて，各々のイベントに参加するまでに， 最も多くの回数のイベントに参加してきた方法だけ考えれば十分です． ただし，「ある時点までに多くの回数のイベントに参加した方が， 最終的なイベント参加回数が多い」ということは言えません． 次のような例があります．\n $D = 1$, $K = 100$ $S_1 = 1$, $P_1 = 1$ $S_2 = 1000$, $P_2 = 2$ $S_3 = 1150$, $P_3 = 1$ $S_4 = 1151$, $P_4 = 1$  町 1 から出発して イベント 1 に参加した直後に 2 に移る (方法A) と， イベント2 の直前に，今まで参加した回数は 1 です． 一方，町2から出発する (方法B) と，イベント2の直前に， 今まで参加した回数は 0 で，方法Aの方が多いです． しかし，方法B の方は，このあと イベント2, 3, 4 に参加して最終の回数が3回にできますが， 方法Aは，最終的に2回しか参加できません．\nしかし，以下は成り立ちます:\n補題 各イベント $i$ に対し，そのイベントに参加する前に参加できるイベント数の 最大値を $M(i)$ とする． 求める答を $X$ とする． 条件を満たしてイベントに参加していく方法 $e_0, \\ldots, e_{X-1}$ であって， 任意の $j = 0, \\ldots, X-1$ に対して，$M(e_j) = j$ となるものが存在する．\n補題が言えれば，DP として，以下のものをとれます:\n dp[i] := $M(i)$  遷移としては，$dp[i]$ が計算できたらば，上で述べた i1 と i2 を取って，\n dp[i1] := max(dp[i1], dp[i] + 1) dp[i2] := max(dp[i2], dp[i] + 1)  とすれば良いです．(仮想的に，十分遅く行われるN番目のイベントを考えて) dp[N] が求める答となります．このDPは，$O(N\\log N)$ で実行できます．\n補題の証明です．帰謬法によることにして，そのような方法がないとすると， $X$を達成するどの方法についても $M(e_j) \u0026gt; j$ となる $j$ があります． 各方法 $\\alpha$ についてそのような $j$ の最大値を$j_\\alpha$ とし， その最小値を与える $\\alpha$ を取ります． すなわち，$M(e_{j_\\alpha}) \u0026gt; j_\\alpha$ です． イベント $e_{j_\\alpha}$ が行われる町を $p$ として， イベント $e_{j_\\alpha + 1}$ が行われる町を $q$ とすると， $ p \\neq q $ であることに注意します． $M(e_{j_\\alpha})$ を与える方法$\\beta$ をとり， $\\beta$の$j_\\alpha$番目のイベント $e$ までの部分を $\\beta'$ とします． イベント $e$ が $q$ で行われる場合には，$\\beta'$ の後に， $q$ に $e_{j_\\alpha + 1}$ まで残り続けて，その後 $\\alpha$ と 同じに振る舞う方法を $\\gamma$ とします． イベント $e$ が $p$ で行われる場合には，$\\beta'$ の直後に$q$に 移り，その後$e_{j_\\alpha + 1}$ まで $q$ にいて，その後 $\\alpha$ と 同じに振る舞う方法を $\\gamma$ とします． いずれの場合にも，$\\gamma$ は $X$ を達成する方法であり， $j_\\gamma \u0026lt; j_\\alpha$ となり，矛盾しました．\nACコード https://atcoder.jp/contests/joi2021yo2/submissions/25099364 ","permalink":"https://yamate11.github.io/blog/posts/2021/08-16-event-hopping/","summary":"JOI 2020/2021 二次予選 「イベント巡り (Event Hopping)」 に関する記事です． 公式解説 を読みきれなかったので\u0026hellip;.\n問題へのリンク https://atcoder.jp/contests/joi2021yo2/tasks/joi2021_yo2_c 解法 ちょっと不思議な感じで，小課題3 を (私の感覚では) 自然に解くと， それが満点解法にもなっているという\u0026hellip; (解説を読むまでわからなかったのですけれど)\nソートして，$S_i$ が昇順になっているとします． ナイーブに考えると，次の DP になります．\n dp[i][j] := i番目のイベントに参加する直前までに参加したイベントの 回数が j であるような方法がある (True/False)  遷移としては，dp[i][j] = True となる j について，\n 町 $P_i$ で行われるイベントで，時刻 $S_i + 1$ 以降最も早いものを i1 町 $3 - P_i$ で行われるイベントで， 時刻 $S_i + 1 + D + K(j + 1)$ 以降最も早いものを i2  として，\n dp[i1][j+1] := True dp[i2][j+1] := True  と設定することになります．でも，これは $\\Omega(N^2)$ なので，間に合いません．","title":"イベント巡り (Event Hopping) - JOI 2020/2021 二次予選"},{"content":"Atcoder Beginner Contest 213 (ABC-213) H - Stroll に関する記事です．\n問題へのリンク \r解法 公式解説 を読んでもよくわからなかったのですが， Motsu_xeさんによる，オフライン・オンライン変換 の説明がわかりやすかったです． 以下の説明は，ほとんど，上の2つの記事に依っています．\n記法を定めます．\n $f(x, i) :=$ 地点$x$に距離$i$で到達する方法の数 $p(x, y, i) :=$ 地点 $x$ と地点 $y$ を結ぶ距離 $i$ の道の数 $X := \\{1, \\ldots, N\\}$  したがって，$f(1, T)$ が求める答です．次の関係が成り立ちます:\n $f(1, 0) = 1$ $f(y, 0) = 0\\quad(y \\neq 1)$ $f(x, i) = \\sum \\{ f(y, j) \\cdot p(x, y, i - j) \\mid y \\in X, j \\in [0, i) \\}$  最後の式は，一見，畳み込みですが，右辺にも $f$ が出てきてしまうので， ただちには FFT に渡せません．ここを 分割統治FFTなる手法で求めようという趣旨であるようです．\nさらに記法です．上の最後の式を少しいじります．\n $ s(x, i, l, m) := \\sum \\{ f(y, j) \\cdot p(x, y, i - j) \\mid y \\in X, j \\in [l, m) \\}$  見比べて，次が成り立ちます:\n $ f(x, i) = s(x, i, 0, i) $  DPで，dp[x, i] を計算していきます． 2つの手続き solve(l, r) と induce(l, m, r) を次のように定めます． a:b は，Python風に半開区間 [a,b) を表すものとします． 配列 v に対して，v[a:b] は，vの，添字a以上b未満の部分です．\nprocedure solve(l, r) { assume(forall i \\in [0,l), x \\in X. dp[x, i] == f(x, i)) assume(forall i \\in [l,r), x \\in X. dp[x, i] == s(x, i, 0, l)) if (l + 1 == r) return; m := floor((l + r) / 2); call solve(l, m); call induce(l, m, r); call solve(m, r); assert(forall i \\in [0,r), x \\in X. dp[x, i] == f(x, i)) } procedure induce(l, m, r) { assume(forall i \\in [0,m), x \\in X. dp[x, i] == f(x, i)) assert(forall i \\in [m,r), x \\in X. dp[x, i] == s(x, i, 0, l)) for (x,y such that p[x,y] is non-zero) { v1 = convolution(dp[x][l:m], p[x, y][0:r-l]) dp[y][m:r] += v1[m-l:r-l] v2 = convolution(dp[y][l:m], p[x, y][0:r-l]) dp[x][m:r] += v2[m-l:r-l] } assert(forall i \\in [0,m), x \\in X. dp[x, i] == f(x, i)) assert(forall i \\in [m,r), x \\in X. dp[x, i] == s(x, i, 1, m)) } $f(x, i) = s(x, i, 0, i)$ であることと， assume と assert の主張から， dp[x, i] == s(x, i, 0, g(i)) (for all x \\in X) となる関数 g が， solve と induce によって，以下のように変化することが分かります．\ninduce を実行する際に，dp[.][l:m] が f(.)[l:m] に一致しているので， (オフラインになって) ここに FFT が使える，ということになります．\n以下を実行すると，答が dp[1][T] に求められます．\nfor x in 1:(N+1) { dp[x, 0] := if x == 1 then 1 else 0 } solve(0, T + 1) 計算量については特に付け加えることはないので，参照している記事をご覧下さい．\nACコード https://atcoder.jp/contests/abc213/submissions/24966725 keywords [\u0026ldquo;オンラインDP\u0026rdquo;, \u0026ldquo;オフラインDP\u0026rdquo;, \u0026ldquo;分割統治DP\u0026rdquo;, \u0026ldquo;DP\u0026rdquo;, \u0026ldquo;分割統治FFT\u0026rdquo;, \u0026ldquo;FFT\u0026rdquo;]\n","permalink":"https://yamate11.github.io/blog/posts/2021/08-11-stroll/","summary":"Atcoder Beginner Contest 213 (ABC-213) H - Stroll に関する記事です．\n問題へのリンク \r解法 公式解説 を読んでもよくわからなかったのですが， Motsu_xeさんによる，オフライン・オンライン変換 の説明がわかりやすかったです． 以下の説明は，ほとんど，上の2つの記事に依っています．\n記法を定めます．\n $f(x, i) :=$ 地点$x$に距離$i$で到達する方法の数 $p(x, y, i) :=$ 地点 $x$ と地点 $y$ を結ぶ距離 $i$ の道の数 $X := \\{1, \\ldots, N\\}$  したがって，$f(1, T)$ が求める答です．次の関係が成り立ちます:\n $f(1, 0) = 1$ $f(y, 0) = 0\\quad(y \\neq 1)$ $f(x, i) = \\sum \\{ f(y, j) \\cdot p(x, y, i - j) \\mid y \\in X, j \\in [0, i) \\}$  最後の式は，一見，畳み込みですが，右辺にも $f$ が出てきてしまうので， ただちには FFT に渡せません．ここを 分割統治FFTなる手法で求めようという趣旨であるようです．","title":"Atcoder Beginner Contest 213 H - Stroll"},{"content":"距離を求める際の，ダイクストラ, 0-1BFS, BFSのコーディング方法のまとめです．\n記法 ノードを表すデータ型を Node とする． int や long long や pair\u0026lt;int, int\u0026gt; など．\nダイクストラ  前提: ノード間の距離δ(x,y)が全部非負 距離の候補を優先度付きキューに入れていく． あるノードがキューから初めて取り出されたときにそのノードへの距離が確定する． 使用するデータと初期化  priority_queue のメソッドは，push(), emplace(), pop(), top() など．    using P = pair\u0026lt;ll, Node\u0026gt;; // 距離とノード priority_queue\u0026lt;P, vector\u0026lt;P\u0026gt;, greater\u0026lt;P\u0026gt;\u0026gt; pque; // 優先度付きキュー  // 値 (d, x) は，ノードxへ，長さdのパスがあることを示す． pque.emplace(0, initial_node); // 始点をキューに vector\u0026lt;ll\u0026gt; dist(N, LLONG_MAX); // 距離．始点以外は∞  // Node型 によっては，map\u0026lt;Node, ll\u0026gt; dist; など． dist[initial_node] = 0; // 始点の距離は0   ループ\n pque から取り出した (d, x) について，  dist[x] \u0026lt; d なら，もっと良い d があるということなので，単に捨てる． そうでなければこの d が x への最短距離であることが確定したので， 先に進む． x の 隣接ノード y について，newd = x + δ(x, y) が y への距離の候補なので以下を行う．  dist[y] \u0026lt;= newd なら，単に捨てる そうでなければ，先に進む． dist[y] を newd に更新する． (newd, y) を pque に入れる．        ゴール\n キューから取り出した時点で判断する． キューに入れる時点では，後からもっと短いものがくるかもしれない．    0-1 BFS  前提: ノード間の距離 δ(x,y) がどれも 0 または 1． 基本的にはダイクストラの考え方だが， 優先度付きキューの代わりに，両端キューが使える． 使用するデータと初期化  基本的には，ダイクストラと同じ． deque のメソッドは， { push | emplace | pop }_{ back | front }(), back(), front() など．    using P = pair\u0026lt;ll, Node\u0026gt;; // 距離とノード deque\u0026lt;P\u0026gt; deq; // 両端キュー  // 値 (d, x) は，ノードxへ，長さdのパスがあることを示す． deq.emplace_back(0, initial_node); // 始点をキューに vector\u0026lt;ll\u0026gt; dist(N, LLONG_MAX); // 距離．始点以外は∞  // Node型 によっては，map\u0026lt;Node, ll\u0026gt; dist; など． dist[initial_node] = 0; // 始点の距離は0   ループ\n 基本的にはダイクストラと同じ．違うのは，キューに入れるところだけ． deq から取り出した (d, x) について，  dist[x] \u0026lt; d なら，もっと良い d があったということなので， 単に捨てる． そうでなければこの d が x への最短距離であることが確定したので， 先に進む． x の 隣接ノード y について，newd = x + δ(x, y) が y への距離の候補なので以下を行う．  dist[y] \u0026lt;= newd なら，単に捨てる． そうでなければ，先に進む． dist[y] を newd に更新する． (newd, y) を deq に挿入する．  δ(x, y) = 0 なら，deq の左から挿入する． δ(x, y) = 1 なら，deq の右から挿入する．          ゴール\n ダイクストラと同じ．deq から取り出すときに判断する． (δ(x,y) = 0 なら入れるときに確定するが，気にしなくても良いであろう)    BFS  前提: ノード間の距離が全部1 ノードを初めて見たときに距離が確定する． FIFOキューには距離を入れる必要が無く，ノードだけで良い． 使用するデータと初期化  queue のメソッドは，push(), emplace(), pop(), front(), back() など．    queue\u0026lt;Node\u0026gt; que; // FIFOキュー  // キューに入っているノードは，  // 「自分の距離は確定したが，隣接ノードは未処理」のもの que.push(initial_node); // 始点をキューに vector\u0026lt;ll\u0026gt; dist(N, -1); // 距離．始点以外は未確定  // Node型 によっては，map\u0026lt;Node, ll\u0026gt; dist; など． dist[initial_node] = 0; // 始点の距離は0   ループ\n que から取り出したノード x の各隣接ノード y について，  dist[y] \u0026gt;= 0 (すでに距離が確定) の場合は，単に捨てる． 未確定ならば，先に進む． dist[y] に dist[x] + 1 を設定する． y をキューに入れる．      ゴール\n dist[] に値を設定するときに判断する．    ","permalink":"https://yamate11.github.io/blog/posts/2021/07-03-bfs-dijkstra/","summary":"距離を求める際の，ダイクストラ, 0-1BFS, BFSのコーディング方法のまとめです．\n記法 ノードを表すデータ型を Node とする． int や long long や pair\u0026lt;int, int\u0026gt; など．\nダイクストラ  前提: ノード間の距離δ(x,y)が全部非負 距離の候補を優先度付きキューに入れていく． あるノードがキューから初めて取り出されたときにそのノードへの距離が確定する． 使用するデータと初期化  priority_queue のメソッドは，push(), emplace(), pop(), top() など．    using P = pair\u0026lt;ll, Node\u0026gt;; // 距離とノード priority_queue\u0026lt;P, vector\u0026lt;P\u0026gt;, greater\u0026lt;P\u0026gt;\u0026gt; pque; // 優先度付きキュー  // 値 (d, x) は，ノードxへ，長さdのパスがあることを示す． pque.emplace(0, initial_node); // 始点をキューに vector\u0026lt;ll\u0026gt; dist(N, LLONG_MAX); // 距離．始点以外は∞  // Node型 によっては，map\u0026lt;Node, ll\u0026gt; dist; など． dist[initial_node] = 0; // 始点の距離は0   ループ","title":"距離: BFSとダイクストラ"},{"content":"キーエンスプログラミングコンテスト 2021 E - Greedy Ant に関する記事です．\n問題へのリンク https://atcoder.jp/contests/keyence2021/tasks/keyence2021 解法 公式解説 の通りではありますが，若干表現を変えます．\nすぬけ君が，蟻から遠い飴を取っても，蟻の行動には直ちには影響を与えません． そういう状況ではすぬけ君は「スキップ」することにして，後から蟻がその飴に近づいてきたとき (左右いずれかで蟻の最も近い飴になったとき) に取ることにしても，ゲームの意味が変わりません． つまり，次のようにゲームを言い変えることができます． (両端などの扱いはサボっています)\n初期化: // 蟻の初期位置を 2n + 1 とする． l := n // 蟻に最も近い左の飴の位置が 2l r := n + 1 // 蟻に最も近い右の飴の位置が 2r k := 0 // すぬけ君の「スキップ」回数 ループ: k += 1 while k \u0026gt; 0: match すぬけ君の選択(): case なし: break case 左: すぬけ君が 2l の飴を取る; l -= 1 case 右: すぬけ君が 2r の飴を取る; r += 1 k -= 1 蟻が，2l, 2r の飴のおいしい方を取る 取った方に応じて l -= 1 または r += 1 そこで， f(l,r,k) を，「上記 while の先頭位置で，l,r,k がこの値である時に，すぬけ君がこのあと取る得点の最大値」として 定義します． 次の漸化式が書けます．\nf(l, r, k) = max( none(l, r, k) , a[l] + f(l - 1, r, k - 1) , a[r] + f(l, r + 1, k - 1) ) ただし，a[l] \u0026gt; a[r] のとき，none(l, r, k) = f(l - 1, r, k + 1) そうでないとき， none(l, r, k) = f(l, r + 1, k + 1) f(n, n + 1, 1) が求める答です． fは，メモ化再帰で計算でき，時間計算量は O(N^3)です．\n経緯 コンテスト中も解けず，復習でも答を思い出せませんでした．blogに書くことで覚えられるか???\n","permalink":"https://yamate11.github.io/blog/posts/2021/07-22-greedy-ant/","summary":"キーエンスプログラミングコンテスト 2021 E - Greedy Ant に関する記事です．\n問題へのリンク https://atcoder.jp/contests/keyence2021/tasks/keyence2021 解法 公式解説 の通りではありますが，若干表現を変えます．\nすぬけ君が，蟻から遠い飴を取っても，蟻の行動には直ちには影響を与えません． そういう状況ではすぬけ君は「スキップ」することにして，後から蟻がその飴に近づいてきたとき (左右いずれかで蟻の最も近い飴になったとき) に取ることにしても，ゲームの意味が変わりません． つまり，次のようにゲームを言い変えることができます． (両端などの扱いはサボっています)\n初期化: // 蟻の初期位置を 2n + 1 とする． l := n // 蟻に最も近い左の飴の位置が 2l r := n + 1 // 蟻に最も近い右の飴の位置が 2r k := 0 // すぬけ君の「スキップ」回数 ループ: k += 1 while k \u0026gt; 0: match すぬけ君の選択(): case なし: break case 左: すぬけ君が 2l の飴を取る; l -= 1 case 右: すぬけ君が 2r の飴を取る; r += 1 k -= 1 蟻が，2l, 2r の飴のおいしい方を取る 取った方に応じて l -= 1 または r += 1 そこで， f(l,r,k) を，「上記 while の先頭位置で，l,r,k がこの値である時に，すぬけ君がこのあと取る得点の最大値」として 定義します． 次の漸化式が書けます．","title":"Greedy Ant - キーエンスプログラミングコンテスト2021 E"},{"content":"桁DPのコーディングに関する記事です． N 以下の整数である条件を満たすものを数えます．\n参照 以下のoptさんの記事 をもとにして，少し追加しています:\n\rコーディングの方針  配るDP 上位桁を 0-padding した状態で考える  有効な桁が始まっているかどうかが必要なこともあるが，その場合にはそれを表すフラグを導入する． 0以上N以下を数えることになるので，必要なら最後に調整．   代入は1回  その桁に表れうる数 (0..9 とか 0..1 とか) をループで回し，「この数を付け加えた時の格納先」を考える 格納先の添字を表す変数を，格納元で初期化して適宜変更する．    // N は各桁数値のベクトルで表現．ds[0] が最上位桁． // もちろん，問題文の都合で string でも良い． // 本来は ds[0] を一の位にして， // ループを ds.size() - 1 から 0 まで回した方が自然かもしれない vector\u0026lt;ll\u0026gt;\u0026amp; ds; // DP表は，最初の次元を上限に等しいかどうかのフラグにする． // 0 ... 上限値． 1 ... 上限値より小さいと確定 auto tbl_init = vector(2, vector(??, vector(??, 0LL))); auto tbl = tbl_init; tbl[0][??][??] = 1 // 00..0 という列が持つ性質のところを1にする． for (ll i = 0; i \u0026lt; (ll)ds.size(); i++) { auto prev = move(tbl); tbl = tbl_init; for (ll f = 0; f \u0026lt; 2; f++) { // 上限フラグ  for (ll p = 0; p \u0026lt; ??; p++) { // 添字  for (ll q = 0; q \u0026lt; ??; q++) { // 添字  if (prev[f][p][q] == 0) continue; // 性能的に結構重要  for (ll x = 0; x \u0026lt;= 9; x++) { // この桁で考える数  ll f0 = f, p0 = p, q0 = q; // 代入先の添字  if (f == 0) { // ds の値には，ここでしかアクセスしない．  if (x \u0026gt; ds[i]) continue; if (x \u0026lt; ds[i]) f0 = 1; } // 「性質p,qを満たす列の末尾にxを付け加えると性質がp0,q0になる」  // ような p0, q0 を定める．ここでは f は使わないはず．  p0 = ....; q0 = ....; // 最後に一回だけ表の更新  tbl[f0][p0][q0] += prev[f][p][q]; }}}}} 問題集 \r\r","permalink":"https://yamate11.github.io/blog/posts/2021/07-06-digitdp/","summary":"桁DPのコーディングに関する記事です． N 以下の整数である条件を満たすものを数えます．\n参照 以下のoptさんの記事 をもとにして，少し追加しています:\n\rコーディングの方針  配るDP 上位桁を 0-padding した状態で考える  有効な桁が始まっているかどうかが必要なこともあるが，その場合にはそれを表すフラグを導入する． 0以上N以下を数えることになるので，必要なら最後に調整．   代入は1回  その桁に表れうる数 (0..9 とか 0..1 とか) をループで回し，「この数を付け加えた時の格納先」を考える 格納先の添字を表す変数を，格納元で初期化して適宜変更する．    // N は各桁数値のベクトルで表現．ds[0] が最上位桁． // もちろん，問題文の都合で string でも良い． // 本来は ds[0] を一の位にして， // ループを ds.size() - 1 から 0 まで回した方が自然かもしれない vector\u0026lt;ll\u0026gt;\u0026amp; ds; // DP表は，最初の次元を上限に等しいかどうかのフラグにする． // 0 ... 上限値． 1 ... 上限値より小さいと確定 auto tbl_init = vector(2, vector(??, vector(??, 0LL))); auto tbl = tbl_init; tbl[0][?","title":"桁DPのコーディング"},{"content":"gcc (g++) の policy-based data structure の中にある tree (の競技プログラミングでの利用) に関する記事です．\nリンク  Policy-based Data Structure (GCC online docs) Codeforces admant\u0026#39;s blog   まとめ 以下の操作ができる set や map\n x を指定して，x より小さい要素がいくつあるか数える n を指定して，n 番目に小さい要素へのイテレータを取得する  先頭部分 #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;using namespace __gnu_pbds; 型の定義 例: pair\u0026lt;int, int\u0026gt; の集合 using pair_t = pair\u0026lt;int, int\u0026gt;; using ordered_set = tree\u0026lt; pair_t, null_type, less\u0026lt;pair_t\u0026gt;, rb_tree_tag, tree_order_statistics_node_update \u0026gt;; 例: string から int へのマップ using ordered_map = tree\u0026lt; string, int, less\u0026lt;string\u0026gt;, rb_tree_tag, tree_order_statistics_node_update \u0026gt;; 機能の呼び出し ordered_set os; os.insert(pair_t(0,0)); os.insert(pair_t(1,0)); os.insert(pair_t(1,1)); os.insert(pair_t(2,0)); os.insert(pair_t(2,1)); // order_of_key: 指定した値よりも小さい要素の数  assert(os.order_of_key(pair_t(-1,0)) == 0); assert(os.order_of_key(pair_t(0,0)) == 0); assert(os.order_of_key(pair_t(0,1)) == 1); assert(os.order_of_key(pair_t(1,0)) == 1); assert(os.order_of_key(pair_t(1,1)) == 2); assert(os.order_of_key(pair_t(100,0)) == 5); // find_by_order: 指定した位置の要素へのイテレータ  assert(*os.find_by_order(0) == pair_t(0,0)); assert(*os.find_by_order(2) == pair_t(1,1)); assert(*os.find_by_order(4) == pair_t(2,1)); assert(os.find_by_order(5) == os.end()); 注意  必ずしも速くないらしい．Fenwick tree なり segment tree の倍くらい遅いというレポートがある multiset や multimap に相当する機能はない (リンク )  ","permalink":"https://yamate11.github.io/blog/posts/2021/06-05-policy-based-ds/","summary":"gcc (g++) の policy-based data structure の中にある tree (の競技プログラミングでの利用) に関する記事です．\nリンク  Policy-based Data Structure (GCC online docs) Codeforces admant\u0026#39;s blog   まとめ 以下の操作ができる set や map\n x を指定して，x より小さい要素がいくつあるか数える n を指定して，n 番目に小さい要素へのイテレータを取得する  先頭部分 #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;using namespace __gnu_pbds; 型の定義 例: pair\u0026lt;int, int\u0026gt; の集合 using pair_t = pair\u0026lt;int, int\u0026gt;; using ordered_set = tree\u0026lt; pair_t, null_type, less\u0026lt;pair_t\u0026gt;, rb_tree_tag, tree_order_statistics_node_update \u0026gt;; 例: string から int へのマップ using ordered_map = tree\u0026lt; string, int, less\u0026lt;string\u0026gt;, rb_tree_tag, tree_order_statistics_node_update \u0026gt;; 機能の呼び出し ordered_set os; os.","title":"policy-based data structure の tree"},{"content":"燃やす埋める問題についての記事です．\n動機 燃やす埋める問題については，一度エントリを書いた のですが，そこにはともかく理解したことを全部書いたので，コンテスト中に参照しても把握するのがたいへん，という状況になってしまっています．そこで，コンテスト中に思い出したい最小限のことだけまとめることにしました．\n考え方    問題文中に「$p$ のとき$b$を受け取る」という記載があったら，「先に $b$ を受け取る．$\\neg p$ の時 $b$ を支払う」と読み替えて，すべて支払いをすると考える． グラフ全体の source ノードのラベルは True，sink ノードのラベルは False． ノード $p$ からノード $q$ への矢印に，重み $a$ がついているのは，「$p$が成り立つのに$q$が成り立たない場合，コスト $a$ を支払う」と読む． したがって，この図では，以下が表現されている  $p_8$ は成り立つ． $p_1$ が成り立たなかったら，$a_5$ 支払う． $p_7$ が成り立ったら，$a_3$ 支払う．   最小カットが，コスト最小の真偽割当．図の赤線だと，$p_1, \\ldots, p_6, p_8$ を真，$p_7, p_9$ を偽にする割当に相当し，この場合のコストは$a_2 + a_6$． 連言や選言のノードは，矢印を出せるか入れられるかが決まっている．下図を参照．不可の理由は，たとえば連言なら，$p$, $q$を真に，$p\\land q$ を偽にできてしまうから．(矢印の根本を真にできてしまうと不当な利益がある．矢印の根本を偽にできても嬉しくない)    ","permalink":"https://yamate11.github.io/blog/posts/2021/05-22-burn-bury/","summary":"燃やす埋める問題についての記事です．\n動機 燃やす埋める問題については，一度エントリを書いた のですが，そこにはともかく理解したことを全部書いたので，コンテスト中に参照しても把握するのがたいへん，という状況になってしまっています．そこで，コンテスト中に思い出したい最小限のことだけまとめることにしました．\n考え方    問題文中に「$p$ のとき$b$を受け取る」という記載があったら，「先に $b$ を受け取る．$\\neg p$ の時 $b$ を支払う」と読み替えて，すべて支払いをすると考える． グラフ全体の source ノードのラベルは True，sink ノードのラベルは False． ノード $p$ からノード $q$ への矢印に，重み $a$ がついているのは，「$p$が成り立つのに$q$が成り立たない場合，コスト $a$ を支払う」と読む． したがって，この図では，以下が表現されている  $p_8$ は成り立つ． $p_1$ が成り立たなかったら，$a_5$ 支払う． $p_7$ が成り立ったら，$a_3$ 支払う．   最小カットが，コスト最小の真偽割当．図の赤線だと，$p_1, \\ldots, p_6, p_8$ を真，$p_7, p_9$ を偽にする割当に相当し，この場合のコストは$a_2 + a_6$． 連言や選言のノードは，矢印を出せるか入れられるかが決まっている．下図を参照．不可の理由は，たとえば連言なら，$p$, $q$を真に，$p\\land q$ を偽にできてしまうから．(矢印の根本を真にできてしまうと不当な利益がある．矢印の根本を偽にできても嬉しくない)    ","title":"燃やす埋める問題"},{"content":"きたまさ法に関する記事です． よすぽさんの記事 を参照して書きました．\n問題設定 整数 $ d_0 , \\ldots, d_{ k - 1 }$ と $a_0, \\ldots, a_{k - 1}$ が与えられている． 漸化式 $ a_{n + k} = d_{0} a_{n} + \\cdots + d_{ k - 1 } a_{n + k - 1}$ で定義される数列の $a_n$ を $O( k^2 \\log n )$ で求める．\n行列 $$ A = \\begin{bmatrix} d_{ k - 1 } \u0026amp;\\cdots \u0026amp; \\cdots \u0026amp; d_{ 0 } \\\\\n1 \u0026amp; \u0026amp; \\Large{0} \u0026amp; 0 \\\\\n\u0026amp; \\ddots \u0026amp; \u0026amp; 0\\\\\n\\Large{0} \u0026amp; \u0026amp; 1 \u0026amp; 0 \\\\\n\\end{bmatrix} $$\nとすれば，\n$$ \\begin{bmatrix} a_n \\\\\n\\vdots \\\\\na_{ n - k + 1} \\end{bmatrix} = A^{ n - k + 1 } \\begin{bmatrix} a_{ k - 1 } \\\\\n\\vdots \\\\\na_{ 0 } \\end{bmatrix} $$\nなので，$A^n$ が計算できれば良い．あるいは，$A^n$ の最上行だけでも良い． 計算量が $O( k^2 \\log n)$ で押さえられて欲しいが， 普通の行列累乗だと$O( k^3 \\log n)$ になる．\n計算 $\\newcommand{\\bsww}{\\boldsymbol{w}}$ $\\newcommand{\\bsx}{\\boldsymbol{x}}$ $\\newcommand{\\bsy}{\\boldsymbol{y}}$ $\\newcommand{\\bsdd}{\\boldsymbol{d}}$ $\\bsy_i$ たちを行ベクトルとする．$\\bsdd = [d_{ k - 1 }, \\ldots, d_0]$ とする． また，$\\text{sft}([z_0, \\ldots, z_{ k - 1 }]) = [z_1, \\ldots, z_{ k - 1 }, 0]$ とする． 計算することによって以下がわかる:\n$$ A \\left[ \\begin{array}{c} \\bsy_1 \\\\ \\bsy_2 \\\\ \\vdots \\\\ \\bsy_k \\end{array}\\right] = \\left[ \\begin{array}{c} * \\\\ \\bsy_1 \\\\ \\vdots \\\\ \\bsy_{ k - 1 } \\end{array}\\right] ,\\quad \\left[\\begin{array}{c} \\bsy_1 \\\\ \\vdots \\\\ \\bsy_k \\end{array}\\right] A = \\left[\\begin{array}{c} y_{11}\\bsdd + \\text{sft}( \\bsy_{1} ) \\\\\n\\vdots \\\\\ny_{k1}\\bsdd + \\text{sft}( \\bsy_{k} ) \\\\\n\\end{array}\\right] \\tag{1}$$\nしたがって，$ A^n $ の最下行の行ベクトルを $\\bsx(n)$ と書くと，以下が成り立つ:\n$$ A^n = \\left[\\begin{array}{c} \\bsx( n + k - 1) \\\\\n\\vdots \\\\\n\\bsx( n ) \\\\\n\\end{array}\\right] \\tag{2} $$\n(1)の右の式より， $\\bsx(n)$ の第1成分を $x$ とすると， $$ \\bsx (n + 1) = x \\bsdd + \\text{sft}( \\bsx(n) ) \\tag{3}$$ であることが分かる． また，$A^n$ の列ベクトルを $\\bsww_1^T, \\ldots, \\bsww_k^T$ とし，\n$$ \\left[\\begin{array}{c} \\bsx(2n + k - 1) \\\\\n\\vdots \\\\\n\\bsx(2n) \\\\\n\\end{array}\\right] = A^{2n} = (A^{n})^{2} = \\left[\\begin{array}{c} \\bsx(n + k - 1) \\\\\n\\vdots \\\\\n\\bsx(n) \\\\\n\\end{array}\\right] \\left[\\begin{array}{c} ~ \\\\\n\\bsww_1^T \u0026amp; \\cdots \u0026amp; \\bsww_k^T \\\\\n~ \\\\\n\\end{array}\\right] $$\nと書いて，最下行を比較すると，\n$$ \\bsx(2n) = [ \\bsx(n)\\cdot \\bsww_1, \\ldots, \\bsx(n)\\cdot \\bsww_k ] \\tag{4}$$\nである．\n以上より，次の手順で $a_n$ を計算することができる．\n $a_n = \\bsx(n - k + 1 + k - 1) \\cdot [a_{ k - 1 }, \\cdots, a_{ 0 }]$ なので，$\\bsx(n)$ が求められれば良い． $n$ を，「$+1$」 と 「$\\times 2$」 で書く．たとえば，$n = 18$ なら，$n = ((1 \\times 2 \\times 2 \\times 2) + 1) \\times 2$． この内側から順に $\\bsx(n)$ を求めていく． $+1$ のときには，(3) を適用する．この計算量は，$O(k)$ $\\times 2$ のときには，まず (3) を $k - 1$ 回適用して，$\\bsx(n), \\ldots, \\bsx(n + k - 1)$ を求める． すると(2) より $A^{n}$ が決まるので，(4) の右辺が計算できる．この計算量は，$O(k^2)$  ","permalink":"https://yamate11.github.io/blog/posts/2021/04-30-kitamasa/","summary":"きたまさ法に関する記事です． よすぽさんの記事 を参照して書きました．\n問題設定 整数 $ d_0 , \\ldots, d_{ k - 1 }$ と $a_0, \\ldots, a_{k - 1}$ が与えられている． 漸化式 $ a_{n + k} = d_{0} a_{n} + \\cdots + d_{ k - 1 } a_{n + k - 1}$ で定義される数列の $a_n$ を $O( k^2 \\log n )$ で求める．\n行列 $$ A = \\begin{bmatrix} d_{ k - 1 } \u0026amp;\\cdots \u0026amp; \\cdots \u0026amp; d_{ 0 } \\\\\n1 \u0026amp; \u0026amp; \\Large{0} \u0026amp; 0 \\\\","title":"きたまさ法"},{"content":"二項係数 binom(n, r) を，小さい素数 p に対して mod p で求める方法に関する記事です．\n観察 p = 3 に関していくつか書いてみると次のようになっている．\n0 1 1 1 1 2 1 2 1 10 1 0 0 1 11 1 1 0 1 1 12 1 2 1 1 2 1 20 1 0 0 2 0 0 1 21 1 1 0 2 2 0 1 1 22 1 2 1 2 1 2 1 2 1 100 1 0 0 0 0 0 0 0 0 1 101 1 1 0 0 0 0 0 0 0 1 1 102 1 2 1 0 0 0 0 0 0 1 2 1 110 1 0 0 1 0 0 0 0 0 1 0 0 1 111 1 1 0 1 1 0 0 0 0 1 1 0 1 1 112 1 2 1 1 2 1 0 0 0 1 2 1 1 2 1 120 1 0 0 2 0 0 1 0 0 1 0 0 2 0 0 1 こんな感じの構造になっている:\n  例: p = 3 例として $p = 3$ の場合には， 上の図から，以下のように計算できる．ただし，$q \u0026lt; 3^k$．\n$$ \\begin{eqnarray} % \\binom00 \u0026amp;=\u0026amp; 1 \\\\\n% \\binom{3^k + q}{r} \u0026amp;=\u0026amp; \\begin{cases} \\displaystyle{\\binom{q}{r}} \u0026amp; \\text{if }\\; 0 \\leq r \\leq q \\\\\n\\displaystyle{\\binom{q}{r - 3^k}} \u0026amp; \\text{if }\\; 3^k \\leq r \\\\\n0 \u0026amp; \\text{if }\\; q \u0026lt; r \u0026lt; 3^k \\\\\n\\end{cases} \\\\\n% \\binom{2\\cdot 3^k + q}{r} \u0026amp;=\u0026amp; \\begin{cases} \\displaystyle{\\binom{q}{r}} \u0026amp; \\text{if }\\; 0 \\leq r \\leq q \\\\\n\\displaystyle{2\\binom{q}{r - 3^k}} \u0026amp; \\text{if }\\; 3^k \\leq r \\leq 2\\cdot 3^k + q \\\\\n\\displaystyle{\\binom{q}{r - 2\\cdot 3^k}} \u0026amp; \\text{if }\\; 2\\cdot 3^k \\leq r \\\\\n0 \u0026amp; \\text{if }\\; q \u0026lt; r \u0026lt; 3^k,\\; 3^k + q \u0026lt; r \u0026lt; 2\\cdot 3^k \\\\\n\\end{cases} \\\\\n% \\end{eqnarray} $$\n列 $s(n) := [\\binom{n}{r} \\mid 0 \\leq r \\leq n]$ が必要ならば，以下のように計算できる． $$ \\begin{eqnarray} s(0) \u0026amp;=\u0026amp; [1] \\\\\ns(3^k + q) \u0026amp;=\u0026amp; s(q) ⧺ z ⧺ s(q) \\\\\ns(2\\cdot 3^k + q) \u0026amp;=\u0026amp; s(q) ⧺ z ⧺ 2 \\cdot s(q) ⧺ z ⧺ s(q) \\end{eqnarray} $$ ただし，$z$ は，$0$ を $3^k - q - 1$ 個並べた列．\nbinom(n, r) 一般に，小さい素数$p$ に対しては，以下のようになる．\n$n = c\\cdot p^k + q$，$1 \\leq c \u0026lt; p$，$q \u0026lt; p^k$，$r = d\\cdot p^k + t$，$0 \\leq d \u0026lt; p$，$t \u0026lt; p^k$ とすると，\n$$ \\begin{eqnarray} \\binom{0}{0} \u0026amp;=\u0026amp; 1 \\\\\n\\binom{n}{r} = \\binom{c\\cdot p^k + q}{d\\cdot p^k + t} \u0026amp;=\u0026amp; \\begin{cases} \\displaystyle{\\binom{c}{d}\\binom{q}{t}} \u0026amp; \\text{if }\\; 0 \\leq t \\leq q \\\\\n0 \u0026amp; \\text{if }\\; q \u0026lt; t \\\\\n\\end{cases} \\\\\n\\end{eqnarray} $$\n$\\binom{n}{r}$ の時間計算量は $O(\\log n)$．\n列 $s(n) := [\\binom{n}{r} \\mid 0 \\leq r \\leq n]$ が必要ならば，以下のように計算できる． 記号は上と同様． $$ \\newcommand{\\mybinom}[2]{\\displaystyle{\\binom{#1}{#2}}} \\begin{eqnarray} s(0) \u0026amp;=\u0026amp; [1] \\\\\ns(n) = s(c\\cdot p^k + q) \u0026amp;=\u0026amp; \\mybinom{c}{0}s(q) ⧺ z ⧺ \\mybinom{c}{1}s(q) ⧺ z ⧺ \\cdots ⧺ \\mybinom{c}{c}s(q) \\\\\n\\end{eqnarray} $$ $z$は，$0$ を $p^k - q - 1$ 個並べた列． $s(n)$ の時間計算量は $O(n)$．\nAtCoder AtCoder ARC117 C - Tricolor Pyramid で，上の手順が使える．ただし，解説 の方法の方が思いつきやすいし，(列を求めるだけだから) 計算量は同じ．\n","permalink":"https://yamate11.github.io/blog/posts/2021/04-27-binom-mod/","summary":"二項係数 binom(n, r) を，小さい素数 p に対して mod p で求める方法に関する記事です．\n観察 p = 3 に関していくつか書いてみると次のようになっている．\n0 1 1 1 1 2 1 2 1 10 1 0 0 1 11 1 1 0 1 1 12 1 2 1 1 2 1 20 1 0 0 2 0 0 1 21 1 1 0 2 2 0 1 1 22 1 2 1 2 1 2 1 2 1 100 1 0 0 0 0 0 0 0 0 1 101 1 1 0 0 0 0 0 0 0 1 1 102 1 2 1 0 0 0 0 0 0 1 2 1 110 1 0 0 1 0 0 0 0 0 1 0 0 1 111 1 1 0 1 1 0 0 0 0 1 1 0 1 1 112 1 2 1 1 2 1 0 0 0 1 2 1 1 2 1 120 1 0 0 2 0 0 1 0 0 1 0 0 2 0 0 1 こんな感じの構造になっている:","title":"binom(n, r) を小さい素数pに対して mod p で求める"},{"content":"Lagrange補間に関する記事です．\n要約 $$ f(x) = \\sum_{i = 0}^{k}\\frac{ f(i) }{ (-1)^{k - i} \\; i ! \\; (k - i) ! } \\cdot \\frac{ 1 }{ x - i } \\cdot \\prod_{j=0}^{k} ( x - j ) $$\n詳細 \\( k \\) 次多項式 $f(x)$ について，$x = 0, \\ldots, k$ の値が，$f(0) = v_0, \\ldots, f(k) = v_k$ と分かっているときに， $f(x)$ (の各係数) を決める方法． 連立方程式を解く方法だと，逆行列を計算する必要があるから，\\( \\Omega( k^3 ) \\) になってしまうが， Lagrange補間だと，$O(k^2)$ で済む．\n$I = \\{0, \\ldots, k\\}$, $I_i = I \\setminus \\{ i \\}$ とする．$i = 0, \\ldots, k$ について，$k$ 次の多項式 $g_i(x)$ を， 次で定義する．\n$$g_i(x) = \\frac{ \\prod \\{ x - j \\mid j \\in I_i \\} }{ \\prod \\{ i - j \\mid j \\in I_i \\} } $$\n$j = 0, \\ldots, k$ について，\n$$ g_i (j) = \\begin{cases} 1 \u0026amp; \\text{ if } i =j \\\\\n0 \u0026amp; \\text{ if } i \\neq j \\end{cases}$$\nであることに注意すると，\n$$ f(x) = \\sum_{i = 0}^{k} g_i(x)v_i $$\nとなることがわかる (左右両辺とも $k$ 次多項式で，$k+1$ 個の値が一致する)．\n$ g_i(x) $ の分母を $c_i$ と書くと，\n$$ c_i = (-1)^{k - i} \\; i ! \\; (k - i) ! $$\nであるから，これらは，事前に $k$ までの階乗を $O(k)$ で計算しておけば，$O(1)$ で求められる．\n$g_i(x)$ の分子は，\n$$ \\frac{1}{x - i}\\cdot\\prod_{j=0}^{k} (x-j) $$\nであるから，まず $\\prod_{j=0}^{k} (x-j)$ を $O(k^2)$ で計算しておけば，各$i$について$O(k)$で，全体で$O(k^2)$で 計算できる．\nAtCoder AtCoder ABC137 F - Polynomial Construction は， Lagrange補間を用いて解ける． ただし，解説 に書かれている方法の方が簡単．\n","permalink":"https://yamate11.github.io/blog/posts/2021/04-22-lagrange/","summary":"Lagrange補間に関する記事です．\n要約 $$ f(x) = \\sum_{i = 0}^{k}\\frac{ f(i) }{ (-1)^{k - i} \\; i ! \\; (k - i) ! } \\cdot \\frac{ 1 }{ x - i } \\cdot \\prod_{j=0}^{k} ( x - j ) $$\n詳細 \\( k \\) 次多項式 $f(x)$ について，$x = 0, \\ldots, k$ の値が，$f(0) = v_0, \\ldots, f(k) = v_k$ と分かっているときに， $f(x)$ (の各係数) を決める方法． 連立方程式を解く方法だと，逆行列を計算する必要があるから，\\( \\Omega( k^3 ) \\) になってしまうが， Lagrange補間だと，$O(k^2)$ で済む．\n$I = \\{0, \\ldots, k\\}$, $I_i = I \\setminus \\{ i \\}$ とする．$i = 0, \\ldots, k$ について，$k$ 次の多項式 $g_i(x)$ を， 次で定義する．","title":"Lagrange補間"},{"content":"行列木定理についての記事です． これを使う問題が，第二回日本最強プログラマー学生選手権 の G - Spanning Tree として出題されました．\n定理 自己ループのない無向グラフ $G$ がある．頂点を $1, \\ldots, N$ とする． 対称 $N\\times N$ 行列 $A = (a_{ij})$ を，次で定める:\n $a_{ii} = $ 頂点$i$の出次数 $a_{ij} = - ( i \\text{と} j \\text{を結ぶ辺の数} )$  このとき，A のすべての余因子は等しく，G の全域木の数と一致する．\n例   上のグラフでは，\n$$ A = \\begin{bmatrix} 3 \u0026amp; -1 \u0026amp; 0 \u0026amp; -2 \\\\\n-1 \u0026amp; 3 \u0026amp; -1 \u0026amp; -1 \\\\\n0 \u0026amp; -1 \u0026amp; 2 \u0026amp; -1 \\\\\n-2 \u0026amp; -1 \u0026amp; -1 \u0026amp; 4 \\end{bmatrix} $$\n$(4,4)-$余因子行列は\n$$ M_{4,4} = \\begin{bmatrix} 3 \u0026amp; -1 \u0026amp; 0 \\\\\n-1 \u0026amp; 3 \u0026amp; -1 \\\\\n0 \u0026amp; -1 \u0026amp; 2\n\\end{bmatrix} $$\nこの行列式の値 13 が，グラフの全域木の数である．\n","permalink":"https://yamate11.github.io/blog/posts/2021/04-18-kirchhoff/","summary":"行列木定理についての記事です． これを使う問題が，第二回日本最強プログラマー学生選手権 の G - Spanning Tree として出題されました．\n定理 自己ループのない無向グラフ $G$ がある．頂点を $1, \\ldots, N$ とする． 対称 $N\\times N$ 行列 $A = (a_{ij})$ を，次で定める:\n $a_{ii} = $ 頂点$i$の出次数 $a_{ij} = - ( i \\text{と} j \\text{を結ぶ辺の数} )$  このとき，A のすべての余因子は等しく，G の全域木の数と一致する．\n例   上のグラフでは，\n$$ A = \\begin{bmatrix} 3 \u0026amp; -1 \u0026amp; 0 \u0026amp; -2 \\\\\n-1 \u0026amp; 3 \u0026amp; -1 \u0026amp; -1 \\\\\n0 \u0026amp; -1 \u0026amp; 2 \u0026amp; -1 \\\\","title":"行列木定理"},{"content":"CodeForces Round #431 (Div.2) E - Goodbye Souvenir についての記事です．\n問題へのリンク https://codeforces.com/contest/849/problem/E 経緯 Yoika さんが主催している Morningforces というバーチャルコンテスト で出て，解けませんでした． 公式解説 を読んだのですが，最後に出てくる座標圧縮云々がよく分かりませんでした．\n問題概要 整数列 $a = a_1, \\ldots, a_k $ に対して，$m(a)$ を，$a$ に現れる各数 $x$ に対して，$x$ が最後に現れる位置と最初に現れる位置との差の総和として定義する．例えば，$m(1, 2, 3, 1, 3, 2, 1) = (7-1) + (6-2) + (5- 3) = 12$．最初に長さ n の整数列 a が与えられる．各要素は1以上n以下．次の2種類のクエリ (全部で$m$個) を処理せよ．$ 1 \\leq n, m \\leq 100,000$．\n p, x が与えられて，aのp番目の要素をxに書き換える． l, r が与えられて，$ m(a[l:r]) $ を求める．  解法 ということで，実装手段を除いては公式解説をなぞっています．\n$x$ が出てくる位置を $p_1, \\ldots, p_k$ と書くと，$x$ による寄与は $ (p_2 - p_1) + \\cdots + ( p_k - p_{ k - 1 } ) $ である． ある数が位置 s に現れ，次には位置 t に現れるという状況の時，2次元平面内の 点 $(t, s)$ に値 $ t - s $ を割り振ることにする． すると，位置 p から q までの a の部分列での値は，2次元平面内の長方形 $ [ p, q + 1) \\times [p, n + 1) $ に割り振られた値の総和に等しい．\nつまり，長方形 $ [1, n + 1) \\times [1, n + 1) $ に対して，以下の操作が高速に行えれば良い．\n 1点に値を割り振る． 部分長方形に割り振られた値の総和を求める．  セグメント木と同じ考え方でできる． 通常のセグメント木は1次元で区間を2分割していくが， 2次元になっても，長方形を4分割することにすれば原理は同じ． ただし，最初に全部のセルを作ろうとすると $ \\Omega ( n^2 )$ 必要なので間に合わない． そこで，ノードは必要になったときだけ生成する． 下のコードを見れば， 普通のセグメント木と同じように書けることが分かると思う． どちらのクエリも $O(\\log n)$ で処理できるので， 全体で計算量は $ O(m\\log n) $ となる．\nACコード https://codeforces.com/contest/849/submission/104679665 ","permalink":"https://yamate11.github.io/blog/posts/2021/01-18-goodbye-souvenir/","summary":"CodeForces Round #431 (Div.2) E - Goodbye Souvenir についての記事です．\n問題へのリンク https://codeforces.com/contest/849/problem/E 経緯 Yoika さんが主催している Morningforces というバーチャルコンテスト で出て，解けませんでした． 公式解説 を読んだのですが，最後に出てくる座標圧縮云々がよく分かりませんでした．\n問題概要 整数列 $a = a_1, \\ldots, a_k $ に対して，$m(a)$ を，$a$ に現れる各数 $x$ に対して，$x$ が最後に現れる位置と最初に現れる位置との差の総和として定義する．例えば，$m(1, 2, 3, 1, 3, 2, 1) = (7-1) + (6-2) + (5- 3) = 12$．最初に長さ n の整数列 a が与えられる．各要素は1以上n以下．次の2種類のクエリ (全部で$m$個) を処理せよ．$ 1 \\leq n, m \\leq 100,000$．\n p, x が与えられて，aのp番目の要素をxに書き換える． l, r が与えられて，$ m(a[l:r]) $ を求める．  解法 ということで，実装手段を除いては公式解説をなぞっています．","title":"CodeForces Round #431 (Div.2) E - Goodbye Souvenir"},{"content":"C++ での乱数の使い方のメモです．\n典型的なコード ll n; cin \u0026gt;\u0026gt; n; random_device rand_dev; mt19937 rng(rand_dev()); uniform_int_distribution\u0026lt;ll\u0026gt; dist(1, n); for (ll i = 0; i \u0026lt; 10; i++) cout \u0026lt;\u0026lt; dist(rng) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; クラス random_device  マニュアル  オブジェクトは乱数発生器．non-deterministic な乱数を生成する． operator() を実行すると，unsigned int の乱数が返り，状態が進む． 実行は高価である可能性がある．  クラス mt19937  マニュアル  32bitメルセンヌツィッター乱数発生器 64bitメルセンヌツィッター乱数発生器 の mt19937_64 というクラスもある． o.operator() を実行すると，uint_fast32_t の乱数が返り，状態が進む． コンストラクタに seed を渡す． デフォルトコンストラクタは引数をとらず，seed = 5489u を用いる．したがって，次のように書けば，どの実行でも同じ値が生成される．  mt19937 rng; クラス uniform_int_distribution  マニュアル  乱数分布を一様分布とする．constructor に a, b を指定すると，a以上b以下の一様分布． T は int や ll など．デフォルトは int． operator() は，引数に乱数発生器を取り，一様分布を生成する． 他の乱数分布クラスとコンストラクタの例:  uniform_real_distribution\u0026lt;double\u0026gt; dist1(a, b); normal_distribution\u0026lt;double\u0026gt; dist2(mean, stddev); ","permalink":"https://yamate11.github.io/blog/posts/2021/01-13-random/","summary":"C++ での乱数の使い方のメモです．\n典型的なコード ll n; cin \u0026gt;\u0026gt; n; random_device rand_dev; mt19937 rng(rand_dev()); uniform_int_distribution\u0026lt;ll\u0026gt; dist(1, n); for (ll i = 0; i \u0026lt; 10; i++) cout \u0026lt;\u0026lt; dist(rng) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; クラス random_device  マニュアル  オブジェクトは乱数発生器．non-deterministic な乱数を生成する． operator() を実行すると，unsigned int の乱数が返り，状態が進む． 実行は高価である可能性がある．  クラス mt19937  マニュアル  32bitメルセンヌツィッター乱数発生器 64bitメルセンヌツィッター乱数発生器 の mt19937_64 というクラスもある． o.operator() を実行すると，uint_fast32_t の乱数が返り，状態が進む． コンストラクタに seed を渡す． デフォルトコンストラクタは引数をとらず，seed = 5489u を用いる．したがって，次のように書けば，どの実行でも同じ値が生成される．  mt19937 rng; クラス uniform_int_distribution  マニュアル  乱数分布を一様分布とする．constructor に a, b を指定すると，a以上b以下の一様分布． T は int や ll など．デフォルトは int． operator() は，引数に乱数発生器を取り，一様分布を生成する． 他の乱数分布クラスとコンストラクタの例:  uniform_real_distribution\u0026lt;double\u0026gt; dist1(a, b); normal_distribution\u0026lt;double\u0026gt; dist2(mean, stddev); ","title":"乱数の作り方"},{"content":"AtCoder Regular Contest (ARC) 056 D - サケノミ についての記事です．\n問題へのリンク  状況 解けないだけではなく，答を見てもなかなかわからなかったので，整理するために書いています．下記を参考にしています．\n 公式解説  kmjpさんのブログ   解法 時刻 $2j+1$ にドリンクを飲むような飲み方全部に関する，時刻 $2j+1$ 時点での美味しさの総和の最大値を $x(j)$ とする． 時刻 $2i$ に全部のグラスが空だったとき，半開区間 $(2i, 2j]$ に属する時刻に注がれるドリンクの美味しさの総和を $y(i, j)$ とすると， $x(j) = \\max \\{ x(i) + y(i, j) \\mid i \u0026lt; j \\} $ である．ここで，$z(i, j) = x(i) + y(i, j)$ と書くことにする．時刻 $j$ に注がれるドリンク全体の集合を $P$ とし，$ p \\in P $ に対して時刻 $2j$ の一回前にドリンク $p$ が注がれる時刻を $l_p$ とする (時刻 j が初回なら，$l_p = 0$ とする)．すると，次が成り立つ．\n $x(j) = z(j,j) = \\max \\{ z(i,j) \\mid i \u0026lt; j \\}$ $z(i,j) - z(i, j-1) = \\sum \\{ w_p \\mid p \\in P,; i \\in [l_p, j) \\}$  したがって，ベクトル $ v_j = ( z(i,j) \\mid i \u0026lt; j ) $ を $j$ に関して遅延伝搬セグメント木 (区間和，区間最大値) で更新していくことができ，$O(M \\log M)$ (ここに $M = \\sum \\{ M_i \\mid i \\leq N \\}$ )で計算できる．答は最終時刻 $T$ に対する $x(T) = z(T, T)$ である．\nその他 似たような問題を見たことがあるような気がして探してみると，EDPC の W. Intervals とほぼ同じでした．こちらの方が古いですが．何度やっても解けません．\n","permalink":"https://yamate11.github.io/blog/posts/2021/01-06-sakenomi/","summary":"AtCoder Regular Contest (ARC) 056 D - サケノミ についての記事です．\n問題へのリンク  状況 解けないだけではなく，答を見てもなかなかわからなかったので，整理するために書いています．下記を参考にしています．\n 公式解説  kmjpさんのブログ   解法 時刻 $2j+1$ にドリンクを飲むような飲み方全部に関する，時刻 $2j+1$ 時点での美味しさの総和の最大値を $x(j)$ とする． 時刻 $2i$ に全部のグラスが空だったとき，半開区間 $(2i, 2j]$ に属する時刻に注がれるドリンクの美味しさの総和を $y(i, j)$ とすると， $x(j) = \\max \\{ x(i) + y(i, j) \\mid i \u0026lt; j \\} $ である．ここで，$z(i, j) = x(i) + y(i, j)$ と書くことにする．時刻 $j$ に注がれるドリンク全体の集合を $P$ とし，$ p \\in P $ に対して時刻 $2j$ の一回前にドリンク $p$ が注がれる時刻を $l_p$ とする (時刻 j が初回なら，$l_p = 0$ とする)．すると，次が成り立つ．","title":"AtCoder Regular Contest 056 D - サケノミ"}]