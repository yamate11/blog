[{"content":"概要 無向グラフの二重連結に関して，二重辺連結，橋，二重点連結，関節点，block-cut tree などに関するライブラリを書いたので，そのメモです．\n概念 以下，グラフは単純とは限らない，無向グラフとします．\nグラフのある辺を削除すると， 連結成分の数が増えるとき，その辺を 橋 (bridge) と呼ぶ．\n橋の無いグラフは，二重辺連結 (two-edge connected) であるという．\nグラフの点集合の部分集合が，二重辺連結部分グラフを導き， そのようなものの中で極大であるとき，これを二重辺連結成分と呼ぶ．\nグラフのある点 (とその点が端点である辺) を削除すると， 連結成分の数が増えるとき， その点を 関節点 (articulation point) と呼ぶ．\n関節点の無いグラフは，二重点連結 (biconnected) であるという．\nグラフの点集合の部分集合が，二重点連結部分グラフを導き， そのようなものの中で極大であるとき，これを二重点連結成分と呼ぶ．\n命題たち 以下のことがなりたつ (と思うのですが，まだちゃんと証明できていない ものもあります)\n 二重点連結グラフは，二重辺連結である． 二重辺連結成分を集めてくると，グラフ点集合の分割になる． 二重辺連結成分$A$, $B$ に，$(A, B) \\in R \\iff \\exists a \\in A \\exists b \\in B (a,b)$は橋．という関係を入れると，森になる． 2つの二重点連結成分の共通部分は，空集合であるか，関節点1点からなる．  二重点連結成分の全体 $C$ と，関節点全部からなる集合 $A$ の和集合 $A \\cup C$ に， $\\{ (a, c) \\mid a \\in A, c \\in C, a \\in c \\}$ で関係を入れると， これは森になります．元のグラフが連結ならば，木です． これを，Block-Cut tree (forest?) と言うそうです． (block は二重点連結成分を指し，cut は関節点を指す)\nライブラリ 以下のような仕様のものを作りました． 一応，自己ループや多重辺があっても，また，連結で無くても動作するはずです．\nstruct bridge { // 二重辺連結に関する機能  bridge(int size); // constructor  void add_edge(int u, int v); // もとのグラフの辺の定義  bool is_bridge(int u, int v); // 橋かどうか判定  int num_tecc(); // 連結成分の数  const vector\u0026lt;int\u0026gt;\u0026amp; tecc(int ccid); // 各連結成分の頂点をあつめたvector  int node_tecc_idx(int u); // もとのグラフの点 u が属する連結成分の ID  vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; tecc_edges(); // 上述の森の辺 (ペアの要素は，連結成分ID) };  struct articulation { // 二重点連結に関する機能  articulation(int size); // constructor  void add_edge(int u, int v); // もとのグラフの辺の定義  bool is_articulation(int u); // 関節点かどうか判定  int bcc_size(); // 連結成分の数 (上と整合していないなあ...)  const vector\u0026lt;int\u0026gt;\u0026amp; bcc(int idx); // 各連結成分の頂点をあつめたvector  enum kind { BLOCK, CUT }; // block-cut forest でどちらを表しているかを示す enum  struct bctree { // block-cut forest (名前が整合的でない...)  int size(); // forest の頂点の数  vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; edges(); // forest の辺  pair\u0026lt;kind, int\u0026gt; what(int node); // forest の頂点が，もとのグラフでは何か?  // {BLOCK, x} なら ID x である連結成分， {CUT, u} なら関節点 u  int node(kind w, int i); // what の逆．forest における頂点番号を返す．  };  bctree* make_bctree(); // Block Cut Forest を作る．戻り値はポインタであることに注意． }; 典型的な使用法は次のような感じです:\n二重辺連結について:\n int N; cin \u0026gt;\u0026gt; N;   bridge bu(N);  for (int i = 0; i \u0026lt; N; i++) {  int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; u--; v--;  bu.add_edge(u, v);  }  int u = ..., v = ...;  bu.is_bridge(u, v); // (u, v) は橋か?  for (int x = 0; x \u0026lt; bu.num_tecc(); x++) {  for (int u : bu.tecc(x)) {  ... u ... ; // x 番目の二重辺連結成分 bu.tecc(x) の要素に順にアクセス  }  }  int x = bu.node_tecc_idx[u]; // 頂点 u は x 番目の連結成分に属する  for (auto [x, y] : bu.tecc_edges()) {  // (x, y) が，上述の森の辺をなしている．  } なお，元のグラフが連結でない場合には，bu.tecc_edges() の関係は 木にはならずに森になります．bu.llk.roots は， (型は vector\u0026lt;int\u0026gt; )，もとのグラフの連結成分から1点ずつとった集合に なっています．\n二重点連結について:\n int N; cin \u0026gt;\u0026gt; N;  articulation au(N);  for (int i = 0; i \u0026lt; N; i++) {  int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; u--; v--;  au.add_edge(u, v);  }  int u = ...;  au.is_articulation(u); // u は関節点か?  for (int x = 0; x \u0026lt; au.bcc_size(); x++) {  for (int u : au.bcc(x)) {  ... u ...; // x 番目の二重点連結成分 au.bcc(x) の要素に順にアクセス  }  }   // Block-Cut tree に，別のライブラリである Tree を使う場合  // この下は，元のグラフが連結であるという前提のコードになっている...  // (ライブラリ自体は，そうでなくても動作はする．bctree() という名前になっているが....)  auto bctree = au.make_bctree();  ll sz = bctree-\u0026gt;size(); // Block-Cut tree の頂点数  Tree bct(0, sz);  for (auto [a, b] : bctree-\u0026gt;edges()) bct.add_edge(a, b);  // bctree-\u0026gt;edges() が，Block Cut tree としての辺の関係  for (int a = 0; a \u0026lt; sz; a++) {  auto [w, i] = bctree-\u0026gt;what(a); // aは BLOCK? それとも CUT?  if (w == articulation::BLOCK) {  // この連結成分は，au.bcc(i) である．  }else if (w == articulation::CUT) {  // この関節点は，(もとのグラフの頂点番号で) i である．  }else assert(0);  // what の逆変換が bctree-\u0026gt;node() である．  }  実装は，lowlink を使っています．DFS 木の行きがけ順を表す vector\u0026lt;int\u0026gt; _ord と，back edge を高々1回たどって到達できる点の _ord の値の最小値である vector\u0026lt;int\u0026gt; _low を最初に計算し，これらを用いて 橋や関節点の判定をしています．\n一応，ソースはこちら にあります．\n参考サイト けむさんの 二重連結性と lowlink の話 がたいへん参考になりました．お礼申し上げます．\n","permalink":"https://yamate11.github.io/blog/posts/2023/09-05-bridge/","summary":"無向グラフの二重連結に関して，辺二重連結，橋，点二重連結，関節点，block-cut tree などに関するまとめです","title":"二重連結"},{"content":"デバッグに失敗した，ないし，長時間かかった間違いの記録\nABC212E Safety Journey 問題へのリンク 2023/07/05 あさかつ\n無向グラフが，完全グラフからM本の辺を除いたものとして与えられている． 除く辺は $(u, v)$ の形で与えられている． dp[i][j] = (i 回の繰返し後，頂点 j に到達できる方法の数) という DP で， 全体から 除いた辺の分を引く． $(u, v)$ と $(v, u)$ の両方を引かなければならないところ， $(u, v)$ しか引かなかった．\nABC279F BOX 2023/07/05 あさかつ\nタイプミス\n正:\nif (rx == -1 and ry == -1) { 誤:\nif (rx == -1 and ry == 1) { ARC164B 2023/07/09 コンテスト\n誤読．\n 正: 木の好きな頂点を選んで出発できる 誤: 木の根から出発する  ABC222E Red and Blue Tree 2023/08/02 あさかつ\n宣言を間違えた．\n正:\nvector A(M, Fp(0)); 誤:\nvector\u0026lt;ll\u0026gt; A(M, Fp(0)); ABC318C Blue Spring  「周遊セット」を買う枚数 $x$ を全探索する問題． ちゃんと考えると，買う枚数の候補は $0$ 枚以上 $\\displaystyle\\left\\lceil \\frac{N}{D} \\right\\rceil$ 枚以下，とわかる． コンテスト中で焦っていたので，面倒だから $0$ 枚以上 $N$ 枚以下で いいや，と考えた．($N$は十分小さいのでこれでも間に合う) ところが，それを REP(x, 0, N) とコーディングしてしまった． もちろん，REP(x, 0, N + 1) でなければならない．  ARC167B Product of Divisors A が整数であって，$ k \\leq A / 2$ を満たす整数 k の最大値を求めよ， という形になった．当然，A の偶奇で場合分けが必要なのだが， A が偶数と思い込んでしまった．\n","permalink":"https://yamate11.github.io/blog/posts/2023/07-05-rec-mistake/","summary":"デバッグに失敗した，ないし，長時間かかった間違いの記録\nABC212E Safety Journey 問題へのリンク 2023/07/05 あさかつ\n無向グラフが，完全グラフからM本の辺を除いたものとして与えられている． 除く辺は $(u, v)$ の形で与えられている． dp[i][j] = (i 回の繰返し後，頂点 j に到達できる方法の数) という DP で， 全体から 除いた辺の分を引く． $(u, v)$ と $(v, u)$ の両方を引かなければならないところ， $(u, v)$ しか引かなかった．\nABC279F BOX 2023/07/05 あさかつ\nタイプミス\n正:\nif (rx == -1 and ry == -1) { 誤:\nif (rx == -1 and ry == 1) { ARC164B 2023/07/09 コンテスト\n誤読．\n 正: 木の好きな頂点を選んで出発できる 誤: 木の根から出発する  ABC222E Red and Blue Tree 2023/08/02 あさかつ","title":"誤りの記録"},{"content":"Atcoder Beginner Contest 306 - ABC 306 G - Return to 1 の解法です．\n問題概要 問題へのリンク $N$ 頂点 $M$ 辺の有向グラフがある． 頂点 $1$ から辺をたどることをちょうど $10^{10^{100}}$ 回繰り返して 頂点 $1$ に戻ってくることが可能か判定せよ． テストケース $T$ 個．\n制約: $T \\leq 2 \\times 10^5$． $N$ の総和と $M$ の総和は $2 \\times 10^5$ 以下．\nコンテスト中の経緯 まず，強連結成分分解をして，頂点1を含む強連結成分のみを 考えれば良い．\n頂点 1 から出発して戻ってくるサイクルの長さ全部の集合を $C$， $C$ の最大公約数を $g$ とする． $10^{10^{100}}$ は十分大きいので， $g \\mid 10^{10^{100}}$ であることが， $10^{10^{100}}$ が $C$ の要素の非負整数倍の和で表せることと同値になる． $g \\mid 10^{10^{100}}$ は，もちろん， $g$ が $2$ と $5$ 以外の素因数を持たないことと同値である．\nということで，$g$ を求めれば良いのだが，$C$ は 巨大な集合なので直接には求められない． なんらかの $C$ の部分集合で，最大公約数が $g$ と等しくなるようなものを 求めるのだろうと思った．すべての辺について， それを使うサイクルは少なくとも 1 回は評価しないといけないであろうという ことで，根拠薄弱だが，次のような集合を取ってみることにした．\n$C\u0026rsquo; := \\{ \\text{dist}(1, x) + 1 + \\text{dist}(y, 1) \\mid (x, y) $ はグラフの辺 $\\}$\nここで，$\\text{dist}(x, y)$ は，2頂点 $x$, $y$ 間の距離である． $\\text{GCD}(C\u0026rsquo;)$ が $2$ と $5$ 以外の素因数を持たないかどうかで Yes / No を答えるようにした．\nダメ元で提出してみたが，ジャッジが詰まっていて， コンテスト終了までに結果が返ってこなかった． 結局このつまりが原因で ABC306 は unrated になった． コンテスト終了後に TLE が帰ってきたが，最初の強連結成分分解で， 頂点 $1$ が単独成分になる場合の考慮漏れだった． これを直したら AC になった．\n証明 コンテスト後， 公式解説 を見たら，想定解法は上の解法と少し似ていた． それを読んでしばらく考えたところ，上の解法も正当であることがわかった．\n 主張1 任意の辺 $(x, y)$ に対して， $g \\mid (\\text{dist}(1, x) + 1 + \\text{dist}(y, 1))$．\n  主張2 $a$ を正の整数とする． 任意の辺 $(x, y)$ に対して $a \\mid (\\text{dist}(1, x) + 1 + \\text{dist}(y, 1))$ であれば， 頂点1からの任意のサイクルの長さは，$a$ の倍数である．\n 主張1, 2 から，$C$ と $C\u0026rsquo;$ の公約数の集合が一致することがわかるので， $g = \\text{GCD}(C\u0026rsquo;)$ である．\n(主張1の証明) 頂点$1$から頂点$x$への最短パスと辺$(x, y)$ と 頂点 $y$ から頂点 $1$ への最短パスをつなぐと，長さ $\\text{dist}(1, x) + 1 + \\text{dist}(y, 1)$ のサイクルになる． $g$ はこういうものたちの公約数であった．(終)\n(主張2の証明) 正の整数 $a$ をとる． 任意の辺 $(x, y)$ に対して $a \\mid (\\text{dist}(1, x) + 1 + \\text{dist}(y, 1))$ と仮定する． このとき，$1 = x_1, x_2, x_3, \\ldots$ が頂点1を出発するパスであれば， $\\text{dist}(1, x_i) \\equiv i - 1 \\pmod a,\\quad \\text{dist}(x_i, 1) \\equiv 1 - i \\pmod a$ であることを帰納法で示す． これが示せれば，$x_k = 1$ であれば $k \\equiv 1 \\pmod a$ である． つまり，サイクルの長さは $a$ の倍数である．\n$i = 1$ は自明．$i$までOKとすると， 辺 $(x_i, x_{i + 1})$ に関して， $\\text{dist}(1, x_i) + 1 + \\text{dist}(x_{i + 1}, 1) \\equiv 0$ だから， 帰納法の仮定より $\\text{dist}(x_{i + 1}, 1) \\equiv i$．\n$\\text{dist}(1, x_{i + 1})$ については， もし $x_{i + 1} = 1$ なら $i \\equiv 0, \\quad\\text{dist}(1, x_{i + 1}) = 0 \\equiv i$ でOKなので，$x_{i + 1} \\neq 1$ とする．$x_{i + 1}$ から $1$ への 最短パス上で，$x_{i + 1}$ の隣の点を $y$ とすると， $0 \\equiv \\text{dist}(1, x_{i + 1}) + 1 + \\text{dist}(y, 1) \\equiv \\text{dist}(1, x_{i + 1}) + 1 + (i - 1)$ より， $\\text{dist}(1, x_{i + 1}) \\equiv i$．(終)\nまあ，証明はできたものの，公式解説の方法の方がずっと良い．\nACコード 提出したコード ","permalink":"https://yamate11.github.io/blog/posts/2023/06-18-abc306g/","summary":"ABC306G Return to 1 の解法です","title":"Return to 1 - Atcoder Beginner Contest 306 G"},{"content":"$n$ 以下の整数での，約数の個数の最大値を計算しておく．たとえば，$n = 10$ のときには，6 と 8 がおのおの 1,2,3,6 および 1,2,4,8 と，4個の約数を持ち，これが最大．$n=100$なら，たとえば72が12個の約数 1,2,3,4,6,8,9,12,18,24,36,72 を持つ．\n結果    $n$ 個数     $10$ 4   $10^2$ 12   $10^3$ 32   $10^4$ 64   $10^5$ 128   $10^6$ 240   $10^7$ 448   $10^8$ 768   $10^9$ 1344   $10^{10}$ 2304   $10^{11}$ 4032   $ 10^{12}$ 6720    たとえば $n \\leq 10^5$ なら，$n$ の約数全体を二重ループで回しても 20,000回くらいで終わる，とかがわかる．\nコード #include \u0026lt;bits/stdc++.h\u0026gt;#include \u0026lt;cassert\u0026gt;using namespace std;  // Prime numbers up to 100. // Note that their product is larger than 2^64. vector\u0026lt;int\u0026gt; primes({2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,  47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97});  // Returns the maximum number of divisors of number s such that // t * s \u0026lt;= n and all prime divisors of s are greater than or equal // to primes[i] int num_div(long long int n, long long int t, int i) {  int p = primes[i];  int ret = 1;  int r = 1;  long long int q = p; // q = p ^ r  while (t * q \u0026lt;= n) {  ret = max(ret, (r + 1) * num_div(n, t * q, i + 1));  q *= p;  r++;  }  return ret; }  // Returns 10^n long long int pow10(int n) {  long long int ret = 1;  while (n-- \u0026gt; 0) ret *= 10;  return ret; }  int main(/* int argc, char *argv[] */) {  for (int k = 1; k \u0026lt;= 12; k++) {  cout \u0026lt;\u0026lt; \u0026#34;10^\u0026#34; \u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; num_div(pow10(k), 1, 0) \u0026lt;\u0026lt; endl;  }  return 0; } EDIT (2020/08/22): 単独でコンパイルできるようにコードを修正．\n","permalink":"https://yamate11.github.io/blog/posts/2023/06-03-num-divisors/","summary":"nまでの約数の個数の表と，求めるためのコード","title":"約数の個数"},{"content":"K 番目の要素 (non explicit) explicit ではない集合 $X$ の，小さい方から $K$ 番目の要素を，二分探索で求める． ただし，$1 \\leq K \\leq |X|$ とする．\n$K$ 番目の要素は， 「$X_i \\leq t$ となる $i$ が $K$ 個以上となる最小の $t$」であるから， $\\text{binsearch}(\\lambda t.\\; | \\{i : X_i \\leq t \\} | \\geq K, \\max(X), \\min(X) - 1)$ で求められる．\nauto check = [\u0026amp;](ll t) -\u0026gt; bool {  return \u0026#34;the number of i such that X[i] \u0026gt;= t\u0026#34;; }; ll ans = binsearch_i\u0026lt;ll\u0026gt;(check, \u0026#34;max of X\u0026#34;, \u0026#34;min of X\u0026#34; - 1); 言い換えると， 「$X_i \u0026lt; t$ となる $i$ が $K$ 個未満となる最大の $t$」でもあるから， $\\text{binsearch}(\\lambda t.\\; | \\{i : X_i \u0026lt; t \\} | \u0026lt; K, \\min(X), \\max(X) + 1)$ でも求められる．\nauto check = [\u0026amp;](ll t) -\u0026gt; bool {  return \u0026#34;the number of i such that X[i] \u0026lt; t\u0026#34;; }; ll ans = binsearch_i\u0026lt;ll\u0026gt;(check, \u0026#34;min of X\u0026#34;, \u0026#34;max of X\u0026#34; + 1); ベクトル v の t 付近の要素 $v$ の要素は整数型とする．\n基本は次のこと:\n $v_i \u0026lt; t$ となる $i$ の個数は， lower_bound(ALL(v), t) - v.begin() である．\n $v_i \\leq t$ については，$v_i \u0026lt; t + 1$ と言い換えれば良いし， $v_i \u0026gt; t$ や $v_i \\geq t$ については，$|v|$ から引けば良い．\nまた，添字の値については次の通り．\n $v_i \u0026lt; t$ となる最大の $i$ の値は，(上の個数 - 1) である． 存在しない場合には当然 -1 になる． $v_i \\leq t$ となる最大の $i$ の値も同様． $v_i \u0026gt; t$ となる最小の $i$ の値は，もちろん， upper_bound(ALL(v)) - v.begin() である． $v_i \\geq t$ となる最小の $i$ の値は，もちろん， lower_bound(ALL(v)) - v.begin() である．  keywords: k-th element, binary search, lower_bound, upper_bound\n","permalink":"https://yamate11.github.io/blog/posts/2023/06-01-kth-element/","summary":"K番目の要素の二分探索による求め方と，ベクトルのt付近の要素","title":"K番目..."},{"content":"概要 今朝 (2023.04.25 \u0026hellip;もう昨日だ\u0026hellip;) の あさかつ で Picking Goods という問題が出ました． もとは ABC175-E です．\nvector を3重にネストさせて解いたのですが， このようなときに，添字を並べる順序によって結構性能に差が出ます． でも，どの順序で添字を並べれば良いのか，よくわかりません． 測定してみたのですが，やはりよくわかりませんでした，という報告です．\nPicking Goods の問題概要 $R$行$C$列に並んだマス目に$K$個のアイテムがある． $i$番目のアイテムは $(r_i, c_i)$ にあり，価値 $v_i$ を持つ． マス $(1, 1)$ から，マス $(R, C)$ まで，右か下に移動していく． マスにあるアイテムを拾っても拾わなくても良い． 同一行で拾えるアイテムは3個以下．拾うアイテムの価値の最大値を求めよ．\n主な制約:\n $1 \\leq R, C \\leq 3000$ $1 \\leq K \\leq 2\\times 10^5$ $1 \\leq v_i \\leq 10^9$  解法概要 $dp(r, c, k) :=$ マス $(r, c)$ に入ってきたときに， すでにその行で $k$ 個拾っている場合の， 拾ったアイテムの価値合計の最大値\nおおむね次のような感じで解ける:\n ll ans = 0;  REP(r, R) REP(c, C) REP(k, 4) {  ll v = そのマスにあるアイテムの価値;  ll w = dp[r][c][k]  if (r + 1 \u0026lt; R) {  chmax(dp[r + 1][c][0], w);  if (k \u0026lt; 3) chmax(dp[r + 1][c][0], w + v); }  if (c + 1 \u0026lt; C) {  chmax(dp[r][c + 1][k], w);  if (k \u0026lt; 3) chmax(dp[r][c + 1][k + 1], w + v); }  if (r + 1 == R and c + 1 == C) {  chmax(ans, w)  if (k \u0026lt; 3) chmax(ans, w + v); }} vector のネスト順と性能 上のコードでは，dp は，次の順序で定義する想定になっています． (RやCは3000くらいでした)\n vector dp(R, vector(C, vector(4, 0LL)));  これをたとえば\n vector dp(C, vector(4, vector(R, 0LL)));  に変えても正しいコードです．R, C, 4 の順序は全部で $3! = 6$ 通りあ り得ますので，そのうちどれにするのが性能的に有利か? というのが知り たいことです．\nここで気になるのは，vector の定義の順だけでなく， ループの順序も関係しそうだ，ということです．上のコードで\n REP(r, R) REP(c, C) REP(k, 4)  となっているところを，たとえば\n REP(c, C) REP(r, R) REP(k, 4)  などと変えることを考えると，ループ順で 6 通り，vector の順序で 6 通りの 合わせて 36 通りで，どれが良いのか，という問題になります． 以下では，ベクトルの順序を RCK, CKR などと，ループの順序を rck, crk などと 書くことにします．\nこの Picking Goods の問題では (たいていの問題でも(?))， vector の順序は 6 種類のどれをとっても正しい値になりますが， ループ順の方はそうではありません．rck, rkc, crk は正しい値になりますが， ckr, krc, kcr では正しくありません．しかし，(この問題に限らない) 性能の 観点から，(この問題については) 正しくない順序も合わせて測定してみました．\n結果 R=3000, C=3000 で 各5回測定して，平均を出しています．\n* rck (正しい) RCK 443.84 RKC 185.02 CRK 1074.77 CKR 1175.56 KRC 282.28 KCR 538.78  * rkc (正しい) RCK 455.33 RKC 168.84 CRK 2350.77 CKR 2412.47 KRC 265.45 KCR 1149.02  * crk (正しい) RCK 710.31 RKC 674.53 CRK 418.03 CKR 165.88 KRC 556.53 KCR 215.19  * ckr (正しくない) RCK 2187.65 RKC 2367.59 CRK 470.11 CKR 178.29 KRC 1166.15 KCR 202.46  * krc (正しくない) RCK 538.14 RKC 188.89 CRK 2716.52 CKR 2419.14 KRC 213.24 KCR 1159.28  * kcr (正しくない) RCK 2331.38 RKC 2501.15 CRK 538.46 CKR 189.43 KRC 1177.99 KCR 210.80 以下のようなことが見てとれます．\n (正しいループ順に限っても) vector の順序によって， 性能に大きな差が生じる (10倍以上違う) vector の順を決めても，ループ順が変われば速度は異なる． 良く言われる，「小さいものを先にした方が良い」ということは， いつでも必ず成り立つとまでは言えない．(rkc - KCR などを参照) R と C を入れ換えると大きく結果が違う例もある．この問題の場合， 行と列が対称ではなく，(特にKとの関係での) アクセスのされ方が異なる ことが効いているのであろうか． (この一つの例から一般化するのは非常に危険だが) ループ順と vector 順を揃えておく (rck - RCK や kcr - KCR など) と (必ずしも最良の結果が得られるとは言えないものの) 最悪の 結果は避けられているように見える  いくつか補足．\n $v_i$ も，2次元のベクトルに保存することになると思いますが， そうすると，この順序も関係しそうです．ここでは，その影響を 避けるために，v_i は入力として与えず，10000 個くらいの点に 適当に値を与えています．(具体的には次で計算される v を 使っています．) この変更によって，実際に問題を解く場合より， かなり速度が速くなっています．   ll v = 0;  if ((r \u0026amp; 0x1f) == 1 and (c \u0026amp; 0x1f) == 1) v = (r \u0026gt;\u0026gt; 5) + (c \u0026gt;\u0026gt; 5);  この測定結果は，私のローカル環境に依存するところも大きいと思います． AtCoder で測定してみたわけではありません．環境は， Ubuntu (Window ホストの Virtual Box) 20.04 上の GCC 9.4.0 です． -std=gnu++17 -O2 でコンパイルしています．  ","permalink":"https://yamate11.github.io/blog/posts/2023/04-26-multi-dim-vect-order/","summary":"ネストしたベクトルは，添字を並べる順序で性能が変わるが，どのように並べれば良いかはよくわからない．","title":"ネストした vector の順序と性能"},{"content":"インタラクティブ問題を解くスタイルについての，自分用のメモ． いろいろ試行したが，現状 (2023年4月現在) はこれになっている．\nrunning example  長さ $N$ のソート済みの整数列 $P_1, \\ldots, P_N$ が隠されている． $N$ と $x$ が最初に与えられる． 「$i$ 番目の整数は何か」との質問を，たかだか 10 回おこなって，$P_i = x$ となる $i$ を答えよ． 存在しない場合には -1 と答えよ．\n 質問の形式: ? i 答の形式: ! i  制約: $N \\leq 1000$，$P_i \u0026lt; P_j (i \u0026lt; j)$，\n コーディング 特別なサポートは行っていない．\n質問用の関数と解答用の関数は用意しておくと良い．\nll ask(ll i) {  cout \u0026lt;\u0026lt; \u0026#34;? \u0026#34; \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; endl; // 0-index 等はここで調整  ll x; cin \u0026gt;\u0026gt; x;  return x; }  void fin(ll i) {  cout \u0026lt;\u0026lt; \u0026#34;! \u0026#34; \u0026lt;\u0026lt; (i \u0026gt;= 0 ? i + 1 : -1) \u0026lt;\u0026lt; endl;  exit(0); } main 関数は，ask() と fin() を使って書く．\nint main(/* int argc, char *argv[] */) {  ios_base::sync_with_stdio(false);  cin.tie(nullptr);  cout \u0026lt;\u0026lt; setprecision(20);   ll N, x; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; x;  ll lo = -1, hi = N;  while (true) {  if (lo + 1 == hi) fin(-1);  ll mid = (lo + hi) / 2;  ll y = ask(mid);  if (y \u0026lt; x) lo = mid;  else if (x \u0026lt; y) hi = mid;  else if (x == y) fin(mid);  }   return 0; } ジャッジプログラム デバッグするとなると，やはりジャッジプログラムが必要になると思われる． ジャッジプログラムを動作させるスクリプト interun を作ってある． この環境で動かすためには，ジャッジプログラムは次のように作成する．\n 問題を標準入力から読み込む．  問題のフォーマットは自分で適当に決める． 問題ファイルを din_x.txt として用意する．   解答プログラムとのやりとりも，標準入出力を使う． ユーザに読ませたい出力は，行頭に # を置いて (標準エラー出力ではなく) 標準出力に出す． judge という名前で実行するようにしておくと良い (オプションで指定も可能)  次を定義しておくと良い．\nvoid ac() {  cout \u0026lt;\u0026lt; \u0026#34;# AC\u0026#34; \u0026lt;\u0026lt; endl;  exit(0); }  void wa(string msg = \u0026#34;\u0026#34;) {  cout \u0026lt;\u0026lt; \u0026#34;# WA: \u0026#34; \u0026lt;\u0026lt; msg \u0026lt;\u0026lt; endl;  exit(1); } main を書く．正解したら ac() を，不正解なら wa() を呼ぶ．\nint main() {  ll N, x, ans; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; x \u0026gt;\u0026gt; ans; // 解答も与えられると想定  vector\u0026lt;ll\u0026gt; P(N); REP(i, 0, N) cin \u0026gt;\u0026gt; P[i];  cout \u0026lt;\u0026lt; N \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl;  ll cnt = 0;  while (true) {  string tp; cin \u0026gt;\u0026gt; tp;  if (tp == \u0026#34;?\u0026#34;) {  if (cnt++ \u0026gt;= 10) wa(\u0026#34;Exceeds Limit\u0026#34;);  ll i; cin \u0026gt;\u0026gt; i;  cout \u0026lt;\u0026lt; P[i - 1] \u0026lt;\u0026lt; endl;  }else if (tp == \u0026#34;!\u0026#34;) {  ll i; cin \u0026gt;\u0026gt; i;  if (i == ans) ac(); else wa();  }else assert(0);  } } # で始まる出力は，ユーザ向けである． interun は，両プログラムのやりとりをログファイル (デフォルト a.log) に出力するので，誤答の場合に渡された値などは必ずしも出力しなくても良い．\n実行 din_?.txt ファイルを用意する． ここでは，正解もファイルに書き込まれているという想定としているが， ジャッジプログラムの作り方によっては不要にもできる．\n5 30 4 1 10 15 30 100 実行する:\n$ interrun \u0026lt; din_1.txt cans, judge, a.log の名前は interun のオプションで変更できる．\ncmpNaive デバッグ時の cmpNaive では，解答プログラム cans と ジャッジプログラム judge は別プロセスとの想定である． スレッド対応はしていない．\n$ cmpNaive -e -i -p $AtCoderTop/clib/tool/interun interun は，judge プログラムと同じ終了コードを返すので， -e (終了コードでの判定), -i (独立プロセス) を指定して， interun の実行を指定して cmpNaive を実行すれば良い． interun にオプションを指定したいときには次のようにする:\n$ cmpNaive -e -i -p \u0026#34;$AtcoderTop/clib/tool/interun -j ./my_judge\u0026#34; keyword: interactive\n","permalink":"https://yamate11.github.io/blog/posts/2023/04-21-interactive-debug/","summary":"インタラクティブ問題のデバッグ方法","title":"インタラクティブ問題のデバッグ"},{"content":"経緯 よく考えればもちろん作れるのだけれど，すぐ間違うのでメモをしておきます．\n公式 $d \\in \\mathbb{Z}$，$t \\in \\mathbb{R}$ とする．\n $d \\leq t \\iff d \\leq \\lfloor t \\rfloor$ $d \u0026lt; t \\iff d \u0026lt; \\lceil t \\rceil$ $t \\leq d \\iff \\lceil t \\rceil \\leq d$ $t \u0026lt; d \\iff \\lfloor t \\rfloor \u0026lt; d$  考え方 \\begin{eqnarray*} d\\leq t \u0026amp;\\iff\u0026amp; t \\in \\{ t \\mid d \\leq t \\} \\\\ \u0026amp;\\iff\u0026amp; t \\in \\bigcup \\{ [e, e+1) \\mid e = d, d+1, \\ldots \\} \\\\ \u0026amp;\\iff\u0026amp; \\bigvee \\{ t \\in [e, e+1) \\mid e = d, d+1, \\ldots \\} \\\\ \u0026amp;\\iff\u0026amp; \\bigvee \\{ \\lfloor t \\rfloor = e \\mid e = d, d+1, \\ldots \\} \\\\ \u0026amp;\\iff\u0026amp; d \\leq \\lfloor t \\rfloor \\hspace{20em} \\end{eqnarray*}\n同様に，\n\\begin{eqnarray*} d\u0026lt;t \u0026amp;\\iff\u0026amp; t \\in \\{ t \\mid d \u0026lt; t \\} \\\\ \u0026amp;\\iff\u0026amp; \\bigvee \\{ t \\in (e-1, e] \\mid e = d+1, d+2, \\ldots \\} \\\\ \u0026amp;\\iff\u0026amp; \\bigvee \\{ \\lceil t \\rceil = e \\mid e = d+1, d+2, \\ldots \\} \\\\ \u0026amp;\\iff\u0026amp; d \u0026lt; \\lceil t \\rceil \\hspace{20em} \\end{eqnarray*}\n\\begin{eqnarray*} t \\leq d \u0026amp;\\iff\u0026amp; \\bigvee \\{ t \\in (e-1, e] \\mid e = d, d - 1, \\ldots \\} \\\\ \u0026amp;\\iff\u0026amp; \\bigvee \\{ \\lceil t \\rceil = e \\mid e = d, d - 1, \\ldots \\} \\\\ \u0026amp;\\iff\u0026amp; \\lceil t \\rceil \\leq d \\hspace{20em} \\end{eqnarray*}\n\\begin{eqnarray*} t \u0026lt; d \u0026amp;\\iff\u0026amp; \\bigvee \\{ t \\in [e, e+1) \\mid e = d - 1, d - 2, \\ldots \\} \\\\ \u0026amp;\\iff\u0026amp; \\bigvee \\{ \\lfloor t \\rfloor = e \\mid e = d - 1, d - 2, \\ldots \\} \\\\ \u0026amp;\\iff\u0026amp; \\lfloor t \\rfloor \u0026lt; d \\hspace{20em} \\end{eqnarray*}\n追記 (追記: 2023/03/23)\nこれを使う場面として良くあるのが，正の整数 $a$, $b$, $c$ について $ab \\leq c$ などであるかどうかを判定したいが， $ab$ が long long に収まらないかもしれない， というとき． $ab \\leq c \\iff a \\leq c/b \\iff a \\leq \\lfloor c/b \\rfloor$ などとして，判定すれば良い．\nなお，この目的のためには，GCC の拡張 __builtin_smulll_overflow も使える (Signed - MULtiplication - Long Long)． 形式は，\nbool __builtin_smulll_overflow(long long a, long long b, long long* res) で，a * b が long long でオーバーフローする時は true が返る． オーバーフローしない時には false が返り，*res に積が設定される． たとえば上記の判定は:\nif (long long ab; not __builtin_smulll_overflow(a, b, \u0026amp;ab) and ab \u0026lt;= c) {  ... } などと実現できる．\n","permalink":"https://yamate11.github.io/blog/posts/2021/02-13-int-inequality-floor/","summary":"経緯 よく考えればもちろん作れるのだけれど，すぐ間違うのでメモをしておきます．\n公式 $d \\in \\mathbb{Z}$，$t \\in \\mathbb{R}$ とする．\n $d \\leq t \\iff d \\leq \\lfloor t \\rfloor$ $d \u0026lt; t \\iff d \u0026lt; \\lceil t \\rceil$ $t \\leq d \\iff \\lceil t \\rceil \\leq d$ $t \u0026lt; d \\iff \\lfloor t \\rfloor \u0026lt; d$  考え方 \\begin{eqnarray*} d\\leq t \u0026amp;\\iff\u0026amp; t \\in \\{ t \\mid d \\leq t \\} \\\\ \u0026amp;\\iff\u0026amp; t \\in \\bigcup \\{ [e, e+1) \\mid e = d, d+1, \\ldots \\} \\\\ \u0026amp;\\iff\u0026amp; \\bigvee \\{ t \\in [e, e+1) \\mid e = d, d+1, \\ldots \\} \\\\ \u0026amp;\\iff\u0026amp; \\bigvee \\{ \\lfloor t \\rfloor = e \\mid e = d, d+1, \\ldots \\} \\\\ \u0026amp;\\iff\u0026amp; d \\leq \\lfloor t \\rfloor \\hspace{20em} \\end{eqnarray*}","title":"整数・実数の大小比較とfloor, ceil"},{"content":"mod ライブラリで素数以外の法に関してできることを書きます．\n制限なくできること  加算 減算 乗算  これらは，単に整数として演算した後に法で割って余りを求める (あるいはそれと同値なことをする) だけだから，できる．\n除算 $\\bmod M$ における $a/b$ というのは， 「$b$ にかけたら $a$ になる数」である．\nできる場合 $(b, M) = 1$ ならば，一意に存在する．\n (存在)$\\quad$ $bu + Mv = 1$ となる $u, v$ がとれるので，$x = au$ とすればよい． (一意性)$\\quad$ $bx \\equiv bx\u0026rsquo; \\equiv a$ ならば， $b(x - x\u0026rsquo;) \\equiv 0$ だから，$x \\equiv x\u0026rsquo;$となる．  特に $M$ が素数ならば， $b\\not\\equiv 0 \\pmod M$ のとき，一意に存在する．\nできない場合 $(b, M) \\neq 1$ のときは，存在しないかもしれないし，複数あるかもしれない．\n 例\n $2x \\equiv 3 \\pmod 4$ となる $x$ は存在しない． $2x \\equiv 2 \\pmod 4$ となる $x$ は， $x = 1$, $x = 3$ の2つがある．   mod ライブラリでは，$(b, M) \\neq 1$ の時に $a/b$ を実行すると， 実行時エラーにしている．\n割り切れる除算 $a/b$ が整数になるとわかっている場合，$a/b \\bmod M$ を求めるのに， $r := a\\bmod bM$ を求めるという方法がある． $a = bMu + r$ とすると，$a/b = Mu + r/b$ であるから， $r/b$ は整数になるはずなので，普通に整数で割り算をすれば良い． $bM$ が大きな数になる可能性があって，int128 などが必要になるかもしれない．\n例題: ABC293-E (この方法による解説 )\n","permalink":"https://yamate11.github.io/blog/posts/2023/03-12-mod-not-prime/","summary":"mod ライブラリで素数以外の法に関してできること","title":"素数以外の mod"},{"content":"順列組合せ (重複有り無し) を生成するライブラリ Perm に関するメモです．\nstruct 4つの struct がある．名前がおかしいのは歴史的理由による．\n IntPerm 順列 IntComb 組合せ IntDupPerm 重複順列 IntDupComb 重複組合せ  constructor IntPerm ip(m, n); IntComp ic(m, n); IntDupPerm idp(m, n); IntDupComb idc(m, n); これらはいずれも，$[0, m)$ の数からなる長さ $n$ のリストを生成する．\nこのライブラリでは，「順列」と「組合せ」の違いは， 後者は昇順にソートされている，ということである．\nIntPerm $[0, m)$ からなる長さ $n$ のリストで，同じ数がたかだか1回しか現れない ものを列挙する．\nたとえば ip(4, 2) は，次を生成する:\n[0,1], [0,2], [0,3], [0,4], [1,0], [1,1], [1,2], [1,3], [2,0], [2,1], [2,2], [2,3], [3,0], [3,1], [3,2], [3,3] IntComb $[0, m)$ からなる長さ $n$ のリストで，同じ数がたかだか1回しか現れず， 昇順ソートされているものを列挙する．\nたとえば，ic(4, 2) は，次を生成する:\n[0,1], [0,2], [0,3], [0,4], [1,2], [1,3], [2,3] IntDupPerm $[0, m)$ からなる長さ $n$ のリストを列挙する．\nたとえば idp(4, 2) は，次を生成する:\n[0,0], [0,1], [0,2], [0,3], [1,0], [1,1], [1,2], [1,3], [2,0], [2,1], [2,2], [2,3], [3,0], [3,1], [3,2], [3,3] IntDupComb $[0, m)$ からなる長さ $n$ のリストで，昇順ソートされているものを列挙する．\nたとえば idc(4, 2) は，次を生成する:\n[0,0], [0,1], [0,2], [0,3], [1,1], [1,2], [1,3], [2,2], [2,3], [3,3] 生成 obj.get() が true を返す間，新しいリストが生成される． リストの i 番目の要素は，obj.at() である．\nwhile (ip.get()) {  for (int i = 0; i \u0026lt; 2; i++) cout \u0026lt;\u0026lt; ip.at(i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } 注意1 obj.get() が false を返すときには，内部状態は初期値に戻るので， そのまま次のラウンドを実行することができる．\n注意2  $n \\geq 0, r \\geq 0$ でないときには，何も生成しない． IntPerm と IntComb は，$r \\leq n$ でないときには，何も生成しない． IntDupPerm と IntDupComb は，$n = r = 0$ のときに， 何も生成しないのでは なく，空リスト [] を生成する． これは，ことによると適切でないかもしれない． ($0^0 = 1$ になるし，$H(n, r) \\neq C(n+r-1, r)$ になるから) $n = 0$ かつ $r \\neq 0$ の場合には，何も生成しない．  デバッグ用 const vector\u0026lt;int\u0026gt;\u0026amp; obj.vec_view(); を使えば，DLOG に渡せる．\n忘れやすい利用シーン ボールと仕切りの重複組合せ 区別されない $a$ 個のボールを 区別される $b$ 個の箱に入れる方法は， IntDupComb(b, a) が列挙するリストと対応付けられる． リスト $[x_1, \u0026hellip;, x_a]$ は，ボール $1$ が箱 $x_1$に，ボール $2$ が箱 $x_2$に， \u0026hellip;, ボール $a$ が箱 $x_a$ に入っていることを意味している． (ボールを区別しないことは，入る箱を昇順にして良いことと対応している．) したがって，各箱に入っているボールの数は，次のように求められる．\nIntDupComb idc(b, a); while (idc.next()) {  vector\u0026lt;ll\u0026gt; numBalls(b);  REP(i, 0, a) numBalls[idc.at(i)]++;  // 箱 j にはボールが numBalls[j] 個入っている } ","permalink":"https://yamate11.github.io/blog/posts/2023/02-28-perm-dup/","summary":"順列組合せ・重複ありなし ライブラリに関するメモです．","title":"順列組合せ"},{"content":"ダブリングを行うライブラリを書きました．自分用のメモです．\nできること その1 $f : [0, N) \\to [0, N)$ が与えられた時， $f^{r}(i)$ を，$r \\in [0, R]$ と $i \\in [0, N)$ に対して計算する．\n典型的には:\n $N$ は $10^5$ くらい，$R$ は $10^{18}$ くらい，または $N$ も $R$ も $10^5$ くらいだが，何回も (たとえば $10^5$回くらい) 計算する  その2 上の $f$ の他に，モノイド $(M, \\oplus)$ と $m: [0, N) \\to M$ が与えられて， $r, i$ に対して $\\bigoplus_{k = 0}^{r} m(f^{k}(i))$ を計算する．\n使用例 その1 ll R = 100000, N = 100000; auto f = [\u0026amp;](ll i) -\u0026gt; ll { return i * i % N; }; DoublingFRel d(R, N, f); ll r = 12345, i = 54321; cout \u0026lt;\u0026lt; d.val(r, i) \u0026lt;\u0026lt; endl; // f^{r}(i) 内部テーブルには，$f^{r}(i)$ が，$i \\in [0, N)$ と $r = 1, 2, 4, 8, \\ldots$ に対して 格納されている．\nその2 struct M {  ll v;  M(ll v_ = LLONG_MIN) v(v_) {}  M operator+(const M\u0026amp; o) const { return M(max(v, o.v)); } };  ll R = 100000, N = 100000; auto f = [\u0026amp;](ll i) -\u0026gt; ll { return i * i % N; }; auto m = [\u0026amp;](ll i) -\u0026gt; M { return M(i * i * i); };  DoublingFRel d1(R, N, f); DoublingCum\u0026lt;M\u0026gt; d2(d1, m); ll r = 12345, i = 54321; cout \u0026lt;\u0026lt; d2.val(r, i); // \\sum { m( f^{(j)}(i) ) | j = 0, 1, ..., r-1 } 内部テーブルには， $m( f^{r}(i) )$ が，$i \\in [0, N)$ と $r = 1, 2, 4, 8, \\ldots$ に対して格納されている．\n普通の和を計算するのなら，struct M を定義する必要はない． ただし，DoublingCum\u0026lt;ll\u0026gt; のように，テンプレートパラメタを明示的に 与える必要がある．\nkeywords: doubling\n","permalink":"https://yamate11.github.io/blog/posts/2022/12-10-doubling/","summary":"ダブリングを行うライブラリを書きました．自分用のメモです．\nできること その1 $f : [0, N) \\to [0, N)$ が与えられた時， $f^{r}(i)$ を，$r \\in [0, R]$ と $i \\in [0, N)$ に対して計算する．\n典型的には:\n $N$ は $10^5$ くらい，$R$ は $10^{18}$ くらい，または $N$ も $R$ も $10^5$ くらいだが，何回も (たとえば $10^5$回くらい) 計算する  その2 上の $f$ の他に，モノイド $(M, \\oplus)$ と $m: [0, N) \\to M$ が与えられて， $r, i$ に対して $\\bigoplus_{k = 0}^{r} m(f^{k}(i))$ を計算する．\n使用例 その1 ll R = 100000, N = 100000; auto f = [\u0026amp;](ll i) -\u0026gt; ll { return i * i % N; }; DoublingFRel d(R, N, f); ll r = 12345, i = 54321; cout \u0026lt;\u0026lt; d.","title":"ダブリングライブラリ"},{"content":"\\begin{eqnarray} \u0026amp; \\sum_{r=0}^{n}\\binom{n}{r}a^r b^{n-r} = (a + b)^n \\\\ \u0026amp; \\sum_{r=0}^{n}\\binom{n}{r} = 2^n \\\\ \u0026amp; r\\binom{n}{r} = n\\binom{n-1}{r-1} \\\\ \u0026amp; \\binom{n}{r} + \\binom{n}{r + 1} = \\binom{n+1}{r + 1} \\\\ \u0026amp; \\sum_{i=r}^{n}\\binom{i}{r} = \\binom{n+1}{r+1} \\\\ \u0026amp; \\sum_{i=0}^{c}\\binom{a}{i}\\binom{b}{c-i} = \\binom{a+b}{c} \\\\ \\end{eqnarray}\n注  (1) 二項定理 (2) 上で $a = b = 1$ (3) 定義に従って展開 (4) パスカルの三角形の作り方 (5) Hockey Stick Identity (6) a + b から c をとるとき，a から i とったとすれば，残りは b からとっている．  ","permalink":"https://yamate11.github.io/blog/posts/2022/10-29-binom/","summary":"二項係数に関する公式です．","title":"二項係数に関する公式"},{"content":" setw(int n)  桁数を n にする   setfill(char c)  余った場所を c で埋める．   oct  8進にする   hex  16進にする   dec  10進にする   fixed  固定小数点表示にする   scientific  浮動小数点表示にする    ","permalink":"https://yamate11.github.io/blog/posts/2022/10-23-ipmanip/","summary":" setw(int n)  桁数を n にする   setfill(char c)  余った場所を c で埋める．   oct  8進にする   hex  16進にする   dec  10進にする   fixed  固定小数点表示にする   scientific  浮動小数点表示にする    ","title":"よく使う iomanip の modifier"},{"content":"全方位木ライブラリ使用法のメモ\nこのライブラリで解ける問題 $\\mathcal{M} = (M, \\oplus, e)$ を可換モノイドとする． 根付き木 $T$ に関し，ノード $x$ の親を $p(x)$， ノード $x$ の子の集合を $C(x)$ と書く．\n根付き木 $T$ に対して， $g : (M \\times T \\times T) \\to M$ から次のように帰納的に定義される 関数 $f : T \\to M$ を考える:\n $f(n) = \\bigoplus \\{ g(f(c), n, c) \\mid c \\in C(n) \\} $  単に $f$ と書いたが，どこを根とするかによって異なる関数が 定義できている．明示的に根 $r$ を示すと次のようになる．\n $f_r(n) = \\bigoplus \\{ g(f_r(c), n, c) \\mid c \\in C_r(n) \\} $  ここで，$F : T \\to M$ を，$F(n) := f_n(n)$ で定義する．\nこのライブラリでは，$\\mathcal{M}$ と $g$ を与えて， $F$ の各ノードでの値が計算できる．\n注意  計算量は $O(|T|)$． 実装では左からの和と右からの和を利用しているので， 逆演算が定義されていなくても計算できる (が，重い)． $F$ 自体が問題の答となるとは限らなくて，さらにそこから もうひと計算する必要があることもある． g を適用して，モノイド演算が実施できるような形にするところがポイント  例題 ABC160F - Distributing Integers   木が与えられる．各頂点 $k$ につき，次の問題を解け\n 頂点 $k$ に 1 を書き，残りの頂点には，既に書き込まれた頂点に 隣接する頂点に 2, 3, \u0026hellip; の数を書く． このように書ける方法の数を$\\mod 10^9 + 7$ で求めよ．   全方位木を使うには，\n 頂点を1つ固定した問題が，木DPで解けて， その木DPの際に，各ノードの処理がモノイド演算でできること  が必要．ということで，まず，$k$ を固定した問題を 木DPで解く方法を考える．\n 1 は根に書くと決まっている． 根の子供が $c_1, c_2, c_3$ として，その部分木の数を $m_1, m_2, m_3$ とする． 2 ～ N を，この3つに割り振る方法を決めると，各 部分木の小問題では，$1$ から $m_1$ の問題が解けていればそれで決まる．  具体的には，上の場合，\n$$f(1) = \\binom{N - 1}{m_1}f(c_1)\\binom{m_1}{m_2}f(c_2)\\binom{m_3}{m_3}f(c_3) = (N - 1)!\\prod\\frac{f(c_i)}{m_i}$$\nとなる．一般も同じ．少し変形して，\n$$ \\frac{f(n)}{(m_n - 1) !} = \\prod \\frac{f(c)}{m_c} $$\nより，$\\hat{f}(n) := f(n) / (m_n - 1)!$ と置いて，\n$$ \\hat{f}(n) = \\prod \\hat{f}(c)\\cdot\\frac{1}{m_c} $$\nとなるので，モノイド演算は積，単位元1，$g(\\alpha, n, c) := \\alpha / m_c$で $\\hat{f}$が計算でき，したがって $f$ が求められる．\n例題 EDPC V Subtree   木と正整数 $M$ が与えられる． 全頂点を白黒に塗り分けるに塗り分け，任意の2つの異なる黒頂点a,bに関して， a から b へのパスが全部黒で塗られているようにする 各頂点$v$について，上を満たして $v$ が黒く塗られる塗り方の数を $\\mod M$ で求めよ．\n ここでは，白く塗られる塗り方の数も問われているものだと仮定して， 解を考える．\n3つの条件を考える．\n B(n): n は黒く塗られ，n の子孫は条件を満たす． W(n): n は白く塗られ，n の子孫は条件を満たす． A(n): n および n の子孫はすべて白く塗られている．  ノードの集合Xについて，次のように定める．\n P(X): 全ての $c \\in X$ について B(c) または A(c) Q(X): 全ての $c \\in X$ について B(c) または W(c) であり， たかだか1つを除いて A(c) である．  これらは，n が塗れるかどうかの条件に関係する．具体的には:\n n が黒く塗れるための条件は，P(C(n))． n が白く塗れるための条件は，Q(C(n))．  $P(X)$, $Q(X)$, $P(\\{c\\})$, $Q(\\{c\\})$ を満たす塗り方の数を $\\alpha_1, \\beta_1, \\alpha_2, \\beta_2$ とするとき， $P(X \\cup \\{c\\})$, $Q(X \\cup \\{c\\})$, を満たす塗り方の数は $(\\alpha_1\\alpha_2, \\beta_1 + \\beta_2 - 1)$ である． そこで，\n $(\\alpha_1, \\beta_1) \\oplus (\\alpha_2, \\beta_2) := (\\alpha_1\\alpha_2, \\beta_1 + \\beta_2 - 1)$  で，モノイド演算を定義する．単位元は $(1, 1)$ である．\nまた，$c$ を黒，白で塗る方法の数を $\\alpha$, $\\beta$ とするとき， $P(\\{c\\})$, $Q(\\{c\\})$ を満たす塗り方の数は， $\\alpha + 1$, $\\alpha + \\beta$ である．そこで，\n $g((\\alpha, \\beta), n, c)) = (\\alpha + 1, \\alpha + \\beta)$  で，$g$ を定義する．\n","permalink":"https://yamate11.github.io/blog/posts/2022/08-17-rerooting/","summary":"全方位木ライブラリ使用法のメモ\nこのライブラリで解ける問題 $\\mathcal{M} = (M, \\oplus, e)$ を可換モノイドとする． 根付き木 $T$ に関し，ノード $x$ の親を $p(x)$， ノード $x$ の子の集合を $C(x)$ と書く．\n根付き木 $T$ に対して， $g : (M \\times T \\times T) \\to M$ から次のように帰納的に定義される 関数 $f : T \\to M$ を考える:\n $f(n) = \\bigoplus \\{ g(f(c), n, c) \\mid c \\in C(n) \\} $  単に $f$ と書いたが，どこを根とするかによって異なる関数が 定義できている．明示的に根 $r$ を示すと次のようになる．\n $f_r(n) = \\bigoplus \\{ g(f_r(c), n, c) \\mid c \\in C_r(n) \\} $  ここで，$F : T \\to M$ を，$F(n) := f_n(n)$ で定義する．","title":"全方位木ライブラリ"},{"content":"インタラクティブな問題がたまに出題される． 特別扱いする必要があるか，ということだが， 何も考えずに書いてしまうとデバッグが難しい，ということがあるので， やはり形式を整えておきたい感じである．\n先日の Codeforces R.812 (Div 2) Tournament Countdown で，TLE というめにあった． virtual base class を持つオブジェクトのメソッド呼び出しがあったりしたのが 良くなかったのではないかと思う．\nということで，軽く実行できるようにしたい．\nポイントとしては，ask() 関数と answer() 関数を用意する． これらで，問と答の入出力部分をラップする． 実装するときには，ask_i() と answer_i() という名前で書く． 通常はこちらを ask(), answer() として使い， 自動テストのと期には ask_judge(), answer_judge() に切り替える．\n典型的な実装はこんな感じ．二分探索数当てゲームを想定．\nbool judge = false;  ll ask(ll x) { return judge ? ask_judge(x) : ask_i(x); } ll answer(ll x) { if (judge) answer_judge(x); else answer_i(x); }  ll ask_i(ll x) {  cout \u0026lt;\u0026lt; \u0026#34;? \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl;  string s; cin \u0026gt;\u0026gt; s;  if (s == \u0026#34;SMALL\u0026#34;) return -1;  else if (s == \u0026#34;LARGE\u0026#34;) return 1;  else if (s == \u0026#34;EQUAL\u0026#34;) return 0;  else assert(0); }  void answer_i(ll x) {  cout \u0026lt;\u0026lt; \u0026#34;! \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; } #endif solve() 関数では，初期入力を受け取ったのち，ask() と answer() を 使って解を組み立てる．\nll L, R; void solve() {  cin \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R;  if (judge) read_judge();   ll lo = L, hi = R;  while (true) {  ll mid = (lo + hi) / 2;  ll resp = ask(mid);  if (resp == 0) { answer(mid); return; }  else if (resp \u0026lt; 0) { lo = mid; }  else { hi = mid; }  } } 自動テストに関して．本来の入力の後に問題情報を， 渡すようにするので，それを読む関数 read_judge() を，適切な位置に 置いておく(上の solve() 関数参照)．\nvoid read_judge() {  cin \u0026gt;\u0026gt; expected; } 自動テストでは，ask() 関数と answer() 関数を差し替えて， 自動テストに適した形にする．つまり，ask() は，追加情報を参照して， 適切な答を作成して返す．また，answer() は，不正解の場合には 異常終了するようにする．\nll ask_judge(ll x) {  if (x \u0026lt; expected) return -1;  else if (x == expected) return 0;  else return 1; }  void answer_judge(ll x) {  if (x == expected) return;  else exit(1); } 自動テストのときには，./cans の引数に judge を与えるようにする． int main(int argc, char *argv[]) { // \u0026hellip; if (stcmp(argv[1], \u0026ldquo;judge\u0026rdquo;) == 0) { judge = true; }\nsolve(); // multiple-question のときには，ここでループ． }\ncmpNaive を使用するときには，コマンドとして cmpNaive -i -e -p './cans judge' のように使う．ソースコードは これ以上書き直す必要は無い (naive関数は不要)．\nたとえば Codeforces R.#449 Ithea Plays with Chtholly のように，先に相手側から質問が来て，こちらはそれに答える，というタイプの ものもある．最後のこちらの答を入力したら， 直ちにプログラムを終了せよ，とか指示される． この場合は，\n 最初の質問までを初期入力と考える． こちらの n 番目の答を ask() で渡して，その戻り値として，相手の n + 1 番目の 質問を得る． こちらの最後の答は answer() で渡す．  というふうにすれば良いであろう．\n","permalink":"https://yamate11.github.io/blog/posts/2022/08-07-interactive-skelton/","summary":"インタラクティブな問題がたまに出題される． 特別扱いする必要があるか，ということだが， 何も考えずに書いてしまうとデバッグが難しい，ということがあるので， やはり形式を整えておきたい感じである．\n先日の Codeforces R.812 (Div 2) Tournament Countdown で，TLE というめにあった． virtual base class を持つオブジェクトのメソッド呼び出しがあったりしたのが 良くなかったのではないかと思う．\nということで，軽く実行できるようにしたい．\nポイントとしては，ask() 関数と answer() 関数を用意する． これらで，問と答の入出力部分をラップする． 実装するときには，ask_i() と answer_i() という名前で書く． 通常はこちらを ask(), answer() として使い， 自動テストのと期には ask_judge(), answer_judge() に切り替える．\n典型的な実装はこんな感じ．二分探索数当てゲームを想定．\nbool judge = false;  ll ask(ll x) { return judge ? ask_judge(x) : ask_i(x); } ll answer(ll x) { if (judge) answer_judge(x); else answer_i(x); }  ll ask_i(ll x) {  cout \u0026lt;\u0026lt; \u0026#34;?","title":"インタラクティブな問題に対するソーススケルトン"},{"content":"燃やす埋める問題についての記事です．\n動機 燃やす埋める問題については，一度エントリを書いた のですが，そこにはともかく理解したことを全部書いたので，コンテスト中に参照しても把握するのがたいへん，という状況になってしまっています．そこで，コンテスト中に思い出したい最小限のことだけまとめることにしました．\n考え方    問題文中に「$p$ のとき$b$を受け取る」という記載があったら，「先に $b$ を受け取る．$\\neg p$ の時 $b$ を支払う」と読み替えて，すべて支払いをすると考える． グラフ全体の source ノードのラベルは True，sink ノードのラベルは False． ノード $p$ からノード $q$ への矢印に，重み $a$ がついているのは，「$p$が成り立つのに$q$が成り立たない場合，コスト $a$ を支払う」と読む． したがって，この図では，以下が表現されている  $p_6$ が成り立って，$p_7$ が成り立たなかったら，$a_2$ 支払う． $p_1$ が成り立たなかったら，$a_5$ 支払う． $p_7$ が成り立ったら，$a_3$ 支払う． $p_8$ は成り立つ． $p_9$ は成り立たない．   最小カットが，コスト最小の真偽割当．図の赤線だと，$p_1, \\ldots, p_6, p_8$ を真，$p_7, p_9$ を偽にする割当に相当し，この場合のコストは$a_2 + a_6$． 連言や選言のノードは，矢印を出せるか入れられるかが決まっている．下図を参照．不可の理由は，たとえば連言なら，$p$, $q$を真に，$p\\land q$ を偽にできてしまうから．(矢印の根本を真にできてしまうと不当な利益がある．矢印の根本を偽にできても嬉しくない)     したがって，「$p \\land q$ なら，支払を行う」は，表現できない． しかし，$\\neg q$ の方を表すノード $r$ を用意すれば， 「$p$ が成り立って $r$ が成り立たなければ，支払を行う」の形で表現できる．  ","permalink":"https://yamate11.github.io/blog/posts/2021/05-22-burn-bury/","summary":"燃やす埋める問題についての記事です．\n動機 燃やす埋める問題については，一度エントリを書いた のですが，そこにはともかく理解したことを全部書いたので，コンテスト中に参照しても把握するのがたいへん，という状況になってしまっています．そこで，コンテスト中に思い出したい最小限のことだけまとめることにしました．\n考え方    問題文中に「$p$ のとき$b$を受け取る」という記載があったら，「先に $b$ を受け取る．$\\neg p$ の時 $b$ を支払う」と読み替えて，すべて支払いをすると考える． グラフ全体の source ノードのラベルは True，sink ノードのラベルは False． ノード $p$ からノード $q$ への矢印に，重み $a$ がついているのは，「$p$が成り立つのに$q$が成り立たない場合，コスト $a$ を支払う」と読む． したがって，この図では，以下が表現されている  $p_6$ が成り立って，$p_7$ が成り立たなかったら，$a_2$ 支払う． $p_1$ が成り立たなかったら，$a_5$ 支払う． $p_7$ が成り立ったら，$a_3$ 支払う． $p_8$ は成り立つ． $p_9$ は成り立たない．   最小カットが，コスト最小の真偽割当．図の赤線だと，$p_1, \\ldots, p_6, p_8$ を真，$p_7, p_9$ を偽にする割当に相当し，この場合のコストは$a_2 + a_6$． 連言や選言のノードは，矢印を出せるか入れられるかが決まっている．下図を参照．不可の理由は，たとえば連言なら，$p$, $q$を真に，$p\\land q$ を偽にできてしまうから．(矢印の根本を真にできてしまうと不当な利益がある．矢印の根本を偽にできても嬉しくない)     したがって，「$p \\land q$ なら，支払を行う」は，表現できない． しかし，$\\neg q$ の方を表すノード $r$ を用意すれば， 「$p$ が成り立って $r$ が成り立たなければ，支払を行う」の形で表現できる．  ","title":"燃やす埋める問題"},{"content":"AtCoder Regular Contest 141 - ARC 141 D - Non-divisible Set の解法です．解説ACです．\n問題概要 問題へのリンク $1 \\leq M \\leq N \\leq 2M$ であるような整数$N, M$ と， 整数の集合 $S = \\{ A_1, \\ldots, A_N \\}$ が与えられる． ここで，$1 \\leq A_1 \u0026lt; \\cdots \u0026lt; A_N \\leq 2M$ である． 各 $i = 1, 2, \\ldots, N$ に対して，$A_i$を含む要素数$M$の$S$の部分集合$T$で， 任意の$a, b \\in T$ ($a \\neq b$) に対して $b$ が $a$ の倍数でないものが存在するかどうか，判定せよ．\n制約: $M \\leq 3\\times 10^5$\n解法 公式解説 そのままです．\n$S$ の要素を，$M$ 個のグループ $G_1, \\ldots, G_M$ に分ける: $x \\in S$ に対して $x = 2^k y, \\quad y = 2j - 1$ と書いたときに，$x$ は $G_j$ に属することとする． $1 \\leq j \\leq M$ となることに注意．\n題意を満たす部分集合としては，各グループから要素を1つずつ選んでこなければならない． 同じグループに属する2つの数は倍数の関係にあり，グループは全部で$M$個だからである． さらに，$j \u0026lt; i$ のときに， $2^k(2j - 1) \\in G_j$ と $2^l(2i - 1) \\in G_i$ が同時にに部分集合に属することができる条件は， $2i - 1$ が $2j - 1$ の倍数でないか，$k \u0026gt; l$ となることである．\nそこで，各グループ$G_j$で，使える最小の値 $L[j]$ と最大の値 $U[j]$ を，次のように定義する．\n$$ L[j] = \\begin{cases} \\min G_j \u0026amp; 3(2j - 1) \\geq 2M \\text{の時} \\\\ \\min \\{ 2^k(2j - 1) \\in G_j \\mid k \u0026gt; k_0 \\} \u0026amp; \\text{ow} \\\\ \\end{cases} $$\n$$ U[j] = \\begin{cases} \\max G_j \u0026amp; j = 1 \\text{の時} \\\\ \\max \\{ 2^k(2j - 1) \\in G_j \\mid k \u0026lt; k_1 \\} \u0026amp; \\text{ow} \\\\ \\end{cases} $$\nここに，$k_0 := \\max \\{ L[i] \\mid j \u0026lt; i \u0026lt; M, \\quad 2i - 1 は 2j - 1 の倍数 \\}$， $k_1 := \\min \\{ U[i] \\mid 1 \\leq i \u0026lt; j, \\quad 2i - 1 は 2j - 1 の約数 \\}$．\n$2^k(2j - 1) \\in G_j$ を含む部分集合が存在する条件は，$L[j] \\leq k \\leq U[j]$ となることである．\n実装 ACコード ","permalink":"https://yamate11.github.io/blog/posts/2022/06-04-arc141-d-nondivisible-set/","summary":"解説ACです","title":"Non-divisible Set - Atcoder Regular Contest 141 D"},{"content":"Mo\u0026rsquo;s algorithm を使う問題はそんなに頻繁に出てくるわけではないので， 書こうとして，あれ，なんだっけ，となりがちです． ライブラリにするほどではないと思うので， コンテストの時に貼れるようにメモをしておきます．\n適用できる問題  $Q$個のクエリ $\\text{query}(l, r)$ を処理せよという形． ($0 \\leq l \\leq r \\leq N$) $\\text{query}(l - 1, r)$ $\\text{query}(l + 1, r)$ $\\text{query}(l, r - 1)$ $\\text{query}(l, r + 1)$ は， $\\text{query}(l, r)$ から $O(1)$ で計算できる． クエリは先読み可能である． 計算量は $O(N\\sqrt{Q})$ で，定数倍は結構大きいので， $Q$ や $N$ の大きさは，$10^5$ とか せいぜい $10^6$ とかいったところ  アルゴリズム  $[0, N]$ を $\\sqrt{Q}$ 個のブロックに (だいたい) 等分割する 次の順序でクエリをソートする: $(l, r)$ と $(l\u0026rsquo;, r\u0026rsquo;)$ との比較で:  $l$ と $l\u0026rsquo;$ が入るブロックが違う時には，左のブロックに入っている方が先 同じブロックに入る時には，$r$ と $r\u0026rsquo;$ で小さい方が先   この順序でクエリを処理する．前回の値から $l$ と $r$ を1つずつ増減させて 今回の値を求める．  計算量 ブロックの個数を $K$，ブロックのサイズを $B$ とする． $l$ の増減による計算はたいてい $B$ 以下で，ブロックをまたぐときも $2B$ 以下だから，全体で $O(BQ)$回． $r$ の増減による計算はあるブロックを処理している間の合計で $N$ 以下だから， 全体で $O(KN)回$．ここでだいたい $K = \\sqrt{Q}$, $B = N / K$ だから， 両者合わせて $O(BQ + KN)$ = $O(N\\sqrt{Q})$ である．\nコード例 $\\text{query}(l, r)$ が， 「$\\bigoplus\\{ a_i \\mid i \\in [l, r) \\}$ を求めよ」という問題だと した場合，次のようなコードで計算できる．\n // ブロックサイズ  ll B = max(1LL, llround(1.3 * N / sqrt(Q))); // 1.3 は適当に調整...   // クエリの先読み  using tup_t = tuple\u0026lt;int, int, int, int\u0026gt;; // ブロックID, r, l, クエリID  vector\u0026lt;tup_t\u0026gt; qs;  for (int query_id = 0; query_id \u0026lt; Q; query_id++) {  int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; l--; // 添字0開始，半開区間  int block_id = l / B;  qs.emplace_back(block_id, r, l, query_id);  }   // 重要: ソートを忘れない!  sort(qs.begin(), qs.end(),  // 比較関数は無くても良いが，あった方が速い．「補足」参照  [](const tup_t\u0026amp; t1, const tup_t\u0026amp; t2) -\u0026gt; bool {  auto [block_id1, r1, _a, _b] = t1;  auto [block_id2, r2, _c, _d] = t2;  if (block_id1 != block_id2) return block_id1 \u0026lt; block_id2;  if ((block_id1 \u0026amp; 1) == 0) return r1 \u0026lt; r2;  else return r1 \u0026gt; r2;  });   // メイン  vector\u0026lt;T\u0026gt; ans(Q);  state_t state = state_t(); // 現在のクエリの状態を初期化  int cl = 0, cr = 0; // 現在の l, r の値  for (auto [_not_used, r, l, query_id] : qs) {  while (l \u0026lt; cl) { // 左側が拡張  cl--;  state.add(A[cl]);  }  while (cr \u0026lt; r) { // 右側が拡張  state.add(A[cr]);  cr++;  }  while (cl \u0026lt; l) { // 左側が縮小  state.subtract(A[cl]);  cl++;  }  while (r \u0026lt; cr) { // 右側が縮小  cr--;  state.subtract(A[cr]);  }  ans[query_id] = state.value();  }   for (T a : ans) cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 答の出力 補足1 Codeforces の記事 に， Hilbert curve を使うと性能があがるという報告があります． 追試をしてみましたが，あまり速くなりませんでした． 左右端の拡張と縮小の回数を減らそうという趣旨とみましたが， もとの Mo\u0026rsquo;s algorithm のブロックサイズを適切に設定することによって， ほぼ同等の回数にすることができます． Hilbert curve order を計算する時間が馬鹿にならないので， トータルの性能としては，改善されないようです．\n補足2 姑息な定数倍高速化ですが， クエリをソートする際に， $r$ の側は左→右と右→左を交互に行うのが得策のようです． データにもよるでしょうが， 実験してみたところ，拡張・縮小回数を30%ほど削減できました (実行時間も20%ほど減りました)．\n","permalink":"https://yamate11.github.io/blog/posts/2022/03-06-mo-s-algorithm/","summary":"Mo\u0026rsquo;s algorithm のコンテスト用メモです","title":"Mo's algorithm メモ"},{"content":"Educational Codeforces Round 115 F. RBS の解法です． 解説ACです．\n問題概要 問題へのリンク 文字 ( と ) のみからなる空でない文字列全体の集合を $S$ とする． $s \\in S$ に対し，$s$ の空でない prefix であって， 括弧の対応が取れているものの数を $f(s)$ と書くことにする． 例えば $f(\\verb!\u0026quot;()()()))\u0026quot;!) = 3$, $f(\\verb!\u0026quot;(()())((\u0026quot;!) = 1$．\n$S$ の要素が $n$ 個与えられる． これらを並べ替えて連結して得られる文字列 $s$ について，$f(s)$ の 最大値を求めよ．\n制約: $ 1 \\leq n \\leq 20$，与えられる文字列の長さの和は $4\\times 10^5$ 以下． 制限時間3秒．\n解法 0-index で記述する． $\\bar{n} := \\{0, \\ldots, n-1\\}$ とする．\n$s \\in S$ に対し，現れる ( の数から ) の数を引いたものを $g(s)$ と書く． $s \\in S$ で，全ての $i \u0026lt; |s|$ に対して $g(s) \\geq 0$ であるものの集合を $L$ と書く．$D := S \\setminus L$．\n$x \\subseteq \\bar{n}$ に対し， $\\{ s_i \\mid i \\in x \\}$ を並び替えて連結して得られる文字列 の集合を $P(x)$ と書く． $P(x)$ の要素 $s$ について，$g(s)$ の値は全て等しい．この値を $b(x)$ と書く． $\\newcommand{\\live}{\\text{live}}\\newcommand{\\dead}{\\text{dead}}$\n $\\live[ x ] := \\max \\{ f(s) \\mid s \\in P(x) \\cap L \\}$ $\\dead[ x ] := \\max \\{ f(s) \\mid s \\in P(x) \\cap D \\}$  ただし，$\\max \\varnothing = -\\infty$．\nすると，求める値は $\\max( \\text{live}[\\bar{n}], \\text{dead}[\\bar{n}] )$ である．\nこれをDPで求める．初期化:\n $\\live[ \\varnothing ] = 0$ $\\dead[ \\varnothing ] = -\\infty$  遷移は次のようになる．\n $\\text{updMax}(\\dead[ x \\cup \\{k\\} ], \\dead[ x ])$ $b(x) + g(s_k) \u0026lt; 0$ のとき， $\\text{updMax}(\\dead[x \\cup \\{k\\} ], \\live[ x ] + h(s_k, b(x)))$ $b(x) + g(s_k) \\geq 0$ のとき， $\\text{updMax}(\\live[x \\cup \\{k\\} ], \\live[ x ] + h(s_k, b(x)))$  ここで，$h(s, b)$ は，$s$ において $g(i) = -b$ かつ すべての $j \u0026lt; i$ に対して $g(j) \\geq -b$ であるような $i$ の数であり， これらは前計算で求めておくことができる．\n計算量は $O(n2^n)$\n実装 ACコード ","permalink":"https://yamate11.github.io/blog/posts/2022/05-19-ecf-115-f-rbs/","summary":"Educational Codeforces Round 115 F. RBS の解法です． 解説ACです．\n問題概要 問題へのリンク 文字 ( と ) のみからなる空でない文字列全体の集合を $S$ とする． $s \\in S$ に対し，$s$ の空でない prefix であって， 括弧の対応が取れているものの数を $f(s)$ と書くことにする． 例えば $f(\\verb!\u0026quot;()()()))\u0026quot;!) = 3$, $f(\\verb!\u0026quot;(()())((\u0026quot;!) = 1$．\n$S$ の要素が $n$ 個与えられる． これらを並べ替えて連結して得られる文字列 $s$ について，$f(s)$ の 最大値を求めよ．\n制約: $ 1 \\leq n \\leq 20$，与えられる文字列の長さの和は $4\\times 10^5$ 以下． 制限時間3秒．\n解法 0-index で記述する． $\\bar{n} := \\{0, \\ldots, n-1\\}$ とする．\n$s \\in S$ に対し，現れる ( の数から ) の数を引いたものを $g(s)$ と書く． $s \\in S$ で，全ての $i \u0026lt; |s|$ に対して $g(s) \\geq 0$ であるものの集合を $L$ と書く．$D := S \\setminus L$．","title":"RBS - Educational Codeforces Round 115 F"},{"content":"Atcoder Regular Contest 138 (大和証券プログラミングコンテスト 2022 Spring) - ARC 138 D - Differ by K bits の解法です． 公式解説 を読んで，きれいに解けるのにびっくりしてしまいました． ここに書くのはもっと泥臭いです．\n問題概要 整数 $N$, $K$ が与えられる． $0, 1, \\ldots, 2^N - 1$ の順列 $P_0, P_1, \\ldots, P_{2^N - 1}$ で， 隣接項が 2進表記でちょうど$K$桁だけ異なるものが存在するかどうか判定し， 存在する場合には1つ構成せよ．\n制約: $1 \\leq K \\leq N \\leq 18$\n問題へのリンク 解法 $N = 1$ の場合には，$K = 1$ であり，$P_i = i$ という解がある． 以下，$N \\geq 2$ とする．\n$K = N$ の場合は，あきらかに解はない． また，$K$ が偶数の場合には，ビットカウントが奇数になる数が作れないので， 解はない． $K \u0026lt; N$ かつ $K$ が奇数の場合には， $n = K + 1, K + 2, \\ldots, N$ の順に解を構成することができる．\nまず，$n = K + 1$ とする． グレイコード を1つおきに反転すれば良い．具体的には， $Q_i := i \\oplus \\textrm{sftR}(i)$ とすると，$(Q_i)_i$ は順列になり，隣接項は2進表記で1桁だけ異なる． ただし，$\\oplus$ は XOR で，sftR は右ビットシフト． したがって，\n$$ P_i := \\begin{cases} Q_i \u0026amp; \\text{ $i$ が偶数の時}\\\\ \\textrm{flip}(Q_i) \u0026amp; \\text{ $i$ が奇数の時} \\end{cases} $$\nが解となる．ただし，flip は，末尾nビットのビット反転．\nあとは，$n$ を1つずつ増やしていく．\n 順列の前半 ($i \u0026lt; 2^n$) は，1つ前の数列をそのまま用いる． 後半の先頭 ($i = 2^n$) は， 前半の最後の数の $K-1$ ビットを反転させた上で， 最上位ビットを立てる． 後半の残りは，前半の対応する場所と同じビットを反転する．  具体的には，$(Q_i)_i$ を $n$ に対する解であるとして， $n + 1$ に対する解 $(P_i)_i$ は次のようになる．\n$$ P_i := \\begin{cases} Q_i \u0026amp; (i \u0026lt; 2^n) \\\\ Q_{2^n - 1} \\oplus (2^{K - 1} - 1) \\oplus 2^n \u0026amp; (i = 2^n) \\\\ Q_{i - 1} \\oplus (Q_{i - 2^n - 1} \\oplus Q_{i - 2^n}) \u0026amp; (i \u0026gt; 2^n) \\end{cases} $$\n実装  ll N, K; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; K;  if (N == 1) { cout \u0026lt;\u0026lt; \u0026#34;Yes\\n0 1\\n\u0026#34;; return 0; }  if (K == N or K % 2 == 0) { cout \u0026lt;\u0026lt; \u0026#34;No\\n\u0026#34;; return 0; }  vector\u0026lt;ll\u0026gt; ans(1LL \u0026lt;\u0026lt; N);  ll n = K + 1;  ll mask = (1LL \u0026lt;\u0026lt; n) - 1;  REP(i, 1LL \u0026lt;\u0026lt; n) {  ll x = i ^ (i \u0026gt;\u0026gt; 1);  ans[i] = i % 2 == 0 ? x : (x ^ mask);  }  for (; n \u0026lt; N; n++) {  ll j0 = 1LL \u0026lt;\u0026lt; n;  ans[j0] = ans[j0 - 1] ^ ((1LL \u0026lt;\u0026lt; (K - 1)) - 1) ^ j0;  REP(i, j0 - 1) ans[j0 + i + 1] = ans[j0 + i] ^ ans[i] ^ ans[i + 1];  }  cout \u0026lt;\u0026lt; \u0026#34;Yes\\n\u0026#34;;  for (ll a : ans) cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34;;  cout \u0026lt;\u0026lt; endl; ACコード ","permalink":"https://yamate11.github.io/blog/posts/2022/04-14-arc138-d-differ-by-k-bits/","summary":"公式解説とは少しだけ異なる解法です","title":"Differ by K bits - Atcoder Regular Contest 138 D"},{"content":"Atcoder Beginner Contest 077 - ABC 077 D - Small Multiple の解法です． 公式解説 の通りですが， 少し丁寧に書きました．\n問題概要 2以上の整数 $K$ が与えられる． $K$ の倍数である正の整数について， 十進表記の各桁の和としてありうる最小の値を求めよ．\n制約: $K \\leq 10^5$\n問題へのリンク 解法 整数 $t$ の十進表記を $t = \\sum_{i=0}^{m} d_i 10^i$ としたとき， 各桁の和を $f(t) = \\sum_{i=0}^{m} d_i$ で表す．次が成り立つのは明らか．\n $f(t + 1) \\leq f(t) + 1$ $d_0 \\not= 9$ のとき，$f(t + 1) = f(t) + 1$ $f(10t) = f(t)$  補題1  非負整数列 $a_0, a_1, \\ldots$ が次を満たすとする:\n $a_0 = 0$ 各 $i$ について， $a_{i + 1} = a_i + 1$ または $a_{i + 1} = 10 a_i$  非負整数列 $b_0, b_1, \\ldots$ を，次で定義する:\n $b_0 = 0$ $a_{i + 1} = a_i + 1$ のとき，$b_{i + 1} = b_i + 1$ $a_{i + 1} = 10 a_i$ のとき，$b_{i + 1} = b_i$  このとき，$f(a_i) \\leq b_i$ である．\n 証明 簡単な帰納法．(終)\n補題2  正の整数 $t$ に対し，整数列 $a_0, a_1, \u0026hellip;, a_m$ で，次を満たすものが取れる:\n $m \u0026gt; 0$ $a_0 = 0$ 各 $i$ について， $a_{i + 1} = a_i + 1$ または $a_{i + 1} = 10 a_i$ $a_m = t$ 補題1で定義する列 $b_0, b_1, \\ldots, b_m$ について，$f(a_m) = b_m$   証明 $t = 10s$ のときには，$s$ に対する列の後ろに $t$ を追加すれば良い． $t = 10s + k\\quad(1 \\leq k \\leq 9)$ のときには，$t - 1$ に対する 列の後ろに $t$ を追加すれば良い．(終)\nノードが $0, 1, \\ldots, K-1$ からなる重み付き有向グラフを考える: $\\newcommand{\\foo}{\\;(\\textrm{mod}~K)}$\n $x$ から $x + 1 \\foo$ に，重み 1 の辺がある． $x$ から $10x \\foo$ に，重み 0 の辺がある．  補題1の条件を満たす整数列 $a_0, a_1, \\ldots, a_m$ と $b_0, b_1, \\ldots, b_m$ に対して， $a_0\\foo, a_1\\foo, \\ldots, a_m\\foo$ は，このグラフのパスになり， その重みは $b_m$ である． したがって，補題1, 2 より，ノード 0 から ノード 0 に至る長さ 2 以上の パスのうち最も短いものの重みが求める答となる．\n0-1 BFS により，計算量 $O(K)$ で求められる．\nACコード #include \u0026lt;bits/stdc++.h\u0026gt;#include \u0026lt;cassert\u0026gt;typedef long long int ll; using namespace std; #define REP2(i, a, b) for (ll i = (a); i \u0026lt; (b); i++) #define REP2R(i, a, b) for (ll i = (a); i \u0026gt;= (b); i--) #define REP(i, b) REP2(i, 0, b) #define ALL(coll) (coll).begin(), (coll).end() #define SIZE(v) ((ll)((v).size()))  int main() {  ios_base::sync_with_stdio(false);  cin.tie(nullptr);  cout \u0026lt;\u0026lt; setprecision(20);   ll K; cin \u0026gt;\u0026gt; K;  using sta = pair\u0026lt;ll, ll\u0026gt;;  deque\u0026lt;sta\u0026gt; deq;  const ll big = 1e10;  vector\u0026lt;ll\u0026gt; dist(K, big);  dist[1] = 1;  deq.emplace_back(1, 1);  while (not deq.empty()) {  auto [d, n] = deq.front(); deq.pop_front();  if (dist[n] \u0026lt; d) continue;  if (n == 0) {  cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl;  return 0;  }  ll y = (n + 1) % K;  if (d + 1 \u0026lt; dist[y]) {  dist[y] = d + 1;  deq.emplace_back(d + 1, y);  }  y = (10 * n) % K;  if (d \u0026lt; dist[y]) {  dist[y] = d;  deq.emplace_front(d, y);  }  }   return 0; } ","permalink":"https://yamate11.github.io/blog/posts/2022/04-05-abc-077-d-small-multiple/","summary":"公式解説の行間を埋めました．","title":"Small Multiple - Atcoder Beginner Contest 077 D"},{"content":"筆者 筆者 (yamate11) の競プロ用のブログです．\n2018年頃から AtCoder に参加しています． IDは yamate11． 2022年3月現在ではレーティングは1800台． 青に3年間くらい居続けていて，なかなか黄色になれません． 精進が足りないということはわかっていますけれども\u0026hellip;． 現状はこちら ．\nCodeForces にも ID yamate11 で参加していますが，こちらはあまりアクティブではありません． 2022年3月現在は Expert(青) です．\nTwitter は， _yamate11 です．\nPowered by Hugo and PaperMod\n","permalink":"https://yamate11.github.io/blog/pages/about/","summary":"筆者 筆者 (yamate11) の競プロ用のブログです．\n2018年頃から AtCoder に参加しています． IDは yamate11． 2022年3月現在ではレーティングは1800台． 青に3年間くらい居続けていて，なかなか黄色になれません． 精進が足りないということはわかっていますけれども\u0026hellip;． 現状はこちら ．\nCodeForces にも ID yamate11 で参加していますが，こちらはあまりアクティブではありません． 2022年3月現在は Expert(青) です．\nTwitter は， _yamate11 です．\nPowered by Hugo and PaperMod","title":"このサイトについて"},{"content":"(高速)ゼータ変換，(高速)メビウス変換については， 良い記事がたくさんありますので，1つ足してもしょうがないのですが， 自分用にまとめました．\nゼータ変換，メビウス変換 $F$ を有限集合とする．その冪集合を $\\mathcal{P}(F)$ と書く． $x \\in \\mathbb{N}$ に対して $\\bar{x} := \\{0, 1, \\ldots, x-1\\}$ と書く．\n$M$ を加群として， 関数 $f: \\mathcal{P}(F) \\to M$ に対して，そのゼータ変換 $\\zeta(f): \\mathcal{P}(F) \\to M$ を，\n\\begin{equation} \\zeta(f)(X) = \\sum \\{ f(Y) \\mid Y \\subseteq X\\} \\end{equation}\nで定義する．あるいは，\n\\begin{equation} \\zeta(f)(X) = \\sum \\{ f(Y) \\mid Y \\supseteq X\\} \\end{equation}\nで定義することもある． $f$ のメビウス変換 $\\mu(f): \\mathcal{P}(F) \\to M$ を，ゼータ変換の定義が(1)のときには，\n\\begin{equation} \\mu(f)(X) = \\sum\\{ (-1)^{|X \\setminus Y|}f(Y) \\mid Y \\subseteq X \\} \\end{equation}\nで，(2)のときには\n\\begin{equation} \\mu(f)(X) = \\sum\\{ (-1)^{|X \\setminus Y|}f(Y) \\mid Y \\supseteq X \\} \\end{equation}\nで定義する．\n定理1  $\\zeta$ と $\\mu$ は互いに他の逆変換である．\n 系2 (包除原理)  各 $i = 0, \\ldots, n-1$ に対して $A_i \\subseteq U$ が定められている時， $$ \\left|\\bigcup_{i \\in \\overline{n}} A_i\\right| = \\sum \\left\\{ (-1)^{|X| + 1} \\left|\\bigcap_{i \\in X} A_i\\right| \\mid X \\in \\mathcal{P}(\\bar{n}) \\setminus \\{ \\emptyset \\} \\right\\} $$\n 系2の証明 (2),(4)の定義を用いる．\n$X \\subseteq \\bar{n}$ に対し， $f(X) := |\\bigcap_{i \\in X} A_i \\cap \\bigcap_{i \\not\\in X} (U \\setminus A_i)|$ とすれば，$|\\bigcap_{i \\in X} A_i| = \\zeta(f)(X)$ となる． 特に $|U| = \\zeta(f)(\\emptyset) $ である．\n$|U| - \\text{(左辺)} % = |\\bigcup_{i \\in \\overline{n}} A_i| = |\\bigcap_{i \\in \\overline{n}} (U \\setminus A_i)| = f(\\emptyset) $\n$|U| - \\text{(右辺)} = \\sum \\{ (-1)^{|X|} |\\bigcap_{i \\in X} A_i| \\mid X \\in \\mathcal{P}(\\bar{n}) \\} = \\sum \\{ (-1)^{|X|} \\zeta(f)(X) \\mid X \\in \\mathcal{P}(\\bar{n}) \\} $ $= \\mu(\\zeta(f))(\\emptyset) = f(\\emptyset) $\n(終)\n定理1の証明 以下，この節では(1)と(3)を採用する．(2)と(4)の場合も同様にできる．\n簡単のため $F = \\bar{n}$ の場合で考える．\n$X, Y \\subseteq \\bar{n}$ に対して， $Y\\subseteq^i X$ を，以下の2条件が成り立つこととして定義する:\n $Y \\cap \\bar{i} \\subseteq X \\cap \\bar{i}$ $Y \\cap (\\bar{n} \\setminus \\bar{i}) = X \\cap (\\bar{n} \\setminus \\bar{i}) $  補題1は定義から従う．\n補題1  \\begin{align*} Y \\subseteq^0 X \u0026amp;\\iff Y = X \\\\ Y \\subseteq^n X \u0026amp;\\iff Y \\subseteq X \\\\ Y \\subseteq^{i+1} X \u0026amp;\\iff \\begin{cases} Y \\subseteq^{i} X \u0026amp; \\text{ if } i \\not\\in X \\\\ Y \\subseteq^{i} X \\text{ or } Y \\subseteq^{i} X \\setminus \\{i\\} \u0026amp; \\text{ if } i \\in X \\\\ \\end{cases} \\end{align*}\n 次のように定義する:\n\\begin{align*} \\zeta^i(f)(X) \u0026amp;= \\sum \\{f(Y) \\mid Y \\subseteq^i X\\} \\\\ \\mu^i(f)(X) \u0026amp;= \\sum \\{(-1)^{|X \\setminus Y|}f(Y) \\mid Y \\subseteq^i X\\} \\\\ \\end{align*}\n補題2は，定義から従う．\n補題2  \\begin{align*} \\zeta^0(f)(X) \u0026amp;= f(X) \\\\ \\mu^0(f)(X) \u0026amp;= f(X) \\\\ \\zeta^n(f)(X) \u0026amp;= \\zeta(f)(X) \\\\ \\mu^n(f)(X) \u0026amp;= \\mu(f)(X) \\\\ \\zeta^{i+1}(f)(X) \u0026amp;= \\begin{cases} \\zeta^{i}(f)(X) \u0026amp; \\text{ if } i \\not\\in X \\\\ \\zeta^{i}(f)(X) + \\zeta^{i}(f)(X \\setminus \\{i\\}) \u0026amp; \\text{ if } i \\in X \\\\ \\end{cases}\\\\ \\mu^{i+1}(f)(X) \u0026amp;= \\begin{cases} \\mu^{i}(f)(X) \u0026amp; \\text{ if } i \\not\\in X \\\\ \\mu^{i}(f)(X) - \\mu^{i}(f)(X \\setminus \\{i\\}) \u0026amp; \\text{ if } i \\in X \\\\ \\end{cases} \\end{align*}\n 補題3  \\begin{align*} \\zeta^{i + 1}(\\mu^{i + 1}(f))(X) \u0026amp;= \\zeta^{i}(\\mu^{i}(f))(X) \\\\ \\mu^{i + 1}(\\zeta^{i + 1}(f))(X) \u0026amp;= \\mu^{i}(\\zeta^{i}(f))(X) \\\\ \\end{align*}\n 証明 上のみ示す．下も同様．\n$i \\not\\in X$ のときは，補題1,2より\n\\begin{align*} \\zeta^{i + 1}(\\mu^{i + 1}(f))(X) = \\sum\\{\\mu^{i}(f)(Y) \\mid Y \\subseteq^{i} X \\} = \\zeta^{i}(\\mu^{i}(f))(X) \\end{align*}\n$i \\in X$ のときは，補題1より\n\\begin{align*} \\zeta^{i + 1}(\\mu^{i + 1}(f))(X) \u0026amp; = \\sum\\{\\mu^{i+1}(f)(Y) \\mid Y \\subseteq^{i+1} X \\} \\\\ \u0026amp; = \\sum\\{\\mu^{i+1}(f)(Y) \\mid i \\in Y \\subseteq^{i+1} X \\} + \\sum \\{\\mu^{i+1}(f)(Y) \\mid i \\not\\in Y \\subseteq^{i+1} X \\} \\\\ \\end{align*}\nとなり，ここで補題2より\n\\begin{align*} \\text{第1項} \u0026amp; = \\sum\\{\\mu^{i+1}(f)(Y) \\mid Y \\subseteq^{i} X \\} \\\\ \u0026amp; = \\sum\\{\\mu^{i}(f)(Y) - \\mu^{i}(f)(Y \\setminus \\{i\\}) \\mid Y \\subseteq^{i} X\\} \\\\ \\end{align*}\n\\begin{align*} \\text{第2項} \u0026amp; = \\sum\\{\\mu^{i+1}(f)(Y) \\mid Y \\subseteq^{i} X \\setminus \\{i\\} \\} \\\\ \u0026amp; = \\sum\\{\\mu^{i}(f)(Y) \\mid Y \\subseteq^{i} X \\setminus \\{i\\} \\} \\\\ \u0026amp; = \\sum\\{\\mu^{i}(f)(Y \\setminus \\{i\\} ) \\mid Y \\subseteq^{i} X \\} \\\\ \\end{align*}\nであるから，\n$$ \\zeta^{i + 1}(\\mu^{i + 1}(f))(X) = \\sum\\{\\mu^{i}(f)(Y) \\mid Y \\subseteq^{i} X \\} = \\zeta^{i}(\\mu^{i}(f))(X) $$\n(終)\n定理1は，補題2, 3 より数学的帰納法で証明された．\n高速ゼータ変換，高速メビウス変換 補題2を用いてゼータ変換，メビウス変換の各点の値を計算することができる． 計算量は，各 $i = 0, \\ldots, n$ に対して $X \\subseteq \\bar{n}$ での 値を計算するので，$O(n 2^n)$ である．\nなお，定義が(2),(4)の場合の補題2の漸化式を明記すればは次のとおり．\n\\begin{align*} \\zeta^{i+1}(f)(X) \u0026amp;= \\begin{cases} \\zeta^{i}(f)(X) \u0026amp; \\text{ if } i \\in X \\\\ \\zeta^{i}(f)(X) + \\zeta^{i}(f)(X \\cup \\{i\\}) \u0026amp; \\text{ if } i \\not\\in X \\\\ \\end{cases}\\\\ \\mu^{i+1}(f)(X) \u0026amp;= \\begin{cases} \\mu^{i}(f)(X) \u0026amp; \\text{ if } i \\in X \\\\ \\mu^{i}(f)(X) - \\mu^{i}(f)(X \\cup \\{i\\}) \u0026amp; \\text{ if } i \\not\\in X \\\\ \\end{cases} \\end{align*}\n実装 template\u0026lt;typename T, int p1, int p2, int p3, int p4, int div\u0026gt; void _trans_form(vector\u0026lt;T\u0026gt;\u0026amp; f) {  int n = f.size();  for (int i = 1; i \u0026lt; n; i *= 2) {  for (int j = 0; j \u0026lt; n; j++) {  if ((j \u0026amp; i) == 0) {  T x = f[j];  T y = f[j | i];  f[j ] = (p1 * x + p2 * y) / div;  f[j | i] = (p3 * x + p4 * y) / div;  }  }  } }  template \u0026lt;typename T\u0026gt; void hadamard(vector\u0026lt;T\u0026gt;\u0026amp; f) { _trans_form\u0026lt;T, 1, 1, 1, -1, 1\u0026gt;(f); }  template \u0026lt;typename T\u0026gt; void inv_hadamard(vector\u0026lt;T\u0026gt;\u0026amp; f) { _trans_form\u0026lt;T, 1, 1, 1, -1, 2\u0026gt;(f); }  template\u0026lt;typename T\u0026gt; void zeta_upper(vector\u0026lt;T\u0026gt;\u0026amp; f) { _trans_form\u0026lt;T, 1, 1, 0, 1, 1\u0026gt;(f); }  template\u0026lt;typename T\u0026gt; void moebius_upper(vector\u0026lt;T\u0026gt;\u0026amp; f) { _trans_form\u0026lt;T, 1, -1, 0, 1, 1\u0026gt;(f); }  template\u0026lt;typename T\u0026gt; void zeta_lower(vector\u0026lt;T\u0026gt;\u0026amp; f) { _trans_form\u0026lt;T, 1, 0, 1, 1, 1\u0026gt;(f); }  template\u0026lt;typename T\u0026gt; void moebius_lower(vector\u0026lt;T\u0026gt;\u0026amp; f) { _trans_form\u0026lt;T, 1, 0, -1, 1, 1\u0026gt;(f); } (1), (3) が zeta_lower と moebius_lower で， (2), (4) が zeta_upper と moebius_upper． im-place で計算が行われる． Hadamard変換がおまけでついている．\n今後の課題 たぶん，約数に関する話もまとめる必要があるだろう． 今は，まとめられるほど理解していない．\n","permalink":"https://yamate11.github.io/blog/posts/2022/03-22-fast-zeta/","summary":"高速ゼータ変換について，自分用にまとめた記事です．","title":"ゼータ変換，メビウス変換，高速ゼータ変換, 高速メビウス変換"},{"content":"AtCoder Regular Contest 137 D - Prefix XORs の解法です． コンテスト中に解いた方法 (実験結果から適当に求める) をベースに， 公式解説を参照して追加しました． リュカの定理の証明もWikipediaを見て書きました．\n問題概要 長さ$N$の整数列 $A = (A_1, \\ldots, A_N)$ と整数 $M$ が与えられる． 下の操作を$k$回行ったあとの $A_i$ の値を $A(i, k)$ と書くことにする． $k = 1, 2, \\ldots, M$ について，$A(N, k)$ を求めよ．\n操作: 各$i = 1, 2, \\ldots, N$ について， $A_i$ を同時に $A_1 \\oplus A_2 \\oplus \\cdots \\oplus A_i$ で置き換える．\n制約: $1 \\leq N, M \\leq 10^6$; $0 \\leq A_i \u0026lt; 2^{30}$\n問題へのリンク 解法 実験 $A(i, k)$ は，$A_1, \\ldots, A_i$ のいくつかのXORをとったものになる． そこで，$a(i, m, k) \\in \\{0, 1\\}$ をとって， $A(i, k) = \\bigoplus_{m=1}^{i} a(i,m,k) A_m$ と書く． 計算してみると分かるとおり，$a(i, m, k)$ は，$i - m$ と $k$ にしか 依存しない．そこで，$b(j, k) := a(j, 0, k)$ と書くことにする． $A(i, k) = \\bigoplus_{m=1}^{i} b(i - m, k) A_m = \\bigoplus \\{ A_{i - j} \\mid b(j, k) = 1; j = 0, \\ldots, i-1 \\}$ だから， 各 $k = 1, 2, \\ldots, M$ について，$b(j, k) = 1$ となる $j$ を (高速に) 列挙できれば良い．\n計算してみると，$b(j, k)$ は次のようになっている:\n 0 11111111111111111111111111111111  1 10101010101010101010101010101010  10 11001100110011001100110011001100  11 10001000100010001000100010001000  100 11110000111100001111000011110000  101 10100000101000001010000010100000  110 11000000110000001100000011000000  111 10000000100000001000000010000000 1000 11111111000000001111111100000000 1001 10101010000000001010101000000000 1010 11001100000000001100110000000000 1011 10001000000000001000100000000000 1100 11110000000000001111000000000000 左端は，k - 1 の値の2進表示．スペースの直後が j = 0 の値, その次が j = 1 の値，その次が j = 2 の値，\u0026hellip; である．\nたとえば，$k - 1 = 6 = 110_2$ のとき，$b(k, j) = 1$ となる$j$ は， $0, 1, 8, 9, 16, 17, 24, 25, \\ldots$ であり，2進表記では次のようになる:\n00000 00001 01000 01001 10000 10001 11000 11001 (下から) 2ビット目と3ビット目は 0 であり，他の ビットは任意に取れる．0 に固定されているビットは，$k - 1 = 110_2$ の 立っているビットである． 他の$k$についても，すべてそのような関係が成立している．つまり， $\\newcommand{\\band}{\\;\\\u0026amp;\\;} b(j, k) = 1 \\iff j \\band (k-1) = 0$ である (\u0026amp;は，ビットごとの AND)．\n証明 帰納法でも証明できるような気がするが， 公式解説 に従って リュカの定理を使う．\nリュカの定理  $p$ を素数，$m$, $n$ を非負整数とする． $m$ と $n$ を $p$進法で表記して $m = m_k p^k + m_{k-1} p^{k-1} + \\cdots + m_1 p + m_0$， $n = n_k p^k + n_{k-1} p^{k-1} + \\cdots + n_1 p + n_0$ とするとき， $$ \\binom{m}{n} \\equiv \\prod_{i=0}^{k} \\binom{m_i}{n_i} \\qquad (\\text{mod } p)$$ である．ただし，$x \u0026lt; y$ のとき，$\\binom{x}{y} = 0$ とする．\n リュカの定理の証明 (Wikipedia) $|M| = m$ なる集合 $M$ をとり，このサイズ $n$ の部分集合の数を mod p で求めれば良い． $M$ を，$m_k$ 個の サイズ $p^k$ の部分集合，\u0026hellip;，$m_0$ 個のサイズ1の部分集合 に分割する．分割した各部分を円環状に並べておく． 置換 $\\pi: M \\to M$ を，$\\pi(x)$ を，自分が属する円環の右隣の要素， として定義する． $N \\subseteq M$, $|N| = n$ となる $N$ を考える． サイズ $p^i$ の円環で，$N$ の要素と $M\\setminus N$ の要素の両方を含むものが あったとする．そのような最大の $i$ をとると，\n $N, \\pi(N), \\pi^2(N), \\ldots, \\pi^{p^i - 1}(N)$ は全て異なる． これらのうち一つを $N\u0026rsquo;$ とすると， $\\{N, \\pi(N), \\ldots, \\pi^{p^i - 1}(N)\\}$ と $\\{N\u0026rsquo;, \\pi(N\u0026rsquo;), \\ldots, \\pi^{p^i - 1}(N\u0026rsquo;)\\}$ は，集合として一致する．  したがって，そのような $N$ の個数は $p$ の倍数である． ゆえに，$\\binom{m}{n}$ は， いくつかの円環の和で表せるようなサイズ$n$の部分集合の個数と mod p で等しい． サイズが $n$ になるように選ぶためには， サイズ$p^k$ の円環を $n_k$ 個，$\\ldots$，サイズ1の円環を$n_0$個， それぞれ選ぶ必要がある． (終)\n$b(j, k) = 1 \\iff j \\band (k - 1) = 0$ の証明 $b$ の計算方法を見れば， $b(j, k) \\equiv \\binom{j + k - 1}{j}\\quad(\\text{mod} 2)$ であることが分かる． したがって，リュカの定理によって，$b(j, k) = 0$ となるための条件は， $j$ の2進表記が 1 で，$j + k-1$ の2進表記が 0 となるような桁が存在する ことであり，これは，$j$と $k-1$ の2進表記がともに1となる桁が存在することと 同値である． (終)\n計算方法 高速ゼータ変換 の要領で計算する．具体的には以下の通り:\n$M$ のビット長を $L$ とする．$k \\in\\{ 1, 2, \\ldots, M\\}$ であった． $t \\in \\{0, 1, \\ldots, L\\}$ とし， $j \\in \\{0, 1, \\ldots, N-1 \\}$に対し， $j \\sim^t k$ を，次の条件が成り立つこととして定義する:\n 第0ビットから第$t - 1$ ビットまでは，$j$ と $k-1$ の両方が1になることはない． 第$t$ビットから第$L-1$ビットまでは，$j$ と $k-1$ は一致する．  $f(t, k)$ を，$\\oplus \\{ A_{N - j} \\mid j \\sim^{t} k;\\; j = 0, \\ldots, 2^L - 1\\}$ で定義する．定義より， $f(L, k)$ が求める $A(N, k)$ である．\nこれは，次のように計算できる．\n $f(0, k) = \\oplus \\{ A_{N - j} \\mid j \\band (2^L - 1) = k - 1 \\}$ $k \\band 2^t \\neq 0$ のとき: $f(t + 1, k) = f(t, k \\band (\\sim 2^t))$ $k \\band 2^t = 0$ のとき: $f(t + 1, k) = f(t, k) \\oplus f(t, k \\;|\\; 2^t)$  実装 主要部分:\nint main() {   ll N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M;  vector\u0026lt;ll\u0026gt; A(N);  REP(i, N) cin \u0026gt;\u0026gt; A[i];  ll L = 64 - __builtin_clzll(M);  vector\u0026lt;ll\u0026gt; vec(1LL \u0026lt;\u0026lt; L);  REP(j, N) vec[j \u0026amp; ((1LL \u0026lt;\u0026lt; L) - 1)] ^= A[N-1 - j];  REP(t, L) {  REP(k, 1LL \u0026lt;\u0026lt; L) {  if (k \u0026gt;\u0026gt; t \u0026amp; 1) continue;  ll k0 = k;  ll k1 = k | (1LL \u0026lt;\u0026lt; t);  ll v0 = vec[k0];  ll v1 = vec[k1];  vec[k0] = v0 ^ v1;  vec[k1] = v0;  }  }  REP(k, M) cout \u0026lt;\u0026lt; vec[k] \u0026lt;\u0026lt; \u0026#34; \u0026#34;;  cout \u0026lt;\u0026lt; endl;  return 0; } 全体: 提出 #30396276 ","permalink":"https://yamate11.github.io/blog/posts/2022/03-20-arc137-d-prefix-xors/","summary":"AtCoder Regular Contest 137 D - Prefix XORs の解法です． コンテスト中に解いた方法 (実験結果から適当に求める) をベースに， 公式解説を参照して追加しました． リュカの定理の証明もWikipediaを見て書きました．\n問題概要 長さ$N$の整数列 $A = (A_1, \\ldots, A_N)$ と整数 $M$ が与えられる． 下の操作を$k$回行ったあとの $A_i$ の値を $A(i, k)$ と書くことにする． $k = 1, 2, \\ldots, M$ について，$A(N, k)$ を求めよ．\n操作: 各$i = 1, 2, \\ldots, N$ について， $A_i$ を同時に $A_1 \\oplus A_2 \\oplus \\cdots \\oplus A_i$ で置き換える．\n制約: $1 \\leq N, M \\leq 10^6$; $0 \\leq A_i \u0026lt; 2^{30}$\n問題へのリンク 解法 実験 $A(i, k)$ は，$A_1, \\ldots, A_i$ のいくつかのXORをとったものになる． そこで，$a(i, m, k) \\in \\{0, 1\\}$ をとって， $A(i, k) = \\bigoplus_{m=1}^{i} a(i,m,k) A_m$ と書く． 計算してみると分かるとおり，$a(i, m, k)$ は，$i - m$ と $k$ にしか 依存しない．そこで，$b(j, k) := a(j, 0, k)$ と書くことにする． $A(i, k) = \\bigoplus_{m=1}^{i} b(i - m, k) A_m = \\bigoplus \\{ A_{i - j} \\mid b(j, k) = 1; j = 0, \\ldots, i-1 \\}$ だから， 各 $k = 1, 2, \\ldots, M$ について，$b(j, k) = 1$ となる $j$ を (高速に) 列挙できれば良い．","title":"Prefix XORs - AtCoder Regular Contest 137 D"},{"content":"Codeforces Round 717 (Div.2) E - Baby Ehab Plays with Permutations の解法です． 公式解説 と同じ，というか その一部分です．\n以下，次のように書きます．\n $1..n$ の順列を $S(n)$ と書く．自然に $S(n) \\subseteq S(n + 1)$ とみなす． $S(n)$ の要素であって，ちょうど $j$ 個の互換の積で表せるものの 集合を，$X(n, j)$ と書く． $F(n, j) := |X(n, j)|$  問題概要 整数$n$, $k$ が与えられる． $j = 1, \\ldots, k$ について，$F(n, j)$ を mod $10^9 + 7$ で求めよ．\n制約: $2 \\leq n \\leq 10^9$, $1 \\leq k \\leq 200$\n問題へのリンク 解法 次のように定義する．\n 順列 $p$ に対し，その互換の積の表記に現れる互換の数の最小値を $s(p)$ と書く． $Y(n, j) := \\{p \\in S(n) \\mid s(p) = j \\}$ $G(n, j) := |Y(n, j)|$  すると，次が成り立つ．\n$$F(n, j) = G(n, j) + G(n, j - 2) + \\cdots + G(n, j \\% 2)$$\n$s$ の計算を考えるために， $p \\in S(n) \\setminus \\{id\\}$ のとき，$p(i) \\neq i$ となる $i$ の 最大値を $i_0$ として，$p\u0026rsquo; := p\\cdot (i_0, p(i_0))$ とすると，\n $s(id) = 0$ $p(j) \\neq j$ となる $j$ の最大のものを $j_0$ として， $q := p\\cdot(j_0, p(j_0))$ とすれば，$s(p) := s(q) + 1$  である．これを踏まえると，$p \\in Y(n, j)$ とすると，\n $p(n) = n$ の場合は，$p \\in Y(n - 1, j)$ $p(n) \u0026lt; n$ の場合は，$p\u0026rsquo; \\in Y(n - 1, j - 1)$  となることがわかるから，$G$ は次のように計算できる:\n\\begin{align*} G(n, 0) \u0026amp;= 1 \\\\ G(n, j) \u0026amp;= 0\\quad (n \u0026lt; j) \\\\ G(n, j) \u0026amp;= G(n - 1, j) + (n - 1) G(n - 1, j - 1) \\end{align*}\nこれで答は求められるが，この計算方法では $\\Omega(nk + k^2)$ なので間に合わない． そこで，$j$ が小さい時，$p \\in Y(n, j)$ に対して，$p$ が動かす数は たかだか $2j$ 個しかないことに着目する．\n\\begin{align*} Z(n, j) \u0026amp;:= \\{p \\in Y(n, j) \\mid \\text{ すべての } i = 1, \\ldots, n \\text{ に対して } p(i) \\neq i \\} \\\\ H(n, j) \u0026amp;:= |Z(n, j)| \\end{align*}\nとすれば，\n$$G(n, j) = \\sum_{i = 0}^{2j} \\binom{n}{i}H(i, j)$$\nである．$H$ は，包除原理で求められる:\n$$H(i, j) = \\sum_{r = 0}^{i} (-1)^r \\binom{i}{r} G(i - r, j)$$\n全体として $O(k^3)$ で計算できた．\n実装 ACコード ","permalink":"https://yamate11.github.io/blog/posts/2022/03-05-cf-717-2-e/","summary":"解説ACです．","title":"Baby Ehab Plays with Permutations - Codeforces Round 717 (Div.2) E"},{"content":"AtCoder Beginner Contest 231 - ABC 231 G - Balls in Boxes の解法です． 公式解説と同じです．\n問題概要 問題へのリンク $N$個の箱があり，箱$i$ には $A_i$ 個のボールが入っている． 「箱を1つ選んでボールを1個入れる」ことを$K$回繰り返す． 操作後の各箱のボールの数を $B_i$ として， $\\prod_{i=1}^{N}B_i$ の期待値を mod 998244353 で求めよ．\n解法1 公式解説1 による．\n例として $N=3$ とする．\n確率変数 $X_i$ を，「箱$i$が選ばれた回数」を表すものとする． 求める期待値は， $E( (A_1 + X_1)(A_2 + X_2)(A_3 + X_3) )$． 展開すると $A_1A_2A_3 + A_1A_2E(X_1) + A_2A_3E(X_2) + A_3A_1E(X_3)$ $ + A_1E(X_2X_3) + A_2E(X_3X_1) + A_3E(X_2X_3) + E(X_1X_2X_3) $ だが，対称性から $E(X_1) = E(X_2)$ などが成り立つので，これは $A_1A_2A_3 + (A_1A_2 + A_2A_3 + A_3A_1)E(X_1)$ $ + (A_1 + A_2 + A_3)E(X_1X_2) + E(X_1X_2X_3) $ に等しい．\n一般に，$A_1, \\ldots, A_i$ の $j$ 次の対称式の値を $S(i,j)$ とし， $e(i) := E(X_1X_2\\cdots X_i)$ とすれば， 求める答は $\\sum_{i = 1}^{N} S(N, N + 1 - i)e(i - 1)$ となる．\n対称式の値の方は， $S(i, j) = [t^{i - j}]\\prod_{k = 1}^{i}(t - A_k)$ であるから， 右辺を愚直に計算して $O(N^2)$ で求められる．\n$e(i)$ を求めるために，確率変数 $Y_{i,k}$ を，箱$i$ が $k$ 回目に 選ばれるとき $1$，選ばれないとき $0$ をとるものとする． $X_i = \\sum_{k = 1}^{K}Y_{i,k}$ であるから，$E(X_1\\cdots X_i)$ を展開して， $e(i) = \\sum \\{ E(\\prod_{j = 1}^i Y_{j,c(j)}) \\mid c : \\bar{i} \\to \\bar{K} \\}$ となる．ここに，$\\bar{n} := \\{1, 2, \\ldots, n\\}$． $c : \\bar{i} \\to \\bar{K}$ が単射でない時には， $\\prod_{j = 1}^i Y_{j,c(j)}$ の値は 0 である． 一方で $c : \\bar{i} \\to \\bar{K}$ が単射の時には， $Y_{1,c(1)}, \\cdots, Y_{i,c(i)}$ は独立である． したがって， $e(i) = \\sum \\{ \\prod_{j = 1}^i E(Y_{j,c(j)}) \\mid c : \\bar{i} \\to \\bar{K} \\text{ は単射} \\}$ $ = \\sum \\{ 1 / N^i \\mid c : \\bar{i} \\to \\bar{K} \\text{ は単射} \\}$ $ = (1 / N^i) (K! / (K - i)!)$ と計算できる．\n解法2 公式解説2 による． $\\prod_{i = 1}^{N} B_i$ を，「$B_i$ 個ずつあるものから1つずつ選ぶ 場合の数と見る」というのがポイント．\nすべての操作について $\\prod_{i=1}^{N}B_i$ の和を求め， $N^K$ で割れば答が求められる．\n操作列 $C_1, \\ldots, C_K$ をとる． すなわち，各 $i$ に対して $1 \\leq C_j \\leq N$ となる列をとる． 列 $D_1, \\ldots, D_N$ を，各 $i$ に対して，$1 \\leq D_i \\leq B_i$ となるようにとる．\n列 $P_1, \\ldots, P_N$ を次のように定める:\n $D_i \\leq A_i$ のとき，$P_i := D_i$ そうでないとき，$P_i := 0$  列 $Q_1, \\ldots, Q_K$ を次のように定める: $i := C_j$ として，$A_i \u0026lt; D_i$ であって，しかも， 第$j$回目の操作で， 箱$i$が選ばれた回数がちょうど $D_i - A_i$ 回になった場合には， $ Q_j := -i$，そうでないとき，$ Q_j := i$\n$(C, D)$ に対して $(P, Q)$ を対応させる写像は単射である． $(C, D)$ の数は，すべての操作に対する $\\prod_{i=1}^{N} B_i$ の和であるから， $(P, Q)$ の数が求める答になる．これは，次の場合の数である．\n $S \\subseteq \\bar{N}$ を選ぶ． 各 $i \\in S$ について $\\bar{A_i}$ から1つ選ぶ 各 $i \\in \\bar{N} \\setminus S$ に対し， ($Q_j = -i$ とする) $j = j_i \\in \\bar{K}$ を，重複のないように選ぶ． 各 $j \\in \\bar{K} \\setminus \\{ j_i \\mid i \\in \\bar{N} \\setminus S\\}$ について，$\\bar{N}$ から1つ選ぶ  $S$ を決めたときの後半2項目の選び方は，$m := |\\bar{N} \\setminus S|$ として， $(K! / (K - m)!)N^{K - m}$ である．つまり，$m$ にしか依存しない． 前半2項目のために，次のDPを考える． 求める答は $\\sum_{m=0}^{N}\\textit{dp}[N][N-m]\\cdot(K! / (K - m)!)N^{K - m}$である．\n $dp[i][j] := \\sum\\{ f(S) \\mid S \\subseteq \\bar{i}$, $|S| = j \\}$  ただし，$f(S)$ は，各 $k \\in S$ について，$A_k$ から1つとる場合の数．    次のように $O(N)$ で計算できる．\n $dp[0][0] = 1$, $\\qquad dp[0][j] = 0\\quad$ ($j \u0026gt; 0)$ $dp[i][j] = dp[i - 1][j] + A_i \\times dp[i - 1][j - 1]$  式を書いてみると，解法1も解法2も同じ計算になることがわかる． (dpの部分は，対称式の計算と同じ．)\n実装 ACコード ","permalink":"https://yamate11.github.io/blog/posts/2022/02-24-abc-231-g-balls-in-boxes/","summary":"解説ACです","title":"Balls in Boxes - Atcoder Beginner Contest 231 G"},{"content":"AtCoder Beginner Contest 230 - ABC 230 F - Predilection の解法です． 解説ACです．\n問題概要 長さ$N$ の数列 $A$ が与えられる．次の操作を好きな回数行う．\n 数列の長さが2以上のとき，隣接する2つの値を，それらの和で置き換える．  0回以上の操作の結果得られる数列の種類数を mod 998244353 で求めよ．\n制約: $N \\leq 2 \\times 10^5$，$-10^9 \\leq A_i \\leq 10^9$\n問題へのリンク 解法 0-indexed で書く．\n$A_0, \\ldots, A_i$ から得られる数列の集合を $S_i$ とする． $S_{i}$ の要素は，$S_{i - 1}$ の要素 $p_0, \\ldots, p_m$ から， いずれかの手段で得られる．\n (A) 末尾に $A_{i}$ を追加して，$p_0, \\ldots, p_m, A_{i}$ とする． (B) 末尾の数に $A_{i}$ を加えて，$p_0, \\ldots, p_{m-1}, p_m + A_{i}$ とする．  このように作成したものが重複する場合を調べる． (A)どうし，(B)どうしは重複しない． (A) 型の $p_0, \\ldots, p_m, A_{i}$ と (B) 型の $q_0, \\ldots, q_{n-1}, q_n + A_{i}$ が一致する条件は， $m = n - 1$, $A_{i} = q_n + A_{i}$，$p_j = q_j$ ($j = 0, \\ldots, n - 1$) である． 逆に，$n \u0026gt; 0$ かつ $q_n = 0$ であれば， $Q_1 = q_0, \\ldots, q_{n-1}, 0$ に対して (B) を適用した数列と， $Q_2 = q_0, \\ldots, q_{n-1}$ に対して (A) を適用した数列が一致する． また，$Q_1$ が $S_{i - 1}$ の要素であれば，$Q_2$ も $S_{i - 1}$ の要素である．\nしたがって，\n $S_i$ の要素数を $dp[i]$ $S_i$ の要素のうち，長さが2以上で末尾が0であるものの数を $f(i)$  とすれば，\n $dp[0] = 1$ $dp[i] = 2 \\times dp[i - 1] - f(i - 1)$  となる．$f(i)$ については，$A_k + A_{k + 1} + \\cdots + A_i = 0$， $0 \u0026lt; k \\leq i$ となる $k$ が存在しなければ，$f(i) = 0$ である． 存在する場合には，そのような $k$ のうち最大のものを $k_0(i)$ として， $f(i) = dp[k_0(i) - 1]$ である．\n$k_0(i)$ は，累積和を用いて $O(N\\log N)$ で計算できる． 全体の計算量は $O(N\\log N)$ となる．\n実装 ACコード ","permalink":"https://yamate11.github.io/blog/posts/2022/02-20-abc-230-f-predilection/","summary":"解説ACです．","title":"Predilection - Atcoder Beginner Contest 230 F"},{"content":"最大流と最小カットについてのコンテスト用のまとめです．\n記号など   $G = (V, E, C)$: グラフ\n $V$: 頂点の集合 $E \\subseteq V \\times V$: 辺の集合．向きあり $C: E \\to \\mathbb{R}$: 容量    $e = (v, w) \\in E$ のとき，$v = e^S$, $w = e^D$ と書く． $(w, v)$ を $e^R$ と書く．\n  $f: E \\to \\mathbb{R}$ に対して，$v \\in V$ での流出量 $\\textrm{out}(v) := \\sum\\{C(e) \\mid e^S = v\\} - \\sum\\{C(e) \\mid e^D = v\\}$．\n  $s, t \\in V$ ($s \\neq t$) について， $f: E \\to \\mathbb{R}$ が $s$ から $t$ への 流量 $F$ のフローである，とは，\n $0 \\leq f(v) \\leq C(v)\\quad$ ($v \\in V$) $\\textrm{out}(v) = 0\\quad$ ($v \\in V \\setminus \\{s, t\\}$) $\\textrm{out}(s) = F$ $\\textrm{out}(t) = -F$    $G_f = (V, E\u0026rsquo;, C\u0026rsquo;)$: 残余グラフ\n $E\u0026rsquo; = E \\cup \\{ e^R \\mid e \\in E \\}$ $e \\in E\u0026rsquo;$ に対して， $C\u0026rsquo;(e) = C(e) - f(e) + f(e^R)\\quad$ ($e^R \\not\\in E$ ならば $f(e^R) = 0$ と解する)    最大流と最小カットの関係 $f$ が$s$から$t$への最大流の時，\n $S := \\{s\\} \\cup \\{ v \\in V \\mid \\text{ 残余グラフ } G_f \\text{ において } s \\text{ から } v \\text{ への正の流量のフローが存在する } \\}$ $T := V \\setminus S$  とする．\n $t \\not\\in T$ である． $(S, T)$ が最小カットを与える．すなわち， $s \\in S\u0026rsquo;$, $t \\in T\u0026rsquo;$ なる分割 $(S\u0026rsquo;, T\u0026rsquo;)$ のなかで， $\\sum\\{ u(e) \\mid e \\in E, e^S \\in S\u0026rsquo;, e^D \\in T\u0026rsquo; \\}$ の最小値を与える．  例   図1のグラフ $G$ を考える．$f$ を，図2の赤字で与えられるフローとする． このフローの流量は4で，最大流ではない． 剰余グラフ $G_f$ を図3 に示す．もとの辺でまだ流せる量と， $f$で流している量の逆向きの流れが合わさったものになっている． ここで上の$S$を作ると $t \\in S$ であり， 図4で示した$s$から$t$に向かうフローがある．このフローを $f$ に加えた フロー $f\u0026rsquo;$ が図5であり，流量6のフローで，最大流である． $G_{f\u0026rsquo;}$ を図6に示す．$(S, T)$ も合わせて図示している． この $(S, T)$ を図1に当てはめてみると，最小カット 4 となっている．\nACL を用いたコード ACL (AtCoder Library) を用いてコードを書く場合には次のようになる．\n#include \u0026lt;atcoder/maxflow\u0026gt;using namespace atcoder;  ...   ll N; cin \u0026gt;\u0026gt; N; // 頂点は {0, ..., N-1}  mf_graph\u0026lt;ll\u0026gt; graph(N);  ll M; cin \u0026gt;\u0026gt; M;  REP(i, M) { cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; c; graph.add_edge(u, v, c); } // 辺の定義   ll f = graph.flow(0, N-1); cout \u0026lt;\u0026lt; f \u0026lt;\u0026lt; endl; // 最大流  for (const auto\u0026amp; e : graph.edges()) if (e.flow \u0026gt; 0) // フローの表示  cout \u0026lt;\u0026lt; e.from \u0026lt;\u0026lt; \u0026#34;-\u0026gt;\u0026#34; \u0026lt;\u0026lt; e.to \u0026lt;\u0026lt; \u0026#34; flow:\u0026#34; \u0026lt;\u0026lt; e.flow \u0026lt;\u0026lt; \u0026#34; / cap:\u0026#34; \u0026lt;\u0026lt; e.cap \u0026lt;\u0026lt; endl;   vector\u0026lt;bool\u0026gt; mc = graph.min_cut(0);  // flow() の直後に呼ぶ．  // mc.size() == N であり，上の (残余グラフから作った) S に対して，mc[i] == true \u0026lt;=\u0026gt; i \\in S  ll c = 0;  for (const auto\u0026amp; e : graph.edges()) if (mc[e.from] and not mc[e.to]) {  c += e.cap;  cout \u0026lt;\u0026lt; e.from \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; e.to \u0026lt;\u0026lt; endl; // 最小カットの表示 }  assert(f == c); // 最大流 == 最小カット リンク  AtCoder Library \u0026hellip; \u0026lt;atcoder/maxflow\u0026gt; Dinic法とその時間計算量 (みはつさん)   ","permalink":"https://yamate11.github.io/blog/posts/2022/02-20-maxflow-mincut/","summary":"最大流と最小カットについてのコンテスト用のまとめです","title":"最大流・最小カット"},{"content":"AtCoder Beginner Contest 238 - ABC 238 G - Cubic? の解法です． 公式解説 と本質的に同じです．\n問題概要 長さ$N$の数列$A$が与えられる．$Q$個の質問に答えよ\n $i$番目の質問: $L_i$, $R_i$ が与えられる．$A_{L_i} \\times \\cdots \\times A_{R_i}$ は立方数か?  制約: $N, Q \\leq 2\\times 10^5$, $A_i \\leq 10^6$\n問題へのリンク 経緯 コンテストでは，時間内には解けませんでした． 終了後に，Mo のアルゴリズムが適用できると気づいて，解けました． 公式解説を読んでみたら，ハッシュで解けると書いてありました． Twitter で，Zobrist Hash というものがあると 指摘されて いて，調べました．\n解法 全部の $A_i$ を素因数分解しておく (40msくらいでできる．別記事 参照)． これらの素因数分解に現れる素数全体の集合を $P$ とし， $S := \\{ (p, i) \\mid p \\in P \\textrm{, } i \\in \\{1, 2\\} \\}$ とする． $S$ の Zobrist Hash $h$ を考える． Zobrist Hash については，別記事 参照．\n正の整数 $a$ を素因数分解して， 冪の部分をすべて3で割ったあまりで置き換えて得られる素冪のうち， $1$ を除いた集合を$f(a)$ と書くことにする． たとえば，$f(7^5\\times 13^{6} \\times 17^{40}) := \\{7^2, 17^1\\}$．\n$B_i := f(A_1 \\times A_2 \\times \\cdots \\times A_i)$ とする． $2\\times3\\times5\\times7\\times11\\times13\\times17\u0026gt;2\\times10^5$ であるから， $|(B_{i + 1} \\setminus B_{i}) \\cup (B_i \\setminus B_{i + 1})|$ はたかだか $6$ である．そこで，$B_i$ たちをすべて決定することができる．\n$C_i := h(B_i)$ として，$i$ 番目の質問には， $C_{L_i-1} == C_{R_i}$ であるかどうかを答える． WAとなる確率はたかだか $QT / V$ (ここで，$T$ はテストケースの数， $V$ はハッシュ関数の値域のサイズ) であるから，$V = 2^{63}$ に とっておけば十分小さい．\n実装 提出コード ","permalink":"https://yamate11.github.io/blog/posts/2022/02-13-abc238-g-cubic/","summary":"ABC238G Cubic? の解法です．公式解説と同じです．","title":"Cubic? - AtCoder Beginner Contest 238 G"},{"content":"ABC238 G Cubic? を解くのに使うことができる Zobrist Hashing に関する記事です．\nネタ元 Wikipedia Zobrist Hashing とは 以下では，ビットごとの XOR を $\\oplus$ と書く．\n固定された有限集合 $S$ の部分集合 に対するハッシュ． $R$ を2冪の大きな数 (たとえば $2^{63}$) として， あらかじめ各 $x \\in S$ に対して区間$[0, R)$ から一様乱数により $r(x)$ を選んでおく． $X \\subseteq S$のハッシュ値 を，$h(X) := \\bigoplus \\{ r(x) \\mid x \\in X\\}$ で定める．\n性質  $h(Y) = h(X) \\oplus h(X \\setminus Y) \\oplus h(Y \\setminus X)$．  したがって，$h(X)$ がわかっていれば， $h(X \\cup \\{x\\})$ や，$h(X \\setminus \\{x\\})$ を $O(1)$ で計算できる．   衝突確率．$X, Y \\subseteq S$, $X \\neq Y$, $\\{d_1, d_2, \\ldots, d_k\\} := (X \\setminus Y) \\cup (Y \\setminus X)$ とする．衝突する条件は，$r(d_1) = \\bigoplus \\{ r(d_j) \\mid j = 2, \\ldots, k \\}$ であるから，この確率は $1/R$ である．  使用例 ABC238 G - Cubic? ","permalink":"https://yamate11.github.io/blog/posts/2022/02-13-zobrist-hash/","summary":"ABC238 G Cubic? を解くのに使うことができる Zobrist Hashing に関する記事です．","title":"Zobrist Hashing"},{"content":"$1$ 以上 $N$ 以下の整数をランダムに生成し， これらの素因数分解に要する時間を計測しました． 生成する個数は，100,000 個としました． 素因数分解の方法は以下の4通りです． 分解する整数を $x$ とします．\n 整数 $p = 2, 3, 4, 5, \\ldots$ で順次割ってみて， 割れたら $x := x / p$ とする．$p^2 \u0026gt; x$ となったら打ち切り． $\\lceil\\sqrt{x}\\;\\rceil$ までの素数リストを，エラトステネスの篩で作成して， それらの素数で順次割ってみる．あとは1と同じ． 事前に $\\lceil\\sqrt{N}\\;\\rceil$ までの素数リストを， エラトステネスの篩で作成しておく． あとは2と同じ． 事前に $N$ までの整数の最小素因数リストを， 篩の方法 で作成しておく．これを用いて分解する．  測定用のソースファイル 結果は以下の通りでした．\n1つの整数の素因数分解に要した時間 (単位: マイクロ秒)\n   N 1e5 2e5 5e5 1e6 2e6 5e6 1e7     方法1 0.70 0.89 1.19 1.56 2.03 2.97 4.02   方法2 1.13 1.53 2.21 3.04 4.18 6.85 8.73   方法3 0.25 0.30 0.36 0.42 0.50 0.65 0.78   方法4 0.09 0.10 0.10 0.16 0.21 0.28 0.33    事前計算に要した時間 (単位: ミリ秒)\n   N 1e5 2e5 5e5 1e6 2e6 5e6 1e7     方法3 0 0 0 0 0 0 0   方法4 0 1 2 6 22 69 147    1e7 までの素数が 1e6 個あるとすると， 方法1では4秒，方法2では 8秒，方法3では 0.78秒，方法4では 0.47秒． 1e6 までの素数が 1e4 個だと， 方法1では4秒，方法2では 8秒，方法3では 0.78秒，方法4では 0.47秒． 15ミリ秒，方法2では30ミリ秒，方法3では 4ミリ秒，方法4では 7ミリ秒．\nランダムの平均だけではなくて，最悪時間も測りたいところですが， まあ，とりあえず．\n","permalink":"https://yamate11.github.io/blog/posts/2022/02-06-prime-factor-perf/","summary":"素因数分解に要する時間を，事前計算と個別の計算に分けて計測しました","title":"素因数分解に要する時間"},{"content":"趣旨 AtCoder Beginner Contest 237 (ABC237) Ex Hakata の 公式解説 に， Dilworth の定理を使って解ける，と書いてあるのですが， それを読んだだけでは (当然?) わからなかったので， (自分が) わかるように書こうという趣旨です．\n結局，この問題を解くには，次の事実が必要であると思います (言葉は下の方で定義しています)．\n命題1  順序集合 $(S, \u0026lt;)$ の反鎖のサイズの最大値は，$|S| - m$ である． ここで $m$ は，$S$を左右に置いて，$s \u0026lt; t$ の時に 左の$s$と右の$t$ を辺で結んだ二部グラフ における最大マッチングのサイズである．\n Dilworth の定理だけではなく，König の定理も知っていると良い感じです．\n以下の記述 (定理の証明) は，Wikipedia の Dilworth\u0026rsquo;s theorem と Konig\u0026rsquo;s theorem に依っています．\n定義・記法 以下，順序とは，半順序のこと． 順序集合 $\\mathcal{S} = (S, \u0026lt;)$ において，$C \\subseteq S$ が鎖であるとは， $C$の任意の2要素が比較可能であること． $A \\subseteq S$ が反鎖であるとは， $A$の任意の2要素が比較不能であること． $D \\subseteq 2^S$が鎖分割であるとは，$D$が$S$の分割であり (つまり，$C, C\u0026rsquo; \\in D, C \\neq C\u0026rsquo; \\implies C\\cap C\u0026rsquo; = \\emptyset$ で，$\\bigcup D = S$)，$D$の要素がすべて鎖であること．\n2部グラフ $(L, R, E)$ ($L$と$R$が頂点の集合，$E\\subseteq L\\times R$ が辺の集合) において， $e = (l, r) \\in E$ に対して，$l$, $r$ をそれぞれ $e_L$, $e_R$ と書く． $M \\subseteq E$ がマッチングであるとは，以下が成り立つこと:\n $e, e\u0026rsquo; \\in M, e \\neq e\u0026rsquo; \\implies e_L \\neq e\u0026rsquo;_L, e_R \\neq e\u0026rsquo;_R$  $C \\subseteq L \\cup R$ が頂点被覆であるとは， 任意の$e\\in E$ に対して $e_L \\in C$ または $e_R \\in C$ となること．\n自明な事実 補題  $A$ が反鎖，$D$ が鎖分割ならば，$|A| \\leq |D|$．\n 証明 $D$ の要素である鎖には，$A$ の要素はたかだか1つしか入れない．(終)\n補題  $M$ がマッチング，$C$ が頂点被覆ならば，$|M| \\leq |C|$．\n 証明 $e \\in M$ に対し，$e_L \\in C$ または $e_R \\in C$ の成り立つ方を 対応させる写像 $M \\to C$ は単射である． (終)\n定理たち Dilworth の定理  $|A| = |D|$ となる反鎖$A$と鎖分割$D$が存在する． 上の補題と合わせて，このサイズが反鎖の最大サイズ，鎖分割の最小サイズである．\n König の定理  $|M| = |C|$ となるマッチング$M$と頂点被覆$C$が存在する． 上の補題と合わせて，このサイズが，マッチングの最大サイズ，頂点被覆の最小サイズである．\n 相互証明 Dilworth の定理と König の定理の片方を仮定すると， 他方を証明することができる．\nKönig → Dilworth 順序集合 $(S, \u0026lt;)$ が与えられたとする． 左右に$S$を置いて，右が大きい組合せを辺でつないだ二部グラフ，つまり， $(S\\times \\{0\\}, S\\times\\{1\\}, \\{((s, 0), (t, 1)) \\mid s \u0026lt; t\\})$ を考える． 最大マッチング$M$と最小頂点被覆$C$を取る．König の定理より， $m = |M| = |C|$ として良い．\n$A$ を，$C$ に現れない頂点の集合とする．つまり， $A = \\{ s \\in S \\mid (s, 0) \\not\\in C, (s, 1) \\not\\in C\\}$． すると，$A$は反鎖であり，$|S| - |C| \\leq |A|$ である．\n$S$ に，$M$ によって導かれる有向グラフ $(S, \\{(s, t) \\mid ((s, 0), (t, 1)) \\in M\\})$ を考える． $M$がマッチングなので，このグラフの頂点の入次数，出次数はたかだか1である． また，$(S, \u0026lt;)$ は順序集合だから，グラフにループは存在しない． したがって，入次数0の頂点から始めて，辺をたどれるだけたどって得られる 集合の全体を $D$ とすると，$D$ は，$S$ の鎖分割になり，$|D| = |S| - |M|$ である．\n以上まとめて，$|D| = |S| - m \\leq |A| \\leq |D|$ となるから， $|A| = |D| = |S| - m$ が得られた．(終)\nDilworth → König (この部分は，ABC237Ex には直接必要ではない)\n2部グラフ $(L, R, E)$ が与えられたとする．$S = L \\cup R$ として， 順序集合 $(S, E)$ を考える． 最大反鎖$A$と最小鎖分割$D$をとる． Dilworth の定理より，$|A| = |D|$ である． $D$ の要素は，単元集合であるか，辺を構成する2点であるかのいずれかである． 前者の集合を $D_1$, 後者の集合を $D_2$ とする．\n$D$は鎖分割であるから，$M = D_2$はマッチングとなる． $C = S \\setminus A$ とすると，$A$は反鎖であるから，$C$は頂点被覆である． $|M| = |C|$ となることを見るために，次を示す:\n $\\bigcup D_1 \\subseteq A$ $e\\in D_2$ に対し，$e_L \\in A$ と $e_R \\in A$ のうちちょうど一方が成り立つ  $p = |\\bigcup D_1 \\setminus A|$ とする． $D_2$ の要素 $e$ については，$e$ は 鎖なので， $e_L \\in A$ と $e_R \\in A$ の両方は成り立たないが，両方とも成り立たない ものの数を $q$ とする．すると， $|D| = |A| \\leq (|D_1| - p) + (|D_2| - q) = |D| - (p + q) \\leq |D|$ であるから，$p = q = 0$ でなければならない．\nしたがって，$|A| = |D_1| + |D_2|$ であり，$|S| = |D_1| + 2 |D_2|$ とあわせて，$|C| = |S| - |A| = |D_2| = |M|$ が得られた．(終)\nKönig の定理の証明 二部グラフ$(L, R, E)$ の最大マッチング$M$をとる． $M_L := \\{ e_L \\mid e \\in M \\}$， $M_R := \\{ e_R \\mid e \\in M \\}$， $m := |M|$ とする．以下のように定義する．\n $L_0 := L \\setminus M_L$ $F_i := \\{ e \\in E \\setminus M \\mid e_L \\in L_0 \\}$ $R_i := \\{ e_R \\mid e \\in F_i \\}$ $G_i := \\{ e \\in M \\mid e_R \\in R_i \\}$ $L_{i + 1} := \\{ e_L \\mid e \\in G_i \\}$ $C := (L \\setminus \\bigcup_i L_i) \\cup \\bigcup_i R_i$  主張1: C は頂点被覆である． $e \\in E$ を取り，$e_L \\not\\in C$ を 仮定し，$e_R \\in C$ を言えば良い．仮定より $e_L \\in L_i$ となる $i$ がとれる．\n $e \\in E \\setminus M$ のときには，$e_R \\in R_i \\subseteq C$ である． $e \\in M$ のときには，定義より $i \\neq 0$ である．したがって， $e\u0026rsquo; \\in G_{i-1}$ なる $e\u0026rsquo;$ がとれて，$e_L = e\u0026rsquo;_L$ である． $e, e\u0026rsquo; \\in M$ で $M$ はマッチングであるから， $e = e\u0026rsquo;$ となり，$e_R = e\u0026rsquo;R \\in R{i-1} \\subseteq C$ である．  主張2: $C \\subseteq M_L \\cup M_R$ $s \\in C \\cap L$ については， $C \\cap L = L \\setminus \\bigcup_i L_i \\subseteq L \\setminus L_i = M_L$ から従う． $s \\in C\\cap R = \\bigcup_i R_i$ について．$s \\not\\in M_R$ であると仮定する． $s \\in R_i$ とすると，$l_0, r_0, l_1, \\ldots, r_i = s$ なる$S$の 列が取れて，$(l_j, r_j) \\in E \\setminus M$, $(l_{j + 1}, r_j) \\in M$ となる． ここで，$M\u0026rsquo; \\subseteq E$ を， $M\u0026rsquo; = M \\setminus \\{(l_{j + 1}, r_j) \\mid j = 0, \\ldots i-1\\} \\cup \\{(l_j, r_j) \\mid j = 0, \\ldots, i\\}$ で定義すると， $M\u0026rsquo;$ はマッチングとなり，$|M\u0026rsquo;| = |M| + 1$ であるから，$M$ が最大マッチング であることに反する．したがって，$s \\in M_R$ でなければならない．\n主張3: $e \\in M$ ならば，$e_L \\not\\in C$ または $e_R \\not\\in C$ $e\\in M$ かつ $e_R \\in C$ とする．$e_R \\in R_i$ となる $i$ がとれる． すると，$e \\in G_i$ であり，したがって，$e_L \\in L_{i+1}$ である． ゆえに，$e_L \\not\\in C$.\n主張2,3より，$C \\to M$ への単射が構成できるので，$|C| \\leq |M|$． 従って補題より $|C| = |M|$ である．主張1と合わせて定理が証明された．(終)\n命題1の証明 König の定理 (いま証明した) を前提とすれば， 上記 König → Dilworth の証明から明らか．(終)\n","permalink":"https://yamate11.github.io/blog/posts/2022/02-02-dilworth-konig/","summary":"ABC237 Ex Hakata を解くのに必要だった Dilworth の定理他に関する記事です．","title":"Dilworthの定理, Konigの定理"},{"content":"AtCoder Beginner Contest 234 - ABC 234 G - Divide A Sequence の解法です． 公式解説 と本質的に同じだと思います．\nコンテストでは，時間が50分くらいあったのですが，解けませんでした． だいたい下に書く解法には到達するまで30分以上かかって， 実装が終わったときには，コンテスト終了後2時間くらいたっていました．\n問題概要 問題へのリンク 長さ $N$ の数列 $A$ が与えられる． $A$ を空でない連続した部分列 $B_1, B_2, \\ldots, B_k$ に切り分ける各方法について， $\\prod_{i=1}^{k}(\\max(B_i) - \\min(B_i))$ を求め，その総和を$\\mod 998244353$ で求めよ．\n制約: $1 \\leq N \\leq 3 \\times 10^5; \\; 1 \\leq A_i \\leq 10^9$\n解法 全部 0-indexed で考える．$A_i$ の代わりに $A[i]$ と書く． また， Python 風に，$A[x:y]$ で， 列 $A_x, A_{x + 1}, \\ldots, A_{y - 1}$ を表すことにする．\n$f(n)$ を，$A[0:n]$ に対する問題の答とする． $f(N)$ を求めることが目標である．\n次のように定義する:\n $q(x, y) := \\max(A[x:y])$ $r(x, y) := \\min(A[x:y])$ $p(x, y) := q(x, y) - r(x, y)$  積和の最後の要素ごとにまとめることによって，次が成り立つ．\n $f(n) = \\sum_{i = 0}^{n-1} f(i)p(i, n)$  ただし，$f(0) = 1$ とする． これで答を求めることができるが，$\\Theta(N^2)$ である． そこで，$f(n)$ の計算結果を利用して $f(n + 1)$ を計算することを考える． 次のように置く:\n $g(n) := f(n + 1) - f(n)$  $g(0) = -1$ である．$n \\geq 1$ の場合は， $p(n, n+1) = A[n] - A[n] = 0$ に注意すると，次が成り立つ:\n $g(n) = \\sum_{i = 0}^{n - 1} f(i)(p(i, n + 1) - p(i, n))$  次のように置く:\n $g_1(n) := \\sum_{i = 0}^{n - 1} f(i)(q(i, n + 1) - q(i, n))$ $g_2(n) := \\sum_{i = 0}^{n - 1} f(i)(r(i, n + 1) - r(i, n))$  以下，$g_1$ を求める． $g_2$ も同様に求められ，$g(n) = g_1(n) - g_2(n)$ だから，答が得られる．\n$k(n)$ と $t(n, j)$ ($j \\in [0, k(n)]$) を定義する:\n $t(n, 0) := n - 1$ $A[i] \u0026gt; \\max(A[i + 1 : n])$ が成り立つ $i \\in [0, n - 1)$ を列挙して， 大きい順に $t(n, 1), t(n, 2), \\ldots, t(n, k(n) - 1)$ とする． $t(n, k(n)) = -1$  ただし，$n = 0$ については，$k(0) := 0$, $t(0, 0) := -1$ である．\nつまり，$i \\in (t(n, j + 1), t(n, j)]$ ならば， $\\max(A[i:n]) = A[t(n, j)]$ となる．\nこの列を用いて，$g_1(n)$ は次のようにかける．\n $g_1(n) = \\sum_{j = 0}^{k(n)} \\max(0, A[n] - A[t(n, j)]) \\sum_{i = t(n, j + 1) + 1}^{t(n, j)} f(i)$  そこで，いつものように累積和を\n $h(0) = 0$ $h(n + 1) = h(n) + f(n)$  と定義すれば，\n $g_1(n) = \\sum_{j = 0}^{k(n)} \\max(0, A[n] - A[t(n, j)]) ( h(t(n, j) + 1) - h(t(n, j + 1) + 1))$  となる． $t(n, *)$ は，stack で実装すれば良い． $t(n + 1, *)$ を計算するときには，$t(n, *)$ をアップデートすることになる． $A[t(n, j)]$ は，$j$ に関して単調増加であることに注意する． 全体の計算量は $O(N)$ である．\nコード 提出コード全体へのリンク 主要部分:\nint main() {  ios_base::sync_with_stdio(false);  cin.tie(nullptr);   ll N; cin \u0026gt;\u0026gt; N;  vector\u0026lt;ll\u0026gt; A(N);  REP(i, N) cin \u0026gt;\u0026gt; A[i];  vector\u0026lt;Fp\u0026gt; f = {1, 0}; f.resize(N + 1);  vector\u0026lt;Fp\u0026gt; h = {0, 1, 1}; h.resize(N + 2);  vector\u0026lt;pair\u0026lt;ll, ll\u0026gt;\u0026gt; stack_max = {{-1, -1}, {0, A[0]}};  vector\u0026lt;pair\u0026lt;ll, ll\u0026gt;\u0026gt; stack_min = {{-1, -1}, {0, A[0]}};  REP2(n, 1, N) {  auto compute = [\u0026amp;](auto\u0026amp; stack, auto cmp) -\u0026gt; Fp {  Fp g = 0;  auto [i, v] = stack.back();  while (not (i \u0026lt; 0 or A[n] == v or cmp(A[n], v))) {  stack.pop_back();  auto [ii, vv] = stack.back();  g += (A[n] - v) * (h[i + 1] - h[ii + 1]);  i = ii;  v = vv;  }  stack.emplace_back(n, A[n]);  return g;  };  Fp g1 = compute(stack_max, less\u0026lt;ll\u0026gt;());  Fp g2 = compute(stack_min, greater\u0026lt;ll\u0026gt;());  f[n + 1] = f[n] + (g1 - g2);  h[n + 2] = h[n + 1] + f[n + 1];  }  cout \u0026lt;\u0026lt; f[N] \u0026lt;\u0026lt; endl;   return 0; } ","permalink":"https://yamate11.github.io/blog/posts/2022/01-09-divide-a-sequence/","summary":"方針にも実装にも時間がかかりました．","title":"Divide A Sequence - AtCoder Beginner Contest 234 G"},{"content":"パナソニックプログラミングコンテスト2021 (AtCoder Beginner Contest 231 - ABC231) に参加して，ABCDEF 6完347位でした．\n微増でした．失敗もありましたけれど，この辺が実力です．\nyamate11さんのAtCoder Beginner Contest 231での成績：347位\nパフォーマンス：1902相当\nレーティング：1836→1843 (+7) :)#AtCoder #パナソニックプログラミングコンテスト2021(ABC231) https://t.co/1XBwubkzMA\n\u0026mdash; yamate11 (@_yamate11) December 11, 2021  問題へのリンク A Water Pressure D/100 を出力します．\nB Election map を使って 各名前の投票数を数え，その最大値を求めます． 書くのも愚かな間違いをして 1WA．\nC Counting 2 ソートしておいて，lower_bound を使って 求めます．\nD Neighbors 迷走したあげくにしょうもないコーディングミスで 1WA． サンプルが弱すぎる! と責任転嫁してしまいます．\nNノードで，$A_i$ と $B_i$ に無向辺を設定したグラフにおいて， 各連結成分が直線上になっていれば良い． 各ノードについて，辺でつながっているノードを vector で持っておいて， サイズが3以上のものがあったらNo．\nノードを端からなめて，vector サイズが1 のものがあったら， そこから直線状にたどれる辺を全部消す．\n最後に全部の辺が消されていたら Yes．残っていたら No．\nE Minimal payments おつり，というのが問題文に出てくるだけで， ちゃんと解けないような気がしてしまいます．\n$dp[x, k] = x$ を，$A_1$ から $A_k$ までの硬貨で表せる枚数，として， $A_k$ 円の硬貨を，$x$ 円以下のできるだけ多くの枚数を払う場合と， 1枚多く使っておつりをもらう場合の枚数の少ない方を取る， と考えて，dp の遷移が書けます． 実装は，$k$ ごとに map を使ってメモ化再帰をすれば良いです．\nF Jealous Two E よりは簡単な印象がありました．\n$(A_i, B_i)$ を，まずAの降順，等しかったら Bの昇順 でソートしておきます． この順で見ていくと， 今までみたものと，今見ているもので喧嘩をしない組合せというのは， Bの方が，今見ているもので値が増えているもの，とすれば良いことが わかります．これはセグメント木で実装できます．反転数の数え方と似ています．\nただし，同じ値があるので注意が必要です．AとBの両方の値が等しいものは， ひとまとめにして考える必要があります．\n","permalink":"https://yamate11.github.io/blog/posts/2021/12-11-abc231/","summary":"パナソニックプログラミングコンテスト2021に参加して，ABCDEF 6完347位でした．A - Water Pressure / B - Election / C - Counting 2 / D - Neighbors / E - Minimal payments / F - Jealous Two","title":"ABC231 参加記"},{"content":"AtCoder Beginner Contest 221 - ABC 221 H - Count Multiset の解法です． 解説ACです． noshi91さんの解説 をなぞっただけのものです．\n問題概要 問題へのリンク 正整数 $N$, $M$ が与えられる． $k = 1, 2, \\ldots, N$ について， $N$ の サイズ $k$ の分割で，多重度が $M$ 以下のものの個数， すなわち，以下を満たす多重集合 $A$ の個数を， mod 998244353 で求めよ．\n $|A| = k$ $\\sum A = N$ 任意の正整数 $x$ について，$A$ に含まれる $x$ の個数は $M$ 以下．  制約: $1 \\leq M \\leq N \\leq 5000$\n解法 $k, n \\in [1, N]$ に対して，次のように定義する:\n $S(k, n)$: $n$ のサイズ $k$ の分割で，多重度が $M$ 以下のもの全体 $T(k, n)$: $S(k, n)$ のうち，最小要素が 2 以上のもの全体 $U(k, n) := S(k, n) \\setminus T(k, n)$: $S(k, n)$ のうち，最小要素が 1 であるもの全体 $V(k, n)$: $S(k, n)$ のうち，1 の多重度が $M$ であるもの全体 $s(k, n) := |S(k, n)|$, $t(k, n) := |T(k, n)|$, $u(k, n) := |U(k, n)|$, $v(k, n) := |V(k, n)|$.  以下が成り立つ．\n $ s(k, n) = t(k, n) + u(k, n) $  自明   $ t(k, n) = \\begin{cases} 0 \u0026amp; \\text{ if } 2k \u0026gt; n \\\\ s(k, n-k) \u0026amp; \\text{ if } 2k \\leq n \\\\ \\end{cases} $  各分割から1ずつ取り除く   $ u(k, n) = \\begin{cases} 0 \u0026amp; \\text{ if } n \u0026lt; k \\text{ or } k = 1 \u0026lt; n \\\\ 1 \u0026amp; \\text{ if } k = n = 1 \\\\ s(k - 1, n - 1) - v(k - 1, n - 1) \u0026amp; \\text{ otherwise } \\\\ \\end{cases} $  要素 1 を一つ取り除く   $ v(k, n) = \\begin{cases} 1 \u0026amp; \\text{ if } k = M = n \\\\ 0 \u0026amp; \\text{ else if } n \\leq k \\text{ or } k \\leq M \\\\ s(k - M, n - k) \u0026amp; \\text{ otherwise } \\\\ \\end{cases} $  各分割から1ずつ取り除く    これで DP ができる．\nそのままメモ化して計算したら TLE してしまった． 配るDPに書き直してやっと通った．\n","permalink":"https://yamate11.github.io/blog/posts/2021/11-24-abc221-h-count-multiset/","summary":"解説ACです．","title":"AtCoder Beginner Contest 221 H - Count Multiset"},{"content":"ABC228 (トヨタシステムズプログラミングコンテスト2021 AtCoder Beginner Contest 228) に参加して ABCDE5完 265位でした．\n失敗した点もありましたが，6連続マイナスで止まったのでよしとします．\nyamate11さんのトヨタシステムズプログラミングコンテスト2021(AtCoder Beginner Contest 228)での成績：265位\nパフォーマンス：2169相当\nレーティング：1859→1894 (+35) :)#AtCoder\n\u0026mdash; yamate11 (@_yamate11) November 20, 2021  問題 問題へのリンク A - On and Off 最近，A問題が難しいです． S \u0026lt; T, S \u0026lt; X のときには T, X に24を加えておいて比較すれば良いです．\nB - Takahashi\u0026rsquo;s Secret 問題文を斜め読みして，DFS を書き始めてしまいました． まあとくに問題無いですけれども．\nC - Final Day 4日目に満点を取ったときに， 3日目までの合計点の第K位に追いつけるかどうかを判定すれば良いです．\nD - Linear Probing vector\u0026lt;ll\u0026gt; A(N) の他に，set\u0026lt;ll\u0026gt; unused を用意します． unused には，A[i] = -1 である i たちを格納しておきます． 初期状態では，unused は，[0..N-1] です．\nタイプ2 のクエリでは，単に A[x mod N] を出力します．\nタイプ1 のクエリでは，h = x mod N として， unused.lower_bound(h) を実行して， [h..N-1] に空いている場所があるかどうか調べ， あればそこに x を代入します． 無ければ unused.lower_bound(0) を実行して， 返ってきた場所に x を代入します． その後，unused を更新します．\nE - Integer Sequence Fair $p = 998244353$ とします． $M^{K^N}$ を mod $p$ で求めればよいわけです．\nおそらく，$M \\equiv 0$ (mod $p$) をコーナーケースだろうと想定している のだろう，と思って，いの一番に\nif (M % p == 0) {  cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; } と書きました．書いたのに，return 0; を書き忘れて1ペナルティ． 馬鹿みたい．\nさて，$M \\not\\equiv 0$ (mod $p$) のときには，Fermat の小定理で $M^{p-1} \\equiv 1$ (mod $p$) ですから， $N^K \\equiv s$ (mod $p-1$) なる $s$ を求めれば， $M^s$ が求める答です．どちらも，普通の，$O(\\log n)$ で $a^n$ を求めるアルゴリズムを使います．\nF - Stamp Game 10分くらい足りなくて，デバッグしきれませんでした． Eで return 0; を忘れなければ解けたかなあ．微妙かなあ．\nまず，$h_2 := \\min(h_1, h_2)$, $w_2 := \\min(w_1, w_2)$ としてしまっても良いです．\n次に，\n $B[i][j] :=$ 左上隅を $(i,j)$ とする黒いスタンプが覆う長方形に 書かれている数値の和 $C[i][j] :=$ 左上隅を $(i,j)$ とする白いスタンプが覆う長方形に 書かれている数値の和  とします．これらは，2次元累積和を用いて，全体として $O(HW)$ で求められます．\n高橋君が左上隅として $(i,j)$ を選んだ時のスコアは， $ s[i][j] := B[i][j] - \\max \\{C[i + di][j + dj] \\mid di \\in [0, h_2 - h_1], dj \\in [0, w_2 - w_1] \\} $ です．この $s[i][j]$ を，順に計算していきます．\nまず，priority queue を $W$ 個 (正確には $W - w_2 + 1$ 個かな) 用意して， $pqC[j]$ には，$i = 0, \\ldots, h_1 - h_2$ について， $(C[i][j], j)$ を挿入しておきます．\n次に，もうひとつ priority queue $pqR$ を用意し， $pqC[0]$ から $pqC[w1 - w2]$ までから最大値を得て，$pqR$ に 挿入します．$pqR$ から最大値を得て，$s[0][0]$ が決定できます．\nこの後，横に動いていく時には，あらたに適当な $j$ について， $pqC[j]$ の最大値を $pqR$ に挿入します．また，$pqR$ から最大値を 得る時には，ペアになっている $j$ の値を見て，もう無効になっていれば そのペアを pop して，その後の最大値を得ます．\n縦に動いていく時も同様に $pqC$ たちを管理します．\n計算量は，全体として $O(HW(\\log H + \\log W))$ だと思います．\n翌日後記 これは，スライド最大値を中途半端に覚えていたんですね． priority queue ではなくて，dequeue を使えばよい． 挿入する時に，今挿入しようとするものよりも小さな値が見えている間は， それを捨てるようにすれば良いのでした．取り出す方は同じです． 計算量は $O(HW)$ になります．\n","permalink":"https://yamate11.github.io/blog/posts/2021/11-21-abc228/","summary":"ABC228 (トヨタシステムズプログラミングコンテスト2021 AtCoder Beginner Contest 228) に参加して ABCDE5完 265位でした．A - On and Off / B - Takahashi\u0026rsquo;s Secret / C - Final Day / D - Linear Probing / E - Integer Sequence Fair / F - Stamp Game","title":"ABC228 参加記"},{"content":"AtCoder Beginner Contest 226 (ABC226) に参加して， ABCDE5完 922位でした．冷えました．\nA - Round decimals 難しかったです．\nstring s; cin \u0026gt;\u0026gt; s; cout \u0026lt;\u0026lt; (stoi(s.substr(0, s.size() - 4)) * 1000 + stoi(s.substr(s.size() - 3) + 500) / 1000 \u0026lt;\u0026lt; endl; B - Counting Arrays vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vec; に読み込んでおいて，sort して unique して erase して size をとりました．\nC - Martial artist 技aが技bの前提になっているとき，bからaに辺がある有向グラフを考えて， 技N からたどれる技全部について 時間を加えれば良いです．\nD - Teleportation $T := \\{(i, j) \\mid 1 \\leq i \u0026lt; j \\leq N\\}$ として， $(a,b), (c,d) \\in T$ に対し， 「$(x_b - x_a, y_b - y_a)$ と $(x_d - x_c, y_d - y_c)$ が平行である」 という同値関係を$T$に入れた時，同値類の数の2倍が求める答です．\n$T$を $(x_b - x_a, y_b - y_a)$ の偏角でソートして，隣り合う要素が 異なるところの数を数えれば同値類の数がわかります．\nしょうもないミスで1WA．\nE - Just one 題意を満たす向き付けができるための必要十分条件は，各連結成分について， 辺の数と頂点の数が等しいことです． 必要条件であることはあきらかです． 十分性: 連結成分のグラフは全域木と1本の辺からなります． その辺の両端をA, B として，全域木の根を A と見た時に， 子から親へ向き付け，最後に A → B の向きを付ければ，題意を満たします．\nこのとき，各連結成分上で，1つだけあるループの向きだけの自由度がありますから， 求める答は，2の連結成分数乗です．\n必要十分条件を理解するまでいろいろ迷走して 2WA．\nF - Score of Permutations 時間が足りず，コードを書いている途中で時間切れになりました．\n順列$P$を決めた時のスコアは，$P$を巡回置換の積で表した時， 各巡回置換の長さの最小公倍数になります．\ndp[n][e] := 1, 2, \u0026hellip;, n の順列で，スコアが e であるものの数\nとします．\n1, .., n の順列のうち， n を含む巡回置換の長さが k であるものを数えます． まず，1, 2, \u0026hellip;, n - 1 から k - 1 個をえらびます． 選んだものと n からなる k 個の巡回置換の数は $(k - 1)!$ ですから， このようなものは $\\binom{n-1}{k-1} (k-1)!$ 個あります． 残り $n - k$ 個の並び替えのスコアが e だとすると，この順列の スコアは LCM(e, k) になりますから，\n$\\textrm{dp}[n][\\textrm{LCM}(e, k)] \\;+\\!=\\; \\textrm{dp}[n - k][e] \\times \\binom{n-1}{k-1} \\times (k-1)!$\nという遷移が書けます．データはmap で持ちます．\n求める答は $\\sum_{e} e^K (\\textrm{dp}[N][e])$ で， $K$乗を $O(\\log K)$ で実行すれば間に合います．\n冷えてhighest-100を割り込みました．まあまた良い時も来るでしょう．\nyamate11さんのAtCoder Beginner Contest 226での成績：922位\nパフォーマンス：1488相当\nレーティング：1894→1859 (-35) :(#AtCoder #ABC226 https://t.co/uBE53UiuSM\n\u0026mdash; yamate11 (@_yamate11) November 7, 2021  ","permalink":"https://yamate11.github.io/blog/posts/2021/11-08-abc226/","summary":"ABC226 に参加して，ABCDE5完 922位でした．冷えました． A - Round decimals;  B - Counting Arrays; C - Martial artist; D - Teleportation; E - Just one; F - Score of Permutations","title":"ABC226 参加記"},{"content":"Atcoder Beginner Contest 225 F String Cards の解法です．公式解説ほぼそのままです．\n問題概要 問題へのリンク 小文字からなる文字列の列 $(S_i)_{i = 1}^N$ がある． $K$個を選んで任意の順で連結して得られる文字列のうち， 辞書順最小のものを求めよ．\n制約: $K \\leq N \\leq 50$, $ | S_i | \\leq 50$\n経緯 コンテスト中には解く時間が無く， 終了後に何時間かかけて，先頭から1文字ずつ決めていく解を実装 して，一応解けたのですが，公式解説を見たら，簡単に解く方法が載っていました．\n予備知識 $K = N$ の場合は，次で求められるのだそうです:\n文字列の集合に，$s \\prec t \\iff s + t \u0026lt; t + s$ で 順序を入れる時，この順序の昇順に連結したものが最小． ただし，$s + t$ は文字列の連結，$s \u0026lt; t$ は通常の順序．\nちょっと注釈が必要で，$\\prec$ は順序にはなります (後述) が， 全順序ではない（たとえば，$s = \\texttt{abc}$，$t = \\texttt{abcabc}$） ので，$ (s_i)_i $ が「昇順」だというのは，$s_i \\nsucc s_{i+1}$ を 意味します．\n命題  $\\prec$ は順序である．\n 公式解説で，鮮やかな証明が紹介されていました．\n証明 非反射律は明らかなので，推移律が成り立つことを言えば良い． $s + t \u0026lt; t + s$ とする．$s + t$ と $t + s$ の長さは同じなので， 文字列 $x$ を26進の数値とみなした値を $v(x)$ と書き， 2^{|x|} を $l(x)$ と書くと， $s + t \u0026lt; t + s \\iff v(s)l(t) + v(t) \u0026lt; v(t)l(s) + v(s)\\iff v(s) - v(s) / l(s) \u0026lt; v(t) - v(t) / l(t)$ となる． つまり，文字列から計算される値の比較で大小が決まるので，推移律が成り立つ． (終)\n命題  $K = N$ の場合，連結文字列のうち，辞書順最小のものは， 順序 $\\prec$ の「昇順」に連結されている．\n 証明 そうでないとすると，その組を入れ替えると辞書順がより小さくなる．(終)\n命題  どのような列も，昇順に並べることができる．\n 証明 列の長さに関する簡単な帰納法．ここで，順序であることを使う．(終)\n解法 まず，$(S_i)_i$ を，$\\prec$ に関して昇順に並べておきます．\n$dp[p][q] := (S_i)_{i=p}^{N}$ から $q$ 個選んで連結して得られる 辞書順最小の文字列\nとします．上の議論から，$q$ 個を選んだら， 並べる順は，全体の順と同一である必要があります．\n$dp[p][q] := \\min(S_p + dp[p + 1][q - 1], dp[p + 1][q]) $\nであることが言えます． 辞書順最小の文字列 $t$ が $S_p$ を含まない場合には，当然，それは $dp[p + 1][q]$ に一致します． $t = S_p + t\u0026rsquo;$ である場合には，任意に $(S_i)_{i=p+1}^{N}$ から $q-1$ 個を選んで連結した文字列 $w$ に対し，$t \\preceq S_p + w$ ですから， $t\u0026rsquo; \\preceq w$ となります．すなわち，$t\u0026rsquo; = dp[p + 1][q-1]$ が成り立ちます． $dp[1][K]$ が求める答で，計算量は $|S_i|$ の最大値を $A$ として， $O(NKA + NA\\log N)$ です．\nなお，公式解説にたくさん嘘解法が紹介されています\u0026hellip;.\nACコード #include \u0026lt;bits/stdc++.h\u0026gt;typedef long long int ll; using namespace std; #define REP2(i, a, b) for (ll i = (a); i \u0026lt; (b); i++) #define REP2R(i, a, b) for (ll i = (a); i \u0026gt;= (b); i--) #define REP(i, b) REP2(i, 0, b) #define ALL(coll) (coll).begin(), (coll).end()  int main() {  ios_base::sync_with_stdio(false);  cin.tie(nullptr);   ll N, K; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; K;  vector\u0026lt;string\u0026gt; S(N); REP(i, N) cin \u0026gt;\u0026gt; S[i];  sort(ALL(S), [\u0026amp;](const string\u0026amp; s, const string\u0026amp; t) -\u0026gt; bool { return s + t \u0026lt; t + s; });  string bigs(1, char(\u0026#39;z\u0026#39; + 1));  vector tbl(N + 1, vector\u0026lt;string\u0026gt;(K + 1, bigs));  REP(i, N + 1) tbl[i][0] = \u0026#34;\u0026#34;;  REP2R(i, N-1, 0) REP2(j, 1, min(K, N - i) + 1) tbl[i][j] = min(tbl[i+1][j], S[i] + tbl[i+1][j-1]);  cout \u0026lt;\u0026lt; tbl[0][K] \u0026lt;\u0026lt; endl;   return 0; } ","permalink":"https://yamate11.github.io/blog/posts/2021/11-03-abc225-f-string-cards/","summary":"解法です．公式解説ほぼそのままです．","title":"String Cards - AtCoder Beginner Contest 225 F"},{"content":"AtCoder Beginner Contest 225 (ABC225) に参加して， ABCD 4完の 1004 位でした．冷えました．\n問題へのリンク A -\tDistinct Strings 全部違えば6，2つ同じでもう一つが違えば3，全部同じなら1です．\nB -\tStar or Not 最初の2行で共通している頂点を見つけて (無ければ No)， 他の全部の行にその頂点が入っているかどうかチェックします．\nC -\tCalendar Validator 以下の条件をチェックします．\n 行の先頭の値が 7 つずつ増える 行内では値が 1 つずつ増える 7 の倍数は，行末以外には現れない．  D -\tPlay Train 各電車について，後と前の電車の番号を覚えておきます(無ければ-1)． クエリ1, 2 では O(1) で更新できます． クエリ3では，前の電車をたどって， 先頭に到達したら，そこから後の電車を順に出力していきます． 出力する電車の合計数が $10^6$ 以下なので，これで間に合います．\n「これで間に合う」ことに気づかず，他の方法を探し続けて 時間を浪費しました．\nE -\tフ 一応コードは時間内に書けたのですが，デバッグが間に合いませんでした．\n直観的には次のようにすればできます．\n i 番目の「フ」の下端と原点を結ぶ直線と，x軸とのなす角を b[i] とする． i 番目の「フ」の左端と原点を結ぶ直線と，x軸とのなす角を e[i] とする．  すると，開区間 (b[i], e[i]) たちが交わらないようにたくさん取れ，という問題に なります．e[i] の昇順に並べ替えておいて，次のDPをします．\ndp[i] = i 番目の区間まで見たときに，重ならないようにとれる区間の数の最大値\ndp[i-1] まで決定したとすると， e[j] \u0026lt;= b[i] なる最大の j を二分探索で取って， dp[i] := max(dp[j] + 1, dp[i-1]) で dp[i] が決定できます． dp[N] が求める答です．計算量は O(N log N)．\n実際には誤差が怖いので整数で計算します． 2つの半直線 (0,0) - (x1,y1) と (0,0) - (x2,y2) が x 軸となす角度の 大小だけ決定できれば良く，それは，x1 * y2 と y1 * x2 の大小を比較すれば わかります．\n大きく冷えました．来週頑張ります．\nyamate11さんのUNICORNプログラミングコンテスト2021(AtCoder Beginner Contest 225)での成績：1004位\nパフォーマンス：1425相当\nレーティング：1936→1894 (-42) :(#AtCoder #UNICORNプログラミングコンテスト2021(ABC225) https://t.co/5DrH4KnAj9\n\u0026mdash; yamate11 (@_yamate11) October 30, 2021  ","permalink":"https://yamate11.github.io/blog/posts/2021/10-31-abc225/","summary":"AtCoder Beginner Contest 225 (ABC225) に参加して，ABCD 4完の 1004 位でした．冷えました．A - Distinct Strings / B - Star or Not / C - Calendar Validator / D -\tPlay Train / E - フ","title":"ABC225 参加記"},{"content":"AtCoder Regular Contest 128 (ARC 128) C - Max Dot を解説ACしました． 公式解説より，多少行間が埋まっていると思います．\n問題概要 整数 $N, M, S$ と整数列 $A = (A_1, .., A_N)$ が与えられる． 次の条件を満たす非負実数列 $(x_1, \u0026hellip;, x_N)$ を作る:\n $0 \\leq x_1 \\leq x_2 \\leq \\cdots \\leq x_N \\leq M $ $x_1 + x_2 + \\cdots + x_N = S$  $\\sum_{i=1}^{N} A_i x_i$ の最大値を求めよ．\n制約: $N \\leq 5000$; $M,S,A_i \\leq 10^6$; $S \\leq NM$;\n問題へのリンク 解法 $x_0 := 0$ として，$y_i := x_{i+1} - x_i$ ($i = 0, \\ldots, N-1$) とすると， 次のように言い換えられる:\n 求める最大値: $\\sum_{i = 0}^{N-1} B_i y_i$． ただし，$B_i := \\sum_{j = i + 1}^{N} A_j$． 満たすべき条件:  $y_i \\geq 0$ $y_0 + \\cdots + y_{N-1} \\leq M$ $N \\cdot y_0 + (N-1) \\cdot y_1 + \\cdots + 1\\cdot y_{N-1} = S$    さらに，$z_i := (N - i)\\cdot y_i$ とすると， 次のように言い換えられる:\n 求める最大値: $\\sum_{i = 0}^{N-1} C_i z_i$． ただし，$C_i := B_i / (N - i)$． 満たすべき条件:  $z_i \\geq 0$ $\\displaystyle\\frac{z_0}{N} + \\displaystyle\\frac{z_1}{N - 1} + \\cdots + \\displaystyle\\frac{z_{N-1}}{1} \\leq M$ $z_0 + z_1 + \\cdots + z_{N-1} = S$    $C_i$ たちの最大値を与える $i$ を $I$ と書く (複数あったら 一番小さいものを取る)． もし，$\\displaystyle\\frac{S}{N - I} \\leq M$ であれば， $z_I = S$, $z_i = 0 \\;(i \\neq I)$ とすることで，最大値が実現できる． 以下，そうでないとする．\n最大値を与える $(x_i)$ を取り，対応する $(y_i)$, $(z_i)$ を取る． もし，$i \u0026gt; I$ かつ $z_i \u0026gt; 0$ なる $i$ があったとすると，$z_{I}$ を $z_i$ だけ増やして，$z_i$ を $0$ に変えると， 条件を満たしたまま，値が増加してしまう．したがって， $i \u0026gt; I$ ならば $z_i = 0$．すなわち， $x_{I + 1} = x_{I + 2} = \\cdots x_{N}$ である．\nここで，$x_{I + 1} \u0026lt; M$ だと仮定する． $x_1 + \\cdots x_I = S - (x_{I + 1} + \\cdots x_N) = S - (N - I) x_{I + 1} \u0026gt; (N - I) (M - x_{I + 1}) \u0026gt; 0$ であるので，$0 = x_{i-1} \u0026lt; x_i$ となる $i \\leq I$ が存在する． 小さな $\\varepsilon \u0026gt; 0$ をとって，$x_i$ を $\\varepsilon$ 減らし， $x_{I+1}$ を $\\varepsilon$ 増やすことによって，条件を満たしたまま 値を大きくすることができてしまう．したがって，$x_{I+1} = M$ で なければならない．\n以上により，もとの問題は，次の2条件を満たす列において， $\\sum_{i = 1}^{I} A_i x_i$ の最大値を求める問題に帰着された．\n $0 \\leq x_1 \\leq x_2 \\leq \\cdots \\leq x_I \\leq M$ $x_1 + x_2 + \\cdots + x_I = S - M(N - I)$  これを繰り返せば良い．計算量は $O(N^2)$．\nACコード 提出 ","permalink":"https://yamate11.github.io/blog/posts/2021/10-29-arc128c-max-dot/","summary":"AtCoder Regular Contest 128 (ARC 128) C - Max Dot を解説ACしました． 公式解説より，多少行間が埋まっていると思います．\n問題概要 整数 $N, M, S$ と整数列 $A = (A_1, .., A_N)$ が与えられる． 次の条件を満たす非負実数列 $(x_1, \u0026hellip;, x_N)$ を作る:\n $0 \\leq x_1 \\leq x_2 \\leq \\cdots \\leq x_N \\leq M $ $x_1 + x_2 + \\cdots + x_N = S$  $\\sum_{i=1}^{N} A_i x_i$ の最大値を求めよ．\n制約: $N \\leq 5000$; $M,S,A_i \\leq 10^6$; $S \\leq NM$;\n問題へのリンク 解法 $x_0 := 0$ として，$y_i := x_{i+1} - x_i$ ($i = 0, \\ldots, N-1$) とすると， 次のように言い換えられる:","title":"Max Dot -- AtCoder Regular Contest 128 C"},{"content":"AtCoder Beginner Contest 224 (ABC 224) に参加して， ABCDE 5完 415位でした．\nA\tTires cout \u0026lt;\u0026lt; (S[S.size() - 2] == 'e' ? \u0026quot;er\\n\u0026quot; : \u0026quot;ist\\n\u0026quot;);\nB\tMongeness 4重ループで全数探索します．\nC\tTriangle? 3重ループで全数探索します．\n(x0, y0), (x1, y1), (x2, y2) を頂点とする三角形が正の面積を持つ条件は， (dx1, dy1) := (x1, y1) - (x0, y0), (dx2, dy2) := (x2, y2) - (x0, y0) として， dx1 * dy2 != dx2 * dy1 です．\nD\t8 Puzzle on Graph 次のような無向グラフを考えます．\n ノードは配置全体． 配置uが配置vから一回の操作で得られるとき，uとvの間に辺がある．  初期配置から，目的とする配置までの距離を普通のBFSで求めます．\nC++なので，配置は普通に長さ9の vector\u0026lt;int\u0026gt; で持って， すでに配置を見たかどうかも set\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; で管理して 間に合いました．時間制限4秒のところ，1.4秒くらいでした．\nE\tIntegers on Grid $a_i$ の大きい順に決定していきます．各行・列ごとに 「その行・列のマスから始めてできるもっとも長い回数」を記憶しておけば， $(r_i, c_i, a_i)$ の答は， max($r_i$行から始められる最も長い回数, $c_i$列から始められる最も長い回数) + 1 になります．$a_i$ が等しいものは一気に処理する必要があります．\nF\tProblem where +s Separate Digits コンテスト中は F は飛ばして G に行きました．\n短いもので実験してみると，次のことが分かります．\n 右端の数は，すべてで右端(一の位)の数として現れる． 右から2番目の数は，半分で一の位，残りで十の位の数として現れる． 右から3番目の数は，半分で一の位，残りの半分で十の位，残りで百の位の数として現れる．  以下同様なので，このとおりに計算すれば良いです．\nG\tRoll or Increment 解けませんでした．残り15分の時点で以下の考察はできていたのに，デバッグしきれませんでした．\n最適解は，次のような形になっています:\n T, T-1, \u0026hellip;, T-(k-1) の k 個では，出目を1増やす． (1 \u0026lt;= k \u0026lt;= T) その他では，振り直す．  k を決めれば良いです．\n上の k 個の位置での期待値の平均は (k - 1) / 2 * A です． したがって，振り直す位置での期待値を e とすると，\ne = B + (k / N) * ((k - 1) / 2 * A) + ((N - k) / N) * e\nとなりますので，これを解いて\ne = (N * B + k * (k - 1) * A / 2) / p\nを得ます．T - k の位置では，k 回出目を増やすよりもランダムの方が 期待値が小さいので，\nN * B + k * (k - 1) * A / 2) / p \u0026lt; A * k\nが成り立ち，k はこれを成り立たせる最小の数ですから，二分探索で k を決定できます．\n誕生日前に黄色になれる最後のチャンスだったので，一発狙ってGに行ってみたけど解けませんでした．来週から地道にやろうと思います．\nyamate11さんのAtCoder Beginner Contest 224での成績：415位\nパフォーマンス：1839相当\nレーティング：1946→1936 (-10) :(#AtCoder #ABC224\n\u0026mdash; yamate11 (@_yamate11) October 23, 2021  ","permalink":"https://yamate11.github.io/blog/posts/2021/10-23-abc224/","summary":"AtCoder Beginner Contest 224 (ABC 224) に参加して，ABCDE 5完 415位でした．A - Tires / B - Mongeness / C - Triangle? / D - 8 Buzzle on Graph / E - Integers on Grid / F - Problem where +s Separate Digits / G - Roll or Increment","title":"ABC224 参加記"},{"content":"自然数の集合 $\\mathbb{N}$ を，XORを加算とする， 体 $\\textrm{F}_2 = \\{0,1\\}$ 上のベクトル空間と見たときに， $x_1, .., x_n \\in \\mathbb{N}$ が張る部分空間の基底の求め方に関する記事です． 熨斗袋さんのツイートで紹介されていた方法です:\nxor の掃き出しすごい簡単に出来るんですね\nvector\u0026lt;int\u0026gt; basis;\nfor(int e : a){\nfor(int b : basis)\nchmin(e, e ^ b);\nif(e)\nbasis.push_back(e);\n}\nこれで数列 a の基底が basis に入る\n\u0026mdash; 熨斗袋 (@noshi91) November 30, 2019  記法など 自然数の集合 $\\{0, 1, \\ldots\u0026hellip;\\}$ を $\\mathbb{N}$ と書く． 自然数のビットごとのXOR演算を $\\oplus$ と書く． $\\mathbb{N}$ を， $\\oplus$ を加算とする，体 $\\textrm{F}_2 = \\{0, 1\\}$ 上の ベクトル空間と見る． $X \\subseteq \\mathbb{N}$ が張る空間を $S(X)$ と書く． 自然数$a, b$ に対して，閉区間，半開区間を $[a, b]$, $[a, b)$ などと書く．\n$x \\in N \\setminus \\{0\\}$ に対して， $2^t \\leq x \u0026lt; 2^{t + 1}$ を満たす $t \\in \\mathbb{N}$ を $\\textrm{MSB}(x)$ と書く． たとえば， $\\textrm{MSB}(1) = 0$, $\\textrm{MSB}(5) = 2$ である．\n命題  $x_1, \\ldots, x_n \\in \\mathbb{N}$ に対し， $y_1, \\ldots, y_n \\in \\mathbb{N}$ を 次で定義する:\n $z_{i, 1} := x_i$ $z_{i,j + 1} := \\min(z_{i,j}, \\;\\; z_{i,j} \\oplus y_j)$ $\\quad (j = 1, \\ldots, i - 1)$ $y_i := z_{i,i}$  $W := \\{i \\in [1, n] \\mid y_i \\neq 0\\}$ とするとき， $Y := \\{y_i \\mid i \\in W\\}$ および $X := \\{x_i \\mid i \\in W\\}$ は， $S(\\{x_1, \\ldots, x_n\\})$ の基底である．\nまた，前者に関しては，$a \\in \\mathbb{N}$ に対して， $c_1, \\ldots, c_n \\in \\{0, 1\\}$ を以下のように定めると， $ a = \\bigoplus_{i = 1}^{n} c_i y_i$ が成り立つ．\n $a_1 := a$ $a_{j + 1} := \\min(a_j,\\; a_j \\oplus y_j)$ ($j = 1, \\ldots, n$) $a_{j + 1} = a_j$ のとき，$c_j = 0$， $a_{j + 1} \u0026lt; a_j$ のとき，$c_j = 1$．   証明 $y_i$ は，$x_i$ および $y_1, \\ldots, y_{i-1}$ の一部の和であるから， $x_i$ は，$y_1, \\ldots, y_i$ の一部の和である．すなわち， $\\{y_1, \\ldots, y_n\\}$ は，$\\{x_1, \\ldots, x_n\\}$ を生成する． したがって，$Y$ は$\\{x_1, \\ldots, x_n\\}$ を生成する．\n次に，$i, j \\in W$, $i \u0026gt; j$ として，$t = \\text{MSB}(y_j)$ とすると， $y_i$ の第$t$ビットは 0 である． なぜなら，$z_{i, j}$ の第 $t$ ビットが 0 であっても 1 であっても， 最小値を作ることから，$z_{i, j+1}$ の第 $t$ ビットは 0 になる． この後の $k \u0026gt;= j + 1$なる $z_{i, k}$においては，帰納法の仮定により， $y_{k-1}$ の第 $t$ ビットは 0 であるから，$z_{i, k}$ の第 $t$ ビットは 0のまま変化しない．\nこのことから，$\\{y_i \\mid i \\in W\\}$ は線形独立である． これらのいくつかの線形結合が 0 であるとし， その最も若い番号を $j$ とすると， 第 $\\text{MSB}(y_j)$ ビットを比較して，$y_j$ の係数が 0 であることがわかる． 以下同様である．\n従って，$Y$は， $S(\\{x_1, \\ldots, x_n\\})$ の基底となる．\nまた，$y_i = x_i \\oplus c_1 y_1 \\oplus \\cdots \\oplus c_{i-1} y_{i-1}$ ($c_j \\in \\{0, 1\\}$) と書けるから， $x_i = c_1 y_1 \\oplus \\cdots \\oplus c_{i-1} y_{i-1} \\oplus y_i$ である．つまり，$X$ は，基底 $Y$ から「基本変形」を繰り返して得られる集合 であるので，$X$も基底になる．(終)\n","permalink":"https://yamate11.github.io/blog/posts/2021/10-22-basis-using-min/","summary":"Z を，XORを加算とする，体 F2 = {0,1} 上のベクトル空間と見たときに，x_1, .., x_n ∈ Z が張る部分空間の基底の求め方","title":"XORに関する基底"},{"content":"AtCoder Beginner Contest 223 (ABC223) H - Xor Query の解法です．解説ACですが，基底は熨斗袋さんの方法で求めました．\n問題概要 正の整数 N と長さN の正の整数列 A = (A_i)_{i\u0026lt;=N} が与えられる． Q個のクエリを処理せよ．クエリでは，(L, R, X) が与えられるので， A_L, A_{L+1}, ..., A_R から1つ以上を選んでそれらの XOR を X に できるかどうか判定する． 制約: N \u0026lt;= 4e5, Q \u0026lt;= 2e5, 1 \u0026lt;= A_i,X_i \u0026lt; 2^60, TL: 3sec 問題へのリンク 解法 $A_i$ や $X_i$ を，$\\textrm{F}_2$ のベクトルと見る．\n$(A_{i}, A_{i-1}, \\ldots, A_1)$ が張る空間の基底 $B_i = (A_{j_p} \\mid p = 1, 2, .., m_i)$ を次のように選ぶ\n $B_0 = $空リスト $B_i\u0026rsquo;$ を，$B_{i-1}$ の先頭に $A_i$ を追加したものとするとき， $B_i$ は，予備知識 に記載した方法で$B_i\u0026rsquo;$ から選んだ基底．  この場合，$B_i = (A_{j_1}, \\ldots, A_{j_{m_i}})$ は， $A_i, A_{i-1}, \\ldots, A_1$ が張る空間の基底で， $i = j_1 \u0026gt; j_2 \u0026gt; \\cdots \u0026gt; j_{m_i}$ となっており，$j_k \\geq j \u0026gt; j_{k+1}$ のとき，$A_j$ は，$A_{j_1}, \\ldots, A_{j_k}$ が張る空間に属する．\nクエリ $(L, R, X)$ は，次のように処理できる: $B_R = (A_{j_1}, \\ldots, A_{j_m})$ とする． $X$ が $(A_{j_1}, \\ldots, A_{j_k})$ が張る空間に属するような 最小の $k$ を，予備知識 に記載した方法で決定する． $L \\leq {j_k}$ なら「Yes」を，そうでなければ「No」を出力する．\n$A_i$ などのビット数を$p$として，$B_i$ の決定は $O(p^2)$ で， $k$ の決定は $O(p)$ でできるので，全体の計算量は $O(p^2 N + pQ)$ である．\n一般に，$x$ が $y_1, \\ldots, y_m$ が張る空間に属するかどうかは， 熨斗袋さんの方法で $O(m)$ で計算できるので， 上の手続きの計算量は， $O(p^2 (N + Q))$ である．\nACコード #include \u0026lt;bits/stdc++.h\u0026gt;#include \u0026lt;cassert\u0026gt;typedef long long int ll; using namespace std; #define REP2(i, a, b) for (ll i = (a); i \u0026lt; (b); i++) #define REP2R(i, a, b) for (ll i = (a); i \u0026gt;= (b); i--) #define REP(i, b) REP2(i, 0, b) #define ALL(coll) (coll).begin(), (coll).end() #define SIZE(v) ((ll)((v).size()))  int main(/* int argc, char *argv[] */) {  ios_base::sync_with_stdio(false);  cin.tie(nullptr);  cout \u0026lt;\u0026lt; setprecision(20);   auto func1 = [\u0026amp;](ll x, const auto\u0026amp; v) -\u0026gt; pair\u0026lt;ll, ll\u0026gt; {  REP(j, SIZE(v)) if ((x = min(x, x ^ v[j].second)) == 0) return {j, 0};  return {-1, x};  };   ll N, Q; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; Q;  vector\u0026lt;ll\u0026gt; A(N); REP(i, N) cin \u0026gt;\u0026gt; A[i];  using sta = pair\u0026lt;ll, ll\u0026gt;;  vector\u0026lt;vector\u0026lt;sta\u0026gt;\u0026gt; B(N);   REP(i, N) {  B[i].emplace_back(i, A[i]);  if (i == 0) continue;  ll sz = SIZE(B[i - 1]);  ll j0 = [\u0026amp;]() -\u0026gt; ll {  REP(j, sz) {  auto [p, y] = B[i - 1][j];  auto [k, x] = func1(y, B[i]);  if (k \u0026lt; 0) B[i].emplace_back(p, x);  else return j + 1;  }  return sz;  }();  REP2(j, j0, sz) B[i].push_back(B[i - 1][j]);  }   REP(i, Q) {  ll l, r, x; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; x; l--; r--;  auto [j, dummy] = func1(x, B[r]);  cout \u0026lt;\u0026lt; (j \u0026gt;= 0 \u0026amp;\u0026amp; l \u0026lt;= B[r][j].first ? \u0026#34;Yes\\n\u0026#34; : \u0026#34;No\\n\u0026#34;);  }  return 0; } ","permalink":"https://yamate11.github.io/blog/posts/2021/10-21-abc223-h-xor-query/","summary":"AtCoder Beginner Contest 223 (ABC223) H - Xor Query の解法です．解説ACですが，基底は熨斗袋さんの方法で求めました．","title":"Xor Query -- AtCoder Beginner Contest 223 H"},{"content":"AtCoder Beginner Contest 223 (ABC 223) に参加して， ABCDEFの6完92'59\u0026quot; 259位でした．記録です．\n問題へのリンク A -\tExact Price cout \u0026lt;\u0026lt; (X \u0026gt; 0 and X % 100 == 0 ? \u0026quot;Yes\\n\u0026quot; : \u0026quot;No\\n\u0026quot;;\nB -\tString Shifting 回数に制限はないので，全部左シフトだとして良いです． 0 回から S.size() - 1 回までの左シフトを順に作って， 辞書順最小と最大のものを作れば良いです．\n$O(N^3)$ のような気が一瞬してしまいましたが，そんなことはなくて $O(N^2)$ ですから間に合います．($N := $S.size())\nC -\tDoukasen 公式解説 に載っている賢い解にびっくりしてしまいましたが，コンテストでは 次のように解きました．\n以下の(1),(2),(3)が成り立つ間，(4)を実行する．\n  (1) 左の火が区間 i に時刻 p に入ろうとしている．\n  (2) 右の火が区間 j に時刻 q に入ろうとしている．\n  (3) i \u0026lt; j\n  (4) p \u0026lt; q なら，p += A[i] / B[i]; i++; そうでなければ， q += A[j] / B[j]; j--;\n  このループを抜けると，左右の火が時間差 p-q で同じ区間 i に 入ろうとしているので，どこで出会うか計算できる．\nD -\tRestricted Permutation 各 i = 1, \u0026hellip;, N に対して，2つの集合 prv, nxt を用意します． 気分は次の通りです．\n prv[i] \u0026hellip; i よりも先に来なければならない数 nxt[i] \u0026hellip; i よりも後に来なければならない数  実際には，各 $(A_i, B_i)$ に対して，$A_i$ を $\\text{prv}[B_i]$ に， $B_i$ を $\\text{nxt}[A_i]$ に入れます．\n答を左から書いていくことにして，prv[i] が空なら，i を書くことができます． 辞書順最小にしたいので，priority queue を使います．\n 最初の状態で prv[i] が空である i を全部キューに入れておきます． キューがからでない間ループ:  キューから i を取り出して出力します． nxt[i] の要素 j に対して，  prv[j] から i を取り除きます． prv[j] が空になったら，j をキューに入れます．      このままだと，同じ j が複数回キューに入ってしまう可能性があります． キューに入れる前に重複チェックが必要です．これを忘れて， また，直し方を間違えて，2 ペナルティーでした．もったいない\u0026hellip;.\nE -\tPlacing Rectangles 3つの長方形の配置は以下のいずれか (ということを無証明で通してしまいました)\n 3つ縦に並ぶ 3つ横に並ぶ 横2行で，1行に1個，もう1行に2個． 縦2列で，1列に1個，もう1列に2個．  各々の場合について，A, B, C が X, Y に入るかどうか判定します．\nF -\tParenthesis Checking ( を 1 に，) を -1 に置き換えて，位置 i までの累積和を $S_i$ と すると，括弧列が全体として正しいための 必要十分条件は，$S_N = 0$ かつ すべての $i$ について $S_i \\geq 0$ であることです． したがって，位置 l から 位置 r までの括弧列が正しいための条件は， 下の両方が成り立つことです．\n $S_{l-1} = S_r$ すべての $i \\in [l, r]$ に対して，$S_i \\geq S_r$  これは，次のように言い換えられます:\n $S_{l-1} = S_r$ かつ $\\min\\{S_i \\mid i \\in [l, r]\\} = S_r$  また，位置$l$と$r$の文字を入れ替えたときには，$S$ は次のように変わります:\n 両方が同じ文字なら，変化無し ( と ) の場合には，$i \\in [l, r-1]$ について，$S_i$ が 2 減る． ) と ( の場合には，$i \\in [l, r-1]$ について，$S_i$ が 2 増える．  したがって，$S_i$ の値を，区間加算と区間最小値取得ができる セグメント木で管理することで答が得られます．\nG -\tVertex Deletion E が解けた時点で残り40分でした． F と G の問題文をざっと読んで，G は解けそうになく (そもそもマッチングという ことばが分からない (ので検索した))，F は解けそうだったので，F に 行きました．結果的には， G は 40分あれば解けたことがわかったので失敗だったのですが， すぐには方針が思いつかなかったのでやむを得ないですかねえ．うーむ．\n最小マッチングというのは，pairwise に頂点を共有しない辺の集合 $X$ で 要素数最小のもの，ということが検索して分かったので，それで考えます． グラフは木ですから，$X$ は，葉から順に貪欲に取っていけば良いです (ということにすぐ思い当たれば G に行けたかもしれない．未練たらしい\u0026hellip;)\n正確には次のようになるでしょうか: 適当に根を考えたとき， $X$ に入っている辺の両端の頂点のうち，根に近い方の点からなる集合を $Y$ とします．$Y$ は次の条件を満たすとして良いです: 頂点 $v$ に関し，\n $v$ の子がすべて $Y$ に属していれば $v$ は $Y$ に属さない． $v$ の子で $Y$ に属していないものがあれば，$v$ は $Y$ に属する．  上の条件は当然で，下の条件はもし満たしていなければ， 満たすように $X$ を (要素数を変えずに) 変更することができます． 上の条件から，根 $r$ を決めたときに $Y$ は確定します．これを $Y_r$ と 書くことにします． $r$ が $Y_r$ に属するときには，$r$ とその辺を取り除いてしまうと 最小マッチングが減り，$r$ が $Y_r$ に属さなければ，最小マッチングは 減りません．ということで，各$r$に対して $r \\in Y_r$ かどうかを判定すれば よいことになりました．\n$r \\in Y_r$ かどうかは， $f(p) = \\bigvee \\{ \\neg f(q) \\mid q \\text{ は } p \\text{ の子 }\\}$ と，子の値からモノイド演算で定義した $f(r)$ の値として決定できますから， 全方位木DPで求めることができます．\nH -\tXor Query 問題も読めませんでした． あとで解説ACしました ．\n微減ですんだからOK... という気持ちには今日はなれないなあ．残念．\nyamate11さんのAtCoder Beginner Contest 223での成績：259位\nパフォーマンス：1916相当\nレーティング：1949→1946 (-3) :(#AtCoder #ABC223 https://t.co/61p9VRUfwY\n\u0026mdash; yamate11 (@_yamate11) October 17, 2021  ","permalink":"https://yamate11.github.io/blog/posts/2021/10-17-abc223/","summary":"AtCoder Beginner Contest 223 (ABC 223) に参加して， ABCDEFの6完92'59\u0026quot; 259位でした．記録です．\n問題へのリンク A -\tExact Price cout \u0026lt;\u0026lt; (X \u0026gt; 0 and X % 100 == 0 ? \u0026quot;Yes\\n\u0026quot; : \u0026quot;No\\n\u0026quot;;\nB -\tString Shifting 回数に制限はないので，全部左シフトだとして良いです． 0 回から S.size() - 1 回までの左シフトを順に作って， 辞書順最小と最大のものを作れば良いです．\n$O(N^3)$ のような気が一瞬してしまいましたが，そんなことはなくて $O(N^2)$ ですから間に合います．($N := $S.size())\nC -\tDoukasen 公式解説 に載っている賢い解にびっくりしてしまいましたが，コンテストでは 次のように解きました．\n以下の(1),(2),(3)が成り立つ間，(4)を実行する．\n  (1) 左の火が区間 i に時刻 p に入ろうとしている．\n  (2) 右の火が区間 j に時刻 q に入ろうとしている．","title":"ABC 223 参加記"},{"content":"エクサウィザーズプログラミングコンテスト2021 (AtCoder Beginner Contest 222 - ABC 222) G - 222 を解説ACしました．公式解説そのままですが，予備知識のところを self-contained になるように書きました．\n問題概要 整数 K が与えられる． 数列 2, 22, 222, 2222, .... に，初めて K の倍数が現れるのは何項目か? 現れなければ -1 と答えよ．T個のケースが与えられる． 制約: T \u0026lt;= 200, K \u0026lt;= 10^8 問題へのリンク 予備知識 フェルマーの小定理  整数 $a$ が素数 $p$ と互いに素ならば， $a^{p - 1} \\equiv 1 \\text{ (mod } p \\text{)}$．\n 証明 $a^p \\equiv a$ を言えば良い．帰納法． $a^p = (a - 1 + 1)^p = (a-1)^p + 1 + \\sum_{r = 1}^{p-1}\\binom{p}{r}(a-1)^r \\equiv (a-1)^p + 1 \\equiv a - 1 + 1 = a$．(終)\nオイラーの$\\varphi$関数 正の整数 $n$ に対し，$n$ と互いに素である $n$ 以下の正の整数の 個数を $\\varphi(n)$ とする．\n命題  $n$ の素因数分解を $\\prod_{k=1}^{d}p_k^{e_k}$ とするとき， $\\varphi(n) = \\prod_{k=1}^{d}(p_k^{e_k} - p_k^{e_k - 1})$\n 証明 素数 $p$ に対して $\\varphi(p^e) = p^e - p^{e-1}$ であることと， $m, n$が互いに素であるとき $\\varphi(mn) = \\varphi(m)\\varphi(n)$ であることを言えば良い．前半は明らか． 後半: $t$ と互いに素である $t$ 以下の正の整数の集合を $P(t)$ とする． $x \\in P(mn)$ に対して $(x \\% m, x \\% n) \\in P(m)\\times P(n)$ を対応させる写像が1対1, onto になる (中国剰余定理)．(終)\nオイラーの定理  $a$ と $n$ が互いに素ならば， $a^{\\varphi(n)} \\equiv 1 \\text{ (mod } n \\text{)}$\n 証明 $X = \\{ ax \\% n \\mid x \\in P(n) \\}$ とすると， $X \\subseteq P(n)$ と $|X| = |P(n)|$ より，$X = P(n)$． したがって，$d := \\prod_{x \\in P(n)} x$ とすれば， $a^{\\varphi(n)} d \\equiv d$．$d$ と $n$ は互いに素なので， $a^{\\varphi(n)} \\equiv 1$．(終)\n解法 数列の第 n 項は，$2 (10^n - 1) / 9$ と書ける． $K$ が奇数のとき，$\\alpha = 9K$，$K$ が偶数の時，$\\alpha = 9K/2$ とすると， $2 (10^n - 1) / 9 \\equiv 0$ (mod $K$) $\\iff 2 (10^n - 1) \\equiv 0$ (mod $9K$) $\\iff 10^n \\equiv 1$ (mod $\\alpha$)．\nここで，$\\alpha$ が 2か5で割り切れる場合には，$10^n$ は mod $\\alpha$ で 1 にはなり得ない． そうでない場合， $10^n \\equiv 1$ となる正の $n$ の最小値を取る． $n = q\\varphi(\\alpha) + r$, $0 \\leq r \u0026lt; \\varphi(\\alpha)$ $\\varphi(\\alpha) = qn + r$, $0 \\leq r \u0026lt; n$ とすると， オイラーの定理より $10^r \\equiv 1$ となるので，最小性より $r = 0$． すなわち，$n$ は $\\varphi(\\alpha)$ の約数．これを全探索すれば良い． (2023.03.25 追記: 間違っていた数式を修正しました． ご指摘 くださいました @kumakumaaaaa__ さん，ありがとうございました．)\n計算量は，$\\varphi(\\alpha)$ を求めるために $K$ を素因数分解 するところで，$O(\\sqrt{K})$ と，約数列挙が $O(\\sqrt{K})$ で，合わせて $O(\\sqrt{K})$．\nACコード https://atcoder.jp/contests/abc222/submissions/26539813 keywords: Fermat Fermat\u0026rsquo;s theorem Euler phi function\n","permalink":"https://yamate11.github.io/blog/posts/2021/10-13-abc222-g-222/","summary":"エクサウィザーズプログラミングコンテスト2021 (AtCoder Beginner Contest 222 - ABC 222) G - 222 を解説ACしました．公式解説そのままですが，予備知識のところを self-contained になるように書きました．","title":"222 -- AtCoder Beginner Contest 222 G"},{"content":"木の直径についての記事です．今週 (2021/10/09) と先週に引き続いて，AtCoder Beginner Contest に木の直径に関する問題が出たので，基本事項をまとめました．\n仮定 木の各辺に，正の重み (距離) がついているとする．\n記法  ノードの集合を $N$ と書く．辺の集合を$E$ と書く． 2ノード $a$, $b$ を結ぶパスを $p(a, b)$ と書く． $(a,b) \\in E$ のとき，辺$ab$に付された重みを $d(a,b)$ と書く． $p(a, b)$ を構成する辺に付された重みの和も， 同じ $d(a, b)$ で表す． $D := \\max\\{d(a,b) \\mid a, b \\in N\\}$ を，木の直径の長さと呼ぶ． $d(a, b) = D$ であるとき，$p(a, b)$ を，木の直径と呼ぶ．  命題1  2つのパス$\\pi_1 = p(x_1, y_1)$ および $\\pi_2 = p(x_2, y_2)$ が ともに直径であるとき， これらのパスは共通のノードを持つ．\n 証明 $\\pi_1$ と $\\pi_2$ が共通ノードを持たないと仮定して矛盾を導く． $\\pi = p(x_1, x_2)$ とする． $\\pi_1$, $\\pi_2$ と $\\pi$ との分岐点を $z_1$, $z_2$ とする． 仮定より $z_1 \\neq z_2$である． 以下が成り立つ．\n $d(x_1, z_1) + d(z_1, y_1) = D$ $d(x_2, z_2) + d(z_2, y_2) = D$ $d(x_1, z_1) + d(z_1, z_2) + d(z_2, y_2) \\leq D$ $d(x_2, z_2) + d(z_1, z_2) + d(z_1, y_1) \\leq D$  第3,4式を加えて第1,2式を代入すると $d(z_1, z_2) \\leq 0$ が得られ，矛盾が生じた．\n命題2  パス $p(a, b)$ が直径であるとき，任意の $x \\in N$ に対して， $a$ または $b$ が，木の中で $x$ から最も遠い点になる．すなわち， 任意の $w \\in N$ に対して，$d(x, w) \\leq \\max(d(x, a), d(x, b))$\n 証明 $d(x, a) \\geq d(x, b)$ として良い．$w \\in N$ が， $d(x, w) \u0026gt; d(x, a)$ を満たすと仮定して，矛盾を導く．\nCase1: $p(x, w)$ と $p(a, b)$ が共通部分を持つ場合\n共通部分を$p(x\u0026rsquo;, w\u0026rsquo;)$ とする． ただし，$x$に近い方を $x\u0026rsquo;$，$w$に近い方を $w\u0026rsquo;$ とする．\nCase1-1: $x\u0026rsquo;$と$w\u0026rsquo;$ のうち，$x\u0026rsquo;$ が $b$ 寄りで，$w\u0026rsquo;$ が $a$ 寄りの場合\n$d(x, w\u0026rsquo;) + d(w\u0026rsquo;, w) = d(x, w) \u0026gt; d(x, a) = d(x, w\u0026rsquo;) + d(w\u0026rsquo;, a)$ であるから，$d(w\u0026rsquo;, w) \u0026gt; d(w\u0026rsquo;, a)$ であることに 注意する． $d(w, b) = d(w, w\u0026rsquo;) + d(w\u0026rsquo;, x\u0026rsquo;) + d(x\u0026rsquo;, b) \u0026gt; d(a, w\u0026rsquo;) + d(w\u0026rsquo;, x\u0026rsquo;) + d(x\u0026rsquo;, b) = d(a, b) = D$ となり，直径の定義に反する．\nCase1-2: $x\u0026rsquo;$と$w\u0026rsquo;$ のうち，$x\u0026rsquo;$ が $a$ 寄りで，$w\u0026rsquo;$ が $b$ 寄りの場合\n$d(x, x\u0026rsquo;) + d(x\u0026rsquo;, a) = d(x, a) \\geq d(x, b) = d(x, x\u0026rsquo;) + d(x\u0026rsquo;, b)$ であるから，$d(x\u0026rsquo;, a) \\geq d(x\u0026rsquo;, b)$ である． また，$d(x, x\u0026rsquo;) + d(x\u0026rsquo;, w) = d(x, w) \u0026gt; d(x, a) = d(x, x\u0026rsquo;) + d(x\u0026rsquo;, a)$ であるから，$d(x\u0026rsquo;, w) \u0026gt; d(x\u0026rsquo;, a)$ である． すると，$d(a, w) = d(a, x\u0026rsquo;) + d(x\u0026rsquo;, w) \u0026gt; d(a, x\u0026rsquo;) + d(x\u0026rsquo;, a) \\geq d(x\u0026rsquo;, b) + d(x\u0026rsquo;, a) = d(a, b) = D$ となり，直径の定義に反する．\nCase2: $p(x, w)$ と $p(a, b)$ が共通部分を持たない場合\n$p(x, w)$ と $p(x, a)$ との共通部分を $p(x, x\u0026rsquo;)$ とする． $p(x, a)$ と $p(b, a)$ との共通部分を $p(b\u0026rsquo;, a)$ とする． $p(x, x\u0026rsquo;) + p(x\u0026rsquo;, w) = p(x, w) \u0026gt; p(x, a) = p(x, x\u0026rsquo;) + p(x\u0026rsquo;, b\u0026rsquo;) + p(b\u0026rsquo;, a)$ であるから，$p(x\u0026rsquo;, w) \u0026gt; p(b\u0026rsquo;, a)$ である． $p(b, w) = p(b, b\u0026rsquo;) + b(b\u0026rsquo;, x\u0026rsquo;) + p(x\u0026rsquo;, w) \u0026gt; p(b, b\u0026rsquo;) + p(b\u0026rsquo;, a) = p(b, a) = D$ となり，直径の定義に反する．\n命題3  $x \\in N$ をとる．$x$ からもっとも遠い点を $a$ として， $a$ からもっとも遠い点を $b$ とすると，$p(a, b)$ は，木の直径である．\n 証明 $p(c, d)$ を木の直径とする． 命題2より，$c$ もまた，$x$ から最も遠い点であるとしてよい． $p(x, a)$ と $p(x, c)$ の共通部分を $p(x, x\u0026rsquo;)$ とする． $d(a, x\u0026rsquo;) = d(c, x\u0026rsquo;)$ である．\n$p(c, d)$ と $p(c, a)$ の共通部分を $p(c, y)$ とする．\nCase1: $y$ が $p(c, x\u0026rsquo;)$ 上にある場合． このときには，$d(a, b) \\geq d(a, d) = d(a, x\u0026rsquo;) + d(x\u0026rsquo;, d) = d(c, x\u0026rsquo;) + d(x\u0026rsquo;, d) = d(c, d) = D$ となり，したがって，$p(a, b)$ は木の直径である．\nCase2: $y$ が $p(x\u0026rsquo;, a)$ 上にある場合． このときには，$d(x, x\u0026rsquo;) + d(x\u0026rsquo;, y) + d(y, a) = d(x, a) \\geq d(x, d) = d(x, x\u0026rsquo;) + d(x\u0026rsquo;, y) + d(y, d)$ より，$d(y, a) \\geq d(y, d)$ である． したがって，$d(a, b) \\geq d(a, c) = d(a, y) + d(y, x\u0026rsquo;) + d(x\u0026rsquo;, c) \\geq d(d, y) + d(y, x\u0026rsquo;) + d(x\u0026rsquo;, c) = d(d, c) = D$ となり， $p(a, b)$ は木の直径である．\n命題4  木の直径の長さを $D$ とすると，次のいずれかが成り立つ．\n $c \\in N$ が存在して，すべての直径 $p(a, b)$ は $c$ を通り， $d(a, c) = d(c, b) = D/2$ である． $(c_1, c_2) \\in E$ と非負の $D_1, D_2$ が存在して， すべての直径 $p(a, b)$ は $c_1, c_2$ を通り， $D_1 + D_2 + d(c_1, c_2) = D$ が成り立ち， (必要なら$a$, $b$を入れ替えることによって) $d(a, c_1) = D_1$, $d(c_2, b) = D_2$ が成り立つ．   証明 直径 $p(a, b)$ を取る．\nCase1: $p(a, b)$ 上のノード $c$ で，$d(a, c) = d(c, b) = D/2$ となる ものが存在するとき．\n他の直径 $p(p, q)$ を取る．命題1により $p(a, b)$ と $p(p, q)$ は 共通のノードを持ち，これらは長さ0以上のパスをなす．これを $p(x, y)$ とする (xの側を a, p; y の側を b, q とする)． $c$ が $p(x, y)$ に含まれないとすると，$p(a, p)$ ないし $p(b, q)$ のいずれか の長さが $D$ より大きくなってしまう．したがって，$c$ は $p(x, y)$ に 含まれる．すなわち，$c$ は $p(p, q)$ 上にある．\nCase2: そうでないとき\n$d(a, c_1) \u0026lt; D/2$, $d(c_2, b) \u0026lt; D/2$, $(c_1, c_2) \\in E$ となる $c_1$, $c_2$ が取れる． 他の直径 $p(p, q)$ を取る． Case1と同様にして，$c_1, c_2 \\in p(p, q)$ であることと， $d(a, c_1) = d(p, c_1)$, $d(c_2, b) = d(c_2, q)$ であることがわかる．\n","permalink":"https://yamate11.github.io/blog/posts/2021/10-10-tree-diameter/","summary":"木の直径についての記事です．今週 (2021/10/09) と先週に引き続いて，AtCoder Beginner Contest に木の直径に関する問題が出たので，基本事項をまとめました．","title":"木の直径"},{"content":"エクサウィザーズプログラミングコンテスト2021（AtCoder Beginner Contest 222） (ABC 222) に参加して，ABCDE 5完498位でした．参加記です．\n問題へのリンク 思ったよりも冷えなかった．よかった (よくない)．\nyamate11さんのエクサウィザーズプログラミングコンテスト2021での成績：498位\nパフォーマンス：1818相当\nレーティング：1963→1949 (-14) :(#AtCoder #エクサウィザーズプログラミングコンテスト2021（ABC222） https://t.co/ajMzOdKgza\n\u0026mdash; yamate11 (@_yamate11) October 9, 2021  A - Four Digits 文字列として読み込んで，(4 - 長さ) 個の 0 を出力した後に出力．\n%04d という書式指定は浮かんだんですけど，printf の使い方に自信が持てず， 止めました．\nB\tFailing Grade 言われたとおりに数えます．\nC\tSwiss-System Tournament シミュレーションします．\nD\tBetween Two Arrays DPをします．\ndp[i][j] = $c_i$ の値が $j$ 以下であって条件を満たす列 $(c_1, \\ldots, c_i)$ の数．\nE\tRed and Blue Tree 色の塗り方にかかわらず，各辺を通る回数は決まっているので，まず， この回数を求めます．2頂点を結ぶ最短経路は，LCA を使って求められます．\n回数が決まったら，DPをします．\ndp[e][k] = 辺 1, \u0026hellip;, e を塗る方法で，そこまでの赤の回数と青の回数の 差が k であるような塗り方の数．\nk の取り得る範囲は - (M * (N - 1)) 以上 (M * (N - 1)) 以下なので， 計算量は $O(MN^2)$ となります．危ないかな，と思いましたが 280ms でセーフ．\n求める答は dp[N-1][K] なのですが，|K| が M * (N-1) より大きいときには 0 にすることが必要です．そういうサンプルを入れてくれてあったので 助かりました．全然気がついていなかったので，サンプルが無かったら 相当悩んだと思います．\nG\t222 Eまで49'11\u0026quot; で，私としては相当速く解けた感じです． もしGが解ければラッキー，と思って考え始めましたが， 歯が立ちませんでした．15分くらい考えて降参． この辺の判断が遅いんですよね．\nF\tExpensive Expense twitter で，みなさん，全方位木DP と言っています． チラッと考えはしたのですが，以下の方針で解ける，と思って実装を始めました． 結局間に合いませんでした．(コンテスト後に一応ACしました．) やっぱり全方位木DPで行くべきでしたでしょうか．\nDFSの行きがけ順に街を並べて，$1 = s(1), \\ldots, s(N)$ とします． 街 $i$ の子孫の s-添字は区間になります． つまり，$i$ の子孫は， $\\{ s(j) \\mid j \\in [b(i), e(i)) \\}$ と書くことができます．\n最大値の問合せと和の更新ができる， ノード数 $N$ の遅延セグメント木を用意します． 初期状態では，ノード $i$ には，$E_{1, i}$ を設定しておきます． DFSで，セグメント木を更新していき，DFSで街$j$を見ているときには， ノード $i$ に $E_{j, i}$ が保持されるようにします．このためには， 木を$p$ から $q$ に下がるときに，\n 全体に $C_r$ を加える．($r$ は，$p$ と $q$ を結ぶ道の番号) $q$ の子孫には，$-2C_r$ を加える．(上と合わせて $C_r$ を減じたことになる)  を行います．ここで，\n セグメント木のノード $q$ には $D_q$ が設定されているので， $-D_q$ を加えて 0 にする． 全体の最大値を求める．  とすることで，$q$ における値が求められます．\n$q$から$p$ に戻るときに，上の逆を行って， セグメント木の値を元に戻します．\n","permalink":"https://yamate11.github.io/blog/posts/2021/10-09-abc222/","summary":"ABC222 に参加して，ABCDE 5完 498位でした．参加記です．","title":"ABC 222 参加記"},{"content":"AtCoder Beginner Contest (ABC221) に参加して， ABCDEF 6完2ペナルティ 238位でした．その記録です．\nA - Seismic magnitude scales $32^{B-A}$ が答です．\nB - typo S = T か，または， 隣り合う2文字を入れ替えてみて T と一致すれば Yes, そうでなければ No です．\n「隣り合う」というのを見落として1WA．良く読まなくちゃ．\nC - Select Mul $N$の桁数を $t$ として，2つに分離する方法が $2^t$ くらいあります (実際には両者1つ以上必要なので，$2^t - 2$)．これらを全部探索します． 2つに分けたら，各々降順ソートして掛け合わせます．\nD - Online games イベントソートです．\n ユーザが x 日目にログインした \u0026hellip; $(x, 1)$ ユーザが y 日目にログアウトした \u0026hellip; $(y, -1)$  これらを昇順にソートして，順に見ます．現在のログイン数を表す 変数 num に，一つ前に見た組の日付を表す変数 prev を使い， $(z, c)$ を見たら，次を実行します:\nanswer[num] += z - prev; num += c; prev = z; E - LEQ 解法 $i \u0026lt; j$ で $A_i \\leq A_j$ となっていたら， $i$ で始まって $j$ で終わる部分列 $2^{j - i - 1}$ 個は条件を満たします．これ以外に条件を満たす部分列はありません．\nしたがって，求める答は\n$$ \\sum_i \\frac{1}{2^{i+1}} \\sum \\{ 2^{j} \\mid i \u0026lt; j \\text{ and } A_i \\leq A_j \\} $$\nとなりますから， $i$ の大きい方から順に，和をセグメント木で求めていけば良いです． 座標圧縮が必要です．\n経緯 $i$ を大きい方から見ていくということは考えていたのですが， $i$ が減るたびに，\n 今ある値を全部2倍して， A_i のところに 1 を追加する  という操作をしなくてはならず，これはできないよな，と思って 上の解法に至るまでだいぶ時間を使いました．終了後，それは 遅延セグメント木でできる，という指摘がありました．\nEは遅延セグ木で区間和、全体二倍、一点+1をしました。\n\u0026mdash; keijak (@keijak) October 2, 2021  F - Diameter set 解法 木の直径などに関しては以下が成り立ちます． maguroflyさんのまとめ がわかりやすい．\n 任意の点$x$に対し，$x$ から $y$ が最遠で，$y$ から $z$ が最遠であるとき， $y$ と $z$ を結ぶパスが直径パスになる． 最遠点までの距離が最小の点を中心と呼ぶことにすると，  直径$d$が偶数の時，中心がちょうど1つ存在する． これは，任意の直径パス $y$ \u0026ndash; $z$ に対して，パス上にあって $y$ から 距離 $d$ の点である． 直径$d$が奇数の時，中心がちょうど2つ存在する． これは，任意の直径パス $y$ \u0026ndash; $z$ に対して，パス上にあって $y$ から 距離 $(d - 1) / 2$ と $(d + 1) / 2$ の点である．    直径$d$が奇数の時には，各中心を根とする (もう一つの中心と反対方向の) 部分木の，深さ$(d - 1) / 2$ の点の数を $m$, $n$ とすれば， 答は $mn$ になります．\n直径$d$が偶数の時には，中心に隣接する点の集合を $A$ として， 各 $a \\in A$ を根とする (中心と反対方向の) 部分木の， 深さ $d/2 - 1$ の点の集合を $L_a$ と書くことにすれば， 各 $L_a$ から 1点または 0点を選んで赤く塗ることができます． ただし，全体として，部分木を2個以上選ばなくてはなりません． したがって答は，$m_a = |L_a|$ として， $\\prod_a (m_a + 1) - \\sum_a m_a - 1$ です．\n経緯 サンプルが通ったのが，終了5分前． 提出したらWAの山で，だめかなと思ったのですが， 偶然バグが見つかって，終了15秒前に通せました．ラッキー．\n","permalink":"https://yamate11.github.io/blog/posts/2021/10-03-abc221/","summary":"ABC221に参加して，ABCDEF 6完2ペナルティでした．その記録です．","title":"ABC 221 参加記"},{"content":"桁DPのコーディングに関する記事です． N 以下の整数で，ある条件を満たすものを数えます．\n参照 以下のoptさんの記事 をもとにして，少し追加しています:\n\rコーディングの方針  配るDP 表の更新を書く行は，ソース上で1箇所にする．  その桁に表れうる数 (0..9 とか 0..1 とか) をループで回し， 「この数を付け加えた時の格納先」を考える 格納先の添字を表す変数を，格納元で初期化して適宜変更する．   上位桁を 0-padding した状態で考える．  0以上N以下の数を数えることになる． 次のような場合は，すべてがゼロであることを表すフラグを使って対応する．  「左端の桁」の概念が出てくる 0以上ではなく，1以上を数える      #define REP(i, x) for (ll i = 0; i \u0026lt; (x); i++)  // N は各桁数値のベクトルで表現．ds[0] が最上位桁． // 問題文の都合で string にしても良い． vector\u0026lt;ll\u0026gt;\u0026amp; ds;  // DP表 tbl[eq][az][p1][p2]... // eq: 上限値に等しいかどうかを表すフラグ // az: 全部の桁がゼロ (all zero) かどうかを表すフラグ // p1やp2の計算に使わなければ省略して良い // 「最上位桁」を特別に扱う場合などに必要 // p1,p2... : 考えるべき性質 (問題に応じて変わる) vector tbl_init(2, vector(2, vector(??, vector(??, 0LL)))); auto tbl = tbl_init;  tbl[1][1][??][??] = 1 // 初期状態は，eq=1, az=1 for (auto d : ds) {  auto prev = move(tbl);  tbl = tbl_init;  REP(eq,2) REP(az,2) REP(p1,??) REP(p2,??) {  if (prev[eq][az][p1][p2] == 0) continue; // 性能的に重要かもしれない  REP(x,10) { // この桁で考える数  // eq, az, p1, p2 の新しい値 new_eq, new_az, new_p1, new_p2 を計算する  // たとえば new_p1 は，「直前の桁までで 性質 P1 の値が p1 であったとき，  // 次の桁として x を追加すると，P1 の値が new_p1 になる」もの．  if (eq \u0026amp;\u0026amp; x \u0026gt; d) continue;  ll new_eq = eq \u0026amp;\u0026amp; x == d;  ll new_az = az \u0026amp;\u0026amp; x == 0; // p1 などの計算に必要なら使う．  ll new_p1 = ....;  ll new_p2 = ....;  // 最後にテーブルを更新する  tbl[new_eq][new_az][new_p1][new_p2] += prev[eq][az][p1][p2];  }}} 問題集 \r\r","permalink":"https://yamate11.github.io/blog/posts/2021/07-06-digitdp/","summary":"桁DPのコーディングに関する記事です．N 以下の整数で，ある条件を満たすものを数えます．opt さんの記事をもとにしています．","title":"桁DPのコーディング"},{"content":"競技プログラミングのコードは，基本的には C++ で書いています． とても Python の方が書きやすいときには Python で書くこともありますが， ほとんどありません．\nいろいろな方がコーディングスタイルの話をされていて，参考にしました． ほとんど，今すぐ出てこないのですが， 競技プログラミングを始めた頃， koturnさんの記事 はとても勉強になりました．また， kimiyuki さんの記事 に書かれていることは，実施するようにしたことが多いです． (していないこともたくさんあります．) 以下，上記記事と多少重複しているところもあります．\n整数型は long long 整数型は，基本的には long long を使います． 例外はおおむね次のような感じです．\n bool で済む大きな vector で，スペースを節約したいとき (boolを使う) 64ビットフルに使うビット配列として用いるとき (unsigned long long を使う) ライブラリの中 (int や size_t も使う)  つまり，ループ変数なんかも，long long で回しています． int にすると必要な領域が半分になる，とか，ループがひょっとして 多少遅いかもしれない，とか思わないこともありませんが， ともかく「int を使わない」のを原則とすることで， うっかりオーバーフローをしてしまうのを避けようとしています．\nソース中では実際には，先頭に次の定義を置いて，ll と表記しています．\nusing ll = long long; また，基本的には，符号付きの変数を使います． たとえば (1) のようにと書くと警告が出ますが， (2) のように書き足してしのぎます． これは， これは，符号無し変数を使って，うっかり (3) の用に書いてしまう 間違いが怖いからです．\nfor (ll i = 0; i \u0026lt; vec.size(); i++) ... // (1) for (ll i = 0; i \u0026lt; (ll)vec.size(); i++) ... // (2) for (size_t i = N - 1; i \u0026gt;= 0; i--) .... // (3) ラムダ関数を使う 一部の処理をくくり出したいことが当然ありますが， 普通の関数(?)ではなく，ラムダ関数を使います．若干乱暴かもしれませんが， [\u0026amp;] を指定することで，その時点で有効な値を全部キャプチャしてしまいます．\nラムダ関数を使わないと， たとえば，入力に N, M, K がパラメータとして与えられている場合に， よく，以下のようなコードになります．\nint func(ll x, ll N, ll M, ll K, vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt;\u0026amp; A) {  ... }  int main() {  ll N, M, K; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M \u0026gt;\u0026gt; K;  vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; A(N);  for (ll i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; A[i];  ...  int t1 = func(x1, N, M, K, A);  int t2 = func(x2, N, M, K, A); } この，func の引数に N, M, K, A たちを渡すのが面倒に感じるのです． おうおうにして，int func (ll x) { くらいで書き始めて， 書いていくうちに，「あ，Nが要る」「あ，Aも要る」と書き足していく ことになりがちです． ちゃんと設計して書かないのがいかん，という批判は当然あると思いますが， 現実としてそうなので\u0026hellip;．\nラムダ関数を使えば以下のように書けるのでらくちんです．\nint main() {  ll N, M, K; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M \u0026gt;\u0026gt; K;  vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; A(N);  for (ll i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; A[i];  ...  auto func = [\u0026amp;](ll x) -\u0026gt; ll {  ... // N, M, K, A その他にアクセスできる．変更も可．  };  ll t1 = func(x1, N, M, K, A);  ll t2 = func(x2, N, M, K, A); } よく最後のセミコロンを書き忘れてコンパイルやり直しますが．\n再帰関数はちょっと書き方がトリッキーですが， 慣れれば手が勝手に動きます(?)．\n ...  auto dfs = [\u0026amp;](auto f, ll node) -\u0026gt; void {  // 引数の先頭に auto f と書いておく  // 再帰関数の時には復帰値型 (この場合は void) が省略不可  ...  for (ll child : children[node]) {  f(f, child); // 再帰呼び出し  }  };  dfs(dfs, 0); // 関数 dfs の呼び出し．f には dfs 自身を渡す．  ... めったにありませんが，相互再帰の例:\n auto isOdd_rep = [\u0026amp;](auto f, ll x) -\u0026gt; bool {  if (x == 0) return false;  return ! f(f, x - 1); // f には isEven を入れて呼んでいる．  };  auto isEven_rep = [\u0026amp;](auto f, ll x) -\u0026gt; bool {  if (x == 0) return true;  return ! isOdd_rep(f, x - 1); // ここは isOdd_rep を呼ぶ．  };  auto isOdd = [\u0026amp;](ll x) -\u0026gt; bool { return isOdd_rep( isEven_rep, x); }  auto isEven = [\u0026amp;](ll x) -\u0026gt; bool { return isEven_rep(isEven_rep, x); }   assert(isOdd(5) == true);  assert(isEven(6) == true); もちろん，isOdd などを定義せずに，直接 isOdd_rep(isEven_rep, 5) などと呼び出しても良いです．\nデバッグ出力 ときどき，「デバッグ用の printf を消し忘れてWA」という話を聞きます． 私は注意力散漫なので，なにかしないと絶対やってしまうにきまっているので， 対策しています．\n コンパイルは，必ず make で行う． ソースファイル名は固定 (cans.cc にしている)． Makefile を次のように書いておく:  単に make を実行すると，識別子 DEBUG の値が真で， 識別子 _GLIBCXX_DEBUG が定義 された状態でコンパイルされる．その他，-g と -O0 も指定される． make DEBUG=  で実行すると，上記識別子は定義されず，-O2 で コンパイルされる．   デバッグ用のライブラリを用意する:  識別子 DEBUG の値が真ならば，DLOGK() などのマクロが 定義される．DLOGK(e) などと呼び出すと，「e」という文字列と eの値が，標準エラー出力に出力される． 識別子 DEBUG が定義されていない状況では，デバッグ出力は 行われない．    識別子 _GLIBCXX_DEBUG は，C++ の STL をデバッグモードで動かすことを 指示するものです．これが定義されていると，vector のサイズを超えた アクセスなどがエラーとして報告されて，便利です． gdb を使えばソース上の位置などもわかります．\nこうしておくと，ソースを修正することなく， 手元では，デバッグ出力などが見えますし，提出先では DEBUG という識別子は定義されていないので，出力されません． また，標準エラー出力に出力しているので，想定回答との比較を行う プログラムで標準出力だけを見るようにすれば，デバッグ出力があっても (速度を除けば)問題無く機能します．速度に問題がある場合には make clean; make DEBUG=  でコンパイルし直します．\nあまりきれいじゃないかもしれませんが，コードです:\nMakefile (GNU make用):\nCXX := g++  ifeq ($(DEBUG),)  DEBUGFLAGS := -O2 else  DEBUGFLAGS := -g -O0 -D_GLIBCXX_DEBUG -DDEBUG=1  ifneq ($(DEBUG_LIB),)  DEBUGFLAGS := $(DEBUGFLAGS) -DDEBUG_LIB=1  endif endif  WARNINGS := -Wall -Wno-format-security -Wshadow -fconcepts CXXFLAGS := -std=gnu++17 $(DEBUGFLAGS) $(WARNINGS) CXXFLAGS := $(CXXFLAGS) -I/full/path/to/ac-library  all: cans  clean: \t$(RM) cans.o cans DLOGKなどの定義\ntemplate \u0026lt;class Head\u0026gt; void dbgLog(bool with_nl, Head\u0026amp;\u0026amp; head) {  cerr \u0026lt;\u0026lt; head;  if (with_nl) cerr \u0026lt;\u0026lt; endl; }  template \u0026lt;class Head, class... Tail\u0026gt; void dbgLog(bool with_nl, Head\u0026amp;\u0026amp; head, Tail\u0026amp;\u0026amp;... tail) {  cerr \u0026lt;\u0026lt; head \u0026lt;\u0026lt; \u0026#34; \u0026#34;;  dbgLog(with_nl, forward\u0026lt;Tail\u0026gt;(tail)...); }  #if DEBUG  #define DLOG(...) dbgLog(true, __VA_ARGS__) #else  #define DLOG(...) #endif  #define DUP1(E1) #E1 \u0026#34;=\u0026#34;, E1 #define DUP2(E1,E2) DUP1(E1), DUP1(E2) #define DUP3(E1,...) DUP1(E1), DUP2(__VA_ARGS__) #define DUP4(E1,...) DUP1(E1), DUP3(__VA_ARGS__) #define DUP5(E1,...) DUP1(E1), DUP4(__VA_ARGS__) #define DUP6(E1,...) DUP1(E1), DUP5(__VA_ARGS__) #define DUP7(E1,...) DUP1(E1), DUP6(__VA_ARGS__) #define DUP8(E1,...) DUP1(E1), DUP7(__VA_ARGS__) #define DUP9(E1,...) DUP1(E1), DUP8(__VA_ARGS__) #define DUP10(E1,...) DUP1(E1), DUP9(__VA_ARGS__) #define DUP11(E1,...) DUP1(E1), DUP10(__VA_ARGS__) #define DUP12(E1,...) DUP1(E1), DUP11(__VA_ARGS__) #define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12,NAME,...) NAME #define DUP(...) GET_MACRO(__VA_ARGS__, DUP12, DUP11, DUP10, DUP9, DUP\\ 8, DUP7, DUP6, DUP5, DUP4, DUP3, DUP2, DUP1)(__VA_ARGS__) #define DLOGK(...) DLOG(DUP(__VA_ARGS__)) #define DLOGKL(lab, ...) DLOG(lab, DUP(__VA_ARGS__)) ","permalink":"https://yamate11.github.io/blog/posts/2021/09-23-coding-style/","summary":"自分のコーディングスタイルについてです","title":"コーディングスタイル"},{"content":"stream の書式関連 参照: https://www.cs.fsu.edu/~myers/c\u0026#43;\u0026#43;/notes/formatting.html  stringstream は，str() メンバ関数で文字列になる．   stringstream ss;  ss \u0026lt;\u0026lt; 100; assert(ss.str() == \u0026#34;100\u0026#34;);  16進表記は hex．10進表記(にもどす)は dec．大文字/小文字は [no]uppercase．   stringstream ss;  ss \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; 253 \u0026lt;\u0026lt; uppercase \u0026lt;\u0026lt; 254 \u0026lt;\u0026lt; nouppercase \u0026lt;\u0026lt; 255;  ss \u0026lt;\u0026lt; dec \u0026lt;\u0026lt; 100;  assert(ss.str() == \u0026#34;fdFEff100\u0026#34;);  小数点以下の桁数は setprecision で制御   stringstream ss;  double x = 1.0 / 3.0;  ss \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; setprecision(20) \u0026lt;\u0026lt; x;  assert(ss.str() == \u0026#34;0.333333 0.33333333333333331483\u0026#34;);  0詰めは setfill, 表示幅は，setw で制御   stringstream ss, ss1;  ss \u0026lt;\u0026lt; setw(4) \u0026lt;\u0026lt; 10 \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; setw(4) \u0026lt;\u0026lt; (int)1e8;  assert(ss.str() == \u0026#34; 10,100000000\u0026#34;);  ss1 \u0026lt;\u0026lt; setfill(\u0026#39;0\u0026#39;) \u0026lt;\u0026lt; setw(4) \u0026lt;\u0026lt; 10 \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; setw(4) \u0026lt;\u0026lt; (int)1e8;  assert(ss1.str() == \u0026#34;0010,100000000\u0026#34;);  ほとんどの manipulator は sticky (効果が持続) だが， setw は例外．   stringstream ss1, ss2;  ss1 \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; 100 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; 200;  assert(ss1.str() == \u0026#34;64 c8\u0026#34;);  ss2 \u0026lt;\u0026lt; setw(4) \u0026lt;\u0026lt; 5 \u0026lt;\u0026lt; 6;  assert(ss2.str() == \u0026#34; 56\u0026#34;); 例外  型宣言: struct Exc : exception {}; 投げる: throw Exc(); 受ける: try { ... } catch(const Exc\u0026amp; e) { ... }  使用例\n struct Exc : exception {};  auto all_non_zero = [\u0026amp;](string s) -\u0026gt; bool {  auto dfs = [\u0026amp;](auto f, size_t i) -\u0026gt; void {  if (i == s.size()) return;  if (s[i] == \u0026#39;0\u0026#39;) throw Exc();  f(f, i + 1);  };  try {  dfs(dfs, 0);  return true;  }catch (const Exc\u0026amp; e) {  return false;  }  };  assert(all_non_zero(\u0026#34;11111\u0026#34;));  assert(! all_non_zero(\u0026#34;11101101\u0026#34;)); ビット処理 long long に対するもの．\n 1の数を数える \u0026ndash; __builtin_popcountll   assert(__builtin_popcountll(0xF) == 4);  assert(__builtin_popcountll(0x100030007000F000) == 10);  右端の0の数 \u0026ndash; __builtin_ctzll  Count Trailing Zero であろう． __builtin_ctzll(x) は，x の LSB の添字に等しい． 引数は0ではいけない．     assert(__builtin_ctzll(0x1) == 0);  assert(__builtin_ctzll(0x8) == 3);  assert(__builtin_ctzll(1LL\u0026lt;\u0026lt;63) == 63);  左端の0の数 \u0026ndash; __builtin_clzll  Count Leading Zero であろう． __builtin_clzll(x) は，63 - (x の MSB の添字) に等しい 引数は0ではいけない．     assert(__builtin_clzll(0x1) == 63);  assert(__builtin_clzll(1LL\u0026lt;\u0026lt;62) == 1); vector での 重複の削除 Unix の， sort | uniq に相当する操作\n vector\u0026lt;int\u0026gt; vec({10, 2, 5, 7, 5, 2, 5});  sort(vec.begin(), vec.end());  vec.erase(unique(vec.begin(), vec.end()), vec.end());  assert(vec == vector\u0026lt;int\u0026gt;({2, 5, 7, 10})); イタレータ iterator は，「要素を指す」と考えるより「要素と要素の間を指す」 と考えた方が話が分かりやすい．\n vector\u0026lt;int\u0026gt; vec({2, 4, 5, 5, 5, 6, 10, 12});  auto it1 = lower_bound(vec.begin(), vec.end(), 5);  auto it2 = upper_bound(vec.begin(), vec.end(), 5);  auto it3 = lower_bound(vec.begin(), vec.end(), 11);  auto it4 = upper_bound(vec.begin(), vec.end(), 11); 逆方向イタレータ reverse_iterator\u0026lt;decltype(it)\u0026gt;(it) で， it の指している「要素間の位置」は変わらずに，方向だけが反転する． 上図で，5以下の要素を並べるコード:\n stringstream ss;  vector\u0026lt;int\u0026gt; vec({2, 4, 5, 5, 5, 6, 10, 12});  auto itN = upper_bound(vec.begin(), vec.end(), 5);  for (auto itR = reverse_iterator\u0026lt;decltype(itN)\u0026gt;(itN);  itR != vec.rend(); itR++) {  ss \u0026lt;\u0026lt; *itR;  }  assert(ss.str() == \u0026#34;55542\u0026#34;); set や map などに対しても，同様のことができる．\n stringstream ss;  multiset\u0026lt;int\u0026gt; is({2, 4, 5, 5, 5, 6, 10, 12});  auto itN = is.upper_bound(5);  for (auto itR = reverse_iterator\u0026lt;decltype(itN)\u0026gt;(itN);  itR != is.rend(); itR++) {  ss \u0026lt;\u0026lt; *itR;  }  cout \u0026lt;\u0026lt; ss.str() \u0026lt;\u0026lt; endl;  assert(ss.str() == \u0026#34;55542\u0026#34;); set や priority queue の比較関数 集合 (set) のテンプレートの第2引数が比較クラスになる． イタレータが降順に動いていってほしい場合，次のように書けば良い．\nset\u0026lt;T, greater\u0026lt;T\u0026gt;\u0026gt; ss; 一般の比較関数 fn を書きたいときには，次のようにする．\nset\u0026lt;T, decltype(fn)\u0026gt;\u0026gt; ss(fn); 優先度付きキューを普通に次のように書くと降順になる:\npriority_queue\u0026lt;T\u0026gt; pque; 昇順にしたいときには，次のように書く:\npriority_queue\u0026lt;T, vector\u0026lt;T\u0026gt;, greater\u0026lt;T\u0026gt;\u0026gt; pque; 一般の比較関数 fn を書きたいときには，次のようにする． 指定した比較関数の「大きい」順に取り出される． つまり，fn(x, y) が真の時には，yがxより先に取り出される．\npriority_queue\u0026lt;T, vector\u0026lt;T\u0026gt;, decltype(fn)\u0026gt; pque(fn); 例:\n using Pair = pair\u0026lt;int, int\u0026gt;;  auto comp = [\u0026amp;](Pair x, Pair y) -\u0026gt; bool {  if (x.first != y.first) return x.first \u0026lt; y.first;  else return x.second \u0026gt; y.second;  };  priority_queue\u0026lt;Pair, vector\u0026lt;Pair\u0026gt;, decltype(comp)\u0026gt; pque(comp);   pque.emplace(2, 1); pque.emplace(3, 5), pque.emplace(3, 9);  Pair p;  p = pque.top(); pque.pop(); assert(p == Pair(3, 5));  p = pque.top(); pque.pop(); assert(p == Pair(3, 9));  p = pque.top(); pque.pop(); assert(p == Pair(2, 1)); ","permalink":"https://yamate11.github.io/blog/posts/2021/09-20-cpp-syntax-misc/","summary":"C++言語や，C++ Standard Template Library の書き方で，忘れやすいものをメモしておくページです．","title":"C++言語・STLメモ"},{"content":"AtCoder Beginner Contest 218 (ABC 218) H - Red and Blue Lamps に関する記事です． コンテストでは解けませんでした (到達しませんでした) し， 後で考えても分かりませんでした． まだ公式解説の3つの解法のうち，最初のしか読んでいませんが， 正当性証明が良く分からなかったので，少し詳しく書きます．\n問題概要 2以上の整数N, 正の整数Rと 正の整数の列 (A_i : i ∈ [1,N-1])が与えられる． X ⊆ [1,N] を，|X| = R となるようにとるとき， S := \\sum { A_i : i と i+1 のうち片方のみが X に属する．} の最大値を求めよ．  制約: N \u0026lt;= 2×10^5, A_i \u0026lt;= 10^9 問題へのリンク 解法 R \u0026gt; N/2 なら，X の代わりに [1,N] - X を考えれば良いので，R \u0026lt;= N/2 として 良い．\ni と i+1 が X に属しているような i は，無いとして良い．\n理由: そういうものがあったとする． R \u0026lt;= N/2 なので，以下のいずれかが成り立つ\n $1 \\not\\in X$ $N \\not\\in X$ $j \\not\\in X$, $j + 1 \\not\\in X$ なる $j$ がある．  どの場合も同様なので，3番目が成り立つ場合のみ扱う． これをみたす $j$ を1つとる．以下のいずれかが成り立つ．\n $i+1 \u0026lt; j$, $i\\in X$, $i+1\\in X$ なる $i$ がある． $j+1 \u0026lt; i$, $i\\in X$, $i+1\\in X$ なる $i$ がある．  どちらも同様なので，上が成り立つ場合のみ扱う．これを満たす最大の $i$ を とる．\n$i+1$ を $X$ から取り除き，$i+2$ を $X$ に加える．$i+3\\in X$ なら終了． そうでなければ $i+3$ を $X$ から取り除き，$i+4$ を $X$ に加える． 以下同様にこの操作をできるだけ繰り返す． 遅くとも $j$ に到達するまでに，この操作は終了する． この操作によって，Sの値は増加し，|X|の 値は変化しない． (理由終わり)\n$i \\in [1,N]$ に対して，$B_i := A_{i-1} + A_{i}$ とする (ただし，$A_0 := A_N := 0$)． 上のことから，問題を次のように言い換えられる: $|X| = R$ なる $X \\subseteq [1, N]$ を，どの $i\\in [1,N-1]$ に対しても $i\\not\\in X$ と $i+1\\not\\in X$ のすくなくともどちらかが成り立つように 取るとき，$S(X) := \\sum_{i \\in X} B_i$ の最大値を求めよ．\n記法として，$r - l$ が偶数の時， $E(l, r) := \\{l, l + 2, \\ldots, r - 2, r\\}$ と書くことにする． 特に $E(l, l) = \\{l\\}$．また，$l \u0026gt; r$ のとき，$E(l, r) = \\varnothing$．\n主張1 $X$ が $R$ に対する最大値を与える選択方法， $Z$ が $R + 1$ に対する最大値を与える選択方法であり， 区間$I = [p, q]$ について $|X\\cap I| + 1 = |Z\\cap I|$ であり， $p \\not\\in X, q \\not\\in X, p \\not \\in Z, q \\not\\in Z$ とする． $J := [1, N] \\setminus I$ とするとき， $Y := (X \\cap J) \\cup (Z \\cap I)$ は，$R + 1$ に対する最大値を与える 選択方法である．\n証明 $|Y| = R+1$ であることと，$i\\in Y, i+1\\in Y$ となる $i$ が存在しない ことは明らかであるから， $S(X \\cap J) \\geq S(Z \\cap J)$ を言えば良いが，そうでないとすると， $X\u0026rsquo; := (Z \\cap J) \\cup (X \\cap I)$ が，$R$ に対して $X$ よりも 良い解を与えることになってしまい，矛盾する． (終)．\n主張2 $X$ が $R$ に対する最大値を与える選択方法であるとき， $R+1$ に対する最大値を与える選択方法 $Y$ で，次のようなものが存在する: $l, r \\in [1, N]$ で，$l \\leq r$ かつ $r - l$ が偶数となるものが存在して， 以下が成り立つ．\n $[1, l)$ と $(r, N]$ では，$X$ と $Y$ は一致する．すなわち， $ J := [1, l) \\cup [r, N] $ と書くとき，$X \\cap J = Y \\cap J$ $X \\cap [l, r] = E(l + 1, r - 1)$ $Y \\cap [l, r] = E(l, r)$  証明 $R+1$に対する最大値を与える選択方法 $Z$ を1つとる． $X\\cap Z$ = $\\{t_1, \\ldots, t_k\\}$ と書いて，区間 $[1, t_1), (t_1, t_2), \\ldots, (t_k, N]$ を考える．これらの区間の 少なくとも一つ $I$ においては，$|X\\cap I| \u0026lt; |Z\\cap I|$ が成り立つ． $Z\\cap I = \\bigcup_{i = 1}^{m} E(l_i, r_i) $; ただし，$l_i \\leq r_i$，$r_{i} +3 \\leq l_{i+1}$ と書いたとき， $[l_i - 1, r_i + 1]$ たちは共通部分を持たないので， $|[l_i - 1, r_i + 1] \\cap X| \u0026lt; |[l_i - 1, r_i + 1] \\cap Z|$ となる $i$ が存在する． ここで，$[l_i - 1, r_i + 1] \\cap Z = E(l_i, r_i)$ であるから， $p + 2 \\leq q$ なる $p, q \\in E(l_i - 1, r_i + 1) \\setminus X $ をとることができ， さらに，$[p + 2, q - 2] \\cap X = E(p + 2, q - 2)$ とすることができる． $ l := p + 1 $, $r := q - 1$, $ Y := (X \\cap J) \\cup E(l, r)$ とする．各種関係式は，それが成り立つようにとった． $Y$ が $R+1$に対する最大値を与える選択方法であることは，主張1から従う． (終)．\nしたがって，以下のように貪欲に取っていけば良い．\n 最初は，$E(i,i)$ たちが候補になる．実際に取るのは，これらのうち， 値が最大のもの 最初の $E(i_0, i_0)$ が決まったら，新たに $E(i_0 - 1, i_0 + 1)$ が 候補になる．この候補に対する得点は， $S(E(i_0 - 1, i_0 + 1)) - S(E(i_0, i_0))$ である． 一般に，$E(l, r)$ を取ることが決まったら，新たに $E(l - 1, r + 1)$ が候補になる．ただし，たとえば，すでに $E(r + 1, m)$ が候補になっているときには， $E(r + 1, m)$ は候補から外され， $E(l - 1, r+ 1)$ ではなく，$E(l - 1, m)$ が新たな候補になる． 左側についても同様．  候補とその得点のペアを (得点を優先度として) 優先度付きキューで 管理し，各端点がどの端点との組で候補になっているかをベクトルで 管理することで，全体として $O(R \\log N)$ で答が求められる．\nACコード https://atcoder.jp/contests/abc218/submissions/25850606 int main(/* int argc, char *argv[] */) {  ios_base::sync_with_stdio(false);  cin.tie(nullptr);  cout \u0026lt;\u0026lt; setprecision(20);   ll N, R; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; R;  if (R \u0026gt; N / 2) R = N - R;  vector\u0026lt;ll\u0026gt; A(N+1), B(N), P(N);  for (ll i = 1; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; A[i];  for (ll i = 0; i \u0026lt; N; i++) B[i] = A[i] + A[i + 1];  using sta = tuple\u0026lt;ll, ll, ll\u0026gt;;  priority_queue\u0026lt;sta\u0026gt; pque;  for (ll i = 0; i \u0026lt; N; i++) {  P[i] = i;  pque.emplace(B[i], i, i);  }  ll ans = 0, cnt = 0;  while (true) {  auto [m, p, q] = pque.top(); pque.pop();  if (P[p] != q || P[q] != p) continue;  ans += m;  if (++cnt == R) break;  assert(! (q == N-1 \u0026amp;\u0026amp; p == 0));  if (q == N-1) {  assert(p - 1 \u0026gt;= 0);  P[p - 1] = -1;  }else if (p == 0) {  assert(q + 1 \u0026lt; N);  P[q + 1] = -1;  }else {  ll u = P[p - 1];  ll v = P[q + 1];  ll new_m = B[u] + B[v] - m;  pque.emplace(new_m, u, v);  P[u] = v;  P[v] = u;  B[u] = B[v] = new_m;  }  }  cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;   return 0; } ","permalink":"https://yamate11.github.io/blog/posts/2021/09-13-abc218-h-red-and-blue-lamps/","summary":"公式解説にある貪欲法の証明を詳しく書きました．","title":"Red and Blue Lamps - AtCoder Beginner Contest 218 H"},{"content":"AtCoder Beginner Contest 218 - ABC 218 - C Shapes についてです．\n問題概要 問題へのリンク 2次元グリッドの，文字 # で示された2つの図形がある． 回転と平行移動で一致するかどうか判定せよ．\n制約: グリッドサイズ \u0026lt;= 200．\n経緯 コンテストでは，解けたのですが，30分以上かかりました． S と T の bounding box を作って，0, 90, 180, 270 の各度の回転で 一致するかどうかの判定をしました．\nこの手の，特別な考察が必要ではないけれど，たくさんコードを書かなければ 問題で，速く解答できるようになるには，どうすればよいのでしょうか? 今回の反省点は:\n 公式解説 にも あるように，bounding box を作るより，全体を回転した上で， 左上の # の位置を比較して 平行移動量を決めた方が簡単でした． 回転で一致するかどうかを，添字を動かす方向を変えることで調べたのですが， 実際に回転したデータを作ってしまった方が簡単でした．  ACコード ライブラリに回転を実行する関数を 追加した後のコードです．ライブラリ部分は省略しています． 全ソースは https://atcoder.jp/contests/abc218/submissions/25806964 にあります．\nint main(/* int argc, char *argv[] */) {  ios_base::sync_with_stdio(false);  cin.tie(nullptr);  cout \u0026lt;\u0026lt; setprecision(20);   auto solve = [\u0026amp;]() -\u0026gt; bool {  ll N; cin \u0026gt;\u0026gt; N;  Board\u0026lt;char\u0026gt; S(N, N, \u0026#39;.\u0026#39;); cin \u0026gt;\u0026gt; S;  Board\u0026lt;char\u0026gt; T(N, N, \u0026#39;.\u0026#39;); cin \u0026gt;\u0026gt; T;   auto left_top = [\u0026amp;](const auto\u0026amp; B) -\u0026gt; BrdIdx {  auto p = [\u0026amp;](auto\u0026amp; bi) -\u0026gt; bool { return B.at(bi) == \u0026#39;#\u0026#39;; };  return *find_if(ALL(BoardRange(B)), p);  };   BrdIdx biT = left_top(T);  return any_of(ALL(ItRange(0, 4)), [\u0026amp;](ll i) -\u0026gt; bool {  auto SS = S.rotate(i);  BrdIdx diff = left_top(SS) - biT;  return all_of(ALL(BoardRange(T)), [\u0026amp;](auto\u0026amp; bi) -\u0026gt; bool {  return SS.at(bi + diff) == T.at(bi) \u0026amp;\u0026amp; SS.at(bi) == T.at(bi - diff);  });  });  };  cout \u0026lt;\u0026lt; (solve() ? \u0026#34;Yes\u0026#34; : \u0026#34;No\u0026#34;) \u0026lt;\u0026lt; endl;  return 0; } ","permalink":"https://yamate11.github.io/blog/posts/2021/09-12-abc218-shapes/","summary":"重実装への対処は，どうしたらよいのでしょうか?","title":"Shapes -- AtCoder Beginner Contest 218 C"},{"content":"AtCoder Beginner Contest 217 - ABC 217 H - Snuketoon の解法です． slope trick を使う公式解説そのままです．\n問題概要  問題へのリンク   変数 P, S がある．時刻0には P = S = 0． 時刻1, 2, 3, ... に P に +1/-1/0 のいずれかを加えることができる． 列 ((T_i, D_i, X_i) : i ∈ [1, N]) が与えられる． T_i は単調増加する正の整数，D_i は 0または1，X_i は整数． 時刻 T_i (Pの値の変化後) において，S に dmg(P, i) を加える．ただし，  dmg(P, i) = max(0, X_i - P) (D_i = 0 のとき)  max(0, P - X_i) (D_i = 1 のとき) S を最小化するように P を変化させよ． 制約: N \u0026lt;= 2e5, 1 \u0026lt;= T_1 \u0026lt; T_2 \u0026lt; ... \u0026lt; T_N \u0026lt;= 1e9, | X_i | \u0026lt;= 1e9 解法  公式解説へのリンク   次の自然なDPが考えられますが，状態空間が大きすぎて間に合いません．\n 定義: dp[i][p] := 時刻 T_i において P = p の時の S の最小値 遷移: dp[i][p] := dmg(p, i) + min { dp[i-1][q] : | q - p | \u0026lt;= T_i - T_{i+1} }  関数 f_i(p) := dp[i][p] が，各 i に対して， 折れ線凸関数になることを利用します． 折れ線凸関数は，次の3つで特徴付けられます．\n 最小値 min(f) 傾きが 0→1, 1→2, \u0026hellip; と変化する点のリスト pos(f) 傾きが -1→0, -2→-1, \u0026hellip; と変化する点のリスト neg(f)  今回の問題の場合，次を実施すれば良いです．\n T_{i-1} から T_i までの時間経過の間に，t := T_i - T_{i-1} だけ 移動できます．これに対応して，pos(f) の各点が t だけ右に移動し， neg(f) の各点が t だけ左に移動します． dmg(p, i) が加えられることに対応して，X_i を pos(f) なり neg(f) なり の適切な位置に挿入します．さらに，  D_i = 1 で neg(f) に X_i を挿入した場合には，neg(f) の先頭を pos(f) の先頭に移します． D_i = 0 で pos(f) に X_i を挿入した場合には，pos(f) の先頭を neg(f) の先頭移します． これらの場合には，min(f) も適切に更新します．たとえば，pos(f) が {x0, x1, \u0026hellip; } だったときに，D_i = 0 で pos(f) に q が挿入されたとすると， x0 を neg(f) に移すとともに，min(f) に q - x0 を加えます．    第1点の移動を愚直に行うと間に合いませんので，移動距離を覚えておくだけにして， 先頭を移す操作や，X_i を挿入する操作の際には，移動距離を考慮に入れます．\nf_N の最小値が求める答です．\n実装は，pos(f) と neg(f) に優先度キューを用いました． 時刻 0 における f は，f(0) = 0 で，p != 0 のときには，f(p) = ∞ になっていてほしいです． これは，pos(f) と neg(f) の初期値が (0,0,0,\u0026hellip;) であることを意味します． しかし，実際にたくさんの0を入れてしまっては効率が悪いので， 0 はpopしないことで対処しました．\nACコード #include \u0026lt;bits/stdc++.h\u0026gt;#include \u0026lt;cassert\u0026gt;typedef long long int ll; using namespace std;  int main(/* int argc, char *argv[] */) {  ios_base::sync_with_stdio(false);  cin.tie(nullptr);  cout \u0026lt;\u0026lt; setprecision(20);   ll N; cin \u0026gt;\u0026gt; N;  ll minf = 0;  priority_queue\u0026lt;ll, vector\u0026lt;ll\u0026gt;, greater\u0026lt;ll\u0026gt;\u0026gt; posf;  priority_queue\u0026lt;ll\u0026gt; negf;  ll shift = 0;  auto push_pos = [\u0026amp;](ll x) -\u0026gt; void { if (x \u0026lt; shift) posf.push(x - shift); };  auto push_neg = [\u0026amp;](ll x) -\u0026gt; void { negf.push(x + shift); };  auto top_pos = [\u0026amp;]() -\u0026gt; ll { return posf.top() + shift; };  auto top_neg = [\u0026amp;]() -\u0026gt; ll { return negf.top() - shift; };  auto pop_pos = [\u0026amp;]() -\u0026gt; void { if (posf.top() != 0) posf.pop(); };  auto pop_neg = [\u0026amp;]() -\u0026gt; void { if (negf.top() != 0) negf.pop(); };  posf.push(0);  negf.push(0);  for ( ; N \u0026gt; 0; N--) {  ll t, d, x; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; d \u0026gt;\u0026gt; x;  shift = t;  if (d == 0) {  ll y = top_pos();  if (x \u0026lt;= y) {  push_neg(x);  }else {  minf += x - y;  push_pos(x);  pop_pos();  push_neg(y);  }  }else if (d == 1) {  ll y = top_neg();  if (y \u0026lt;= x) {  push_pos(x);  }else {  minf += y - x;  push_neg(x);  pop_neg();  push_pos(y);  }  }  }  cout \u0026lt;\u0026lt; minf \u0026lt;\u0026lt; endl;   return 0; } ","permalink":"https://yamate11.github.io/blog/posts/2021/09-05-abc217-h-snuketoon/","summary":"slope trick というのは忘れていましたが，そもそもHまで到達しませんでした．この記事は公式解説そのままです．","title":"Snuketoon - ABC217 H"},{"content":"「牛ゲー」なる手法のまとめです． ABC216 G - 01Sequence で出てきました．\n適用できる問題 $(c_{ij} \\mid i, j \\in [1, N])$ と，$S, T \\in [1, N]$ が与えられる． 変数 $x_1, \\ldots, x_N$ に対する制約\n $x_i - x_j \\leq c_{ij}$  のもとで，$ x_T - x_S $ の最大値を求めよ．\n解法 集合 $\\{1, .., N\\}$ 上に，$i$ から $j$ に距離 $c_{ij}$ の辺がある グラフを考える． 以下のようになる (参照 ):\n 制約を満たす解がある $\\Leftrightarrow$ グラフに負閉路がない グラフに負閉路がない場合:  $ x_T - x_S $ の最大値がない (いくらでも大きくできる) $\\Leftrightarrow$ $T$ は $S$ から到達できない   グラフに負閉路がなく，$T$ が $S$ から到達できる場合  $ x_T - x_S $ の最大値は，グラフ上の $S$ から $T$ への最短路長に一致する．    最後の行が重要．特に，全部の $c_{ij}$ が非負なら， ダイクストラで解ける．\n","permalink":"https://yamate11.github.io/blog/posts/2021/08-30-ushi-game/","summary":"「牛ゲー」なる手法のまとめです","title":"「牛ゲー」"},{"content":"AtCoder Beginner Contest 216 (ABC216) G - 01Sequence の解法です． 公式解説 によると 「牛ゲー 」で解けるとのことですが，別の (より効率が悪い) 方法で解きました．\n問題へのリンク https://atcoder.jp/contests/abc216/tasks/abc216_g 問題概要 $N$ と $(L_i, R_i, X_i)$ ($i = 1, \\ldots , M$) が与えられる． 長さ$N$の0と1からなる数列 $(A_i \\mid i \\in [1, N])$ で， 条件 $ | \\{ i \\in [L_i, R_i] \\mid A_i = 1 \\}| \\geq X_i $ を満たすもののうち， 1の数が最小のものを一つ作れ．\n制約: $ N, M \\leq 2 \\times 10^5 $\n解法 0の数の条件に書き換える．$Y_i := R_i - L_i + 1 - X_i$ として， 条件 $ | \\{ i \\in [L_i, R_i] \\mid A_i = 0 \\}| \\leq Y_i $ のもとで， 全体の0の数を最大にする．\n$S_j := \\{ i \\in [1, M] \\mid L_i \\leq j \\leq R_i \\}$　と書く．\n$A_0, A_1, \\ldots$ の順に $A_i$ の値を，貪欲に 0 を 置くように決めていくことができる．理由は以下の通り． 今，$A$ が条件を満たすとする．$i \\in S_j$ に対し，\n$ t(i, j) := | \\{ k \\in [L_i, j) \\mid A_k = 0 \\} |$\nと書く．ある $j\\in [1, N]$ について，$A_j = 1$ であり，しかも すべての $i \\in S_j$ について $t(i, j) \u0026lt; Y_i$ であったとする．この次に$A$の値が0となる添字を $k$ とする， すなわち，$A_{k} = 0$ で，すべての $l \\in [j, k)$ に対して $A_l = 1$ とする．このとき，$A_j$ と $A_{k}$ の 0/1 を入れ替えた列も，条件を満たす． そのような $k$ が存在しないときは，単に $A_j$ の値を 0 にした列が 条件を満たす．\nしたがって，次の構成を行えば良い: $A_0, \\ldots, A_{j-1}$ まで決めたとして，$A_j$ を定める．\n すべての $i \\in S_j$ について，$t(i, j) \u0026lt; Y_i$ のとき，$A_j = 0$ そうでないとき，$A_j = 1$  イベントソートを用いて，次のようにすれば良いように考えられる．\n 初期時点 $j = -1$ では，すべての $i$ に対し，その残り容量は $\\infty$ である． 時点$j$ において，  $j = L_i$ となる $i$ の残り容量を $Y_i$ に設定する． $j = R_i$ となる $i$ の残り容量を $\\infty$ に設定する． 残り容量が 0 である $i$ がある場合，  $A_i := 1$ と定める．   残り容量が 0 である $i$ がない場合，  $A_i := 0$ と定める． 全部の $i$ の残り容量を 1 減らす．      しかし，全部の残り容量を愚直に減らしていては間に合わない． 代わりに， 「自分の区間が終わるまでに，0の累積個数 $n$ がいくつ以下でなければならない」 という量 $Z_i$ を持つことにする．\n 初期時点 $j = -1$  すべての $i$ に対し，$ Z_i := \\infty $ $n := 0$   時点$j$ において，  $j = L_i$ となる $i$ に対し，$ Z_i := n + Y_i $ $j = R_i$ となる $i$ に対し，$ Z_i := \\infty $ $Z_i$ たちの最小値が $n$ である場合:  $A_i := 1$   $Z_i$ たちの最小値が $n$ より大きい場合:  $A_i := 0$ $n := n + 1$      これは，$Z_i$ を優先度キューで管理することで実装できる．\nACコード https://atcoder.jp/contests/abc216/submissions/25452502 ","permalink":"https://yamate11.github.io/blog/posts/2021/08-30-abc216g-01sequence/","summary":"公式解説とは違う (より効率の悪い) 方法で解きました．","title":"01Sequence - ABC216 G"},{"content":"AtCoder Beginner Contest 214 - ABC 214 G - Three Permutations の解法です．\n解説ACです． 公式解説 も参考になりましたが，それだけでは解答は作れませんでした． kmjpさんのブログ が助けになりました．ありがとうございます．\n問題へのリンク https://atcoder.jp/contests/abc214/tasks/abc214_g 問題概要 $1, \\ldots, N$ の順列の全体を $\\textrm{Perm}$ と書く． $p, q \\in \\text{Perm}$ が与えられる． 条件「$x = p(i)$ または $x = q(i)$」を，$\\text{Coi}(x, i)$ と書く ことにする． $r \\in \\text{Perm}$ に対して， $C(r) := \\{ i \\in [1, N] \\mid \\text{Coi}(r(i), i) \\}$ とする． 集合 $\\{r \\in \\text{Perm} \\mid C(r) = \\varnothing \\}$ の要素数を mod $10^9 + 7$ で求めよ．\n解法 $r \\in \\text{Perm}$， $X \\subseteq [1, N]$， $k \\in [0, N]$ に対して，次のように書くことにする:\n $S(X) := \\{r \\in\\text{Perm} \\mid X \\subseteq C(r) \\}$ $R_k := \\sum \\{ |S(X)| \\mid X \\subseteq [1, N],\\; |X| = k \\}$ $r \\downarrow X := r$ の定義域を $X$ に制限したもの $\\text{Perm}\u0026rsquo;(X) := \\{ r \\downarrow X \\mid r \\in \\text{Perm} \\}$ $S\u0026rsquo;(X) := \\{ r \\downarrow X \\mid r \\in S(X) \\} = \\{r\u0026rsquo; \\in \\text{Perm}\u0026rsquo;(X) \\mid \\forall i \\in X.\\; \\text{Coi}(r\u0026rsquo;(i), i) \\} $  包除原理により，求める答は $N! - \\sum_{k=1}^{N} (-1)^{k - 1} R_k$ となるから，各$k$ に対する $R_k$ を求めれば良い． また，$|S(X)| = |S\u0026rsquo;(X)| \\times (N - |X|)!$ であるから， $\\sum\\{ |S\u0026rsquo;(X)| \\mid X \\subseteq [1, N],\\; |X| = k \\}$ を求めれば良い．\n集合 $[1, N]$ 上で，すべての $(p_i, q_i)$ を 結んだグラフを考える．どの頂点も次数は2以下である． 連結成分は，自己ループか，サイクルかのいずれかである． 連結成分全体の集合を $\\mathcal{Z}$ と書く． $Z\\in \\mathcal{Z}$ に対して， $Z$内にある辺に対応する番号の集合を $I(Z) := \\{ i \\in [1, N] \\mid p(i), q(i) \\in Z \\}$ と書く． $S\u0026rsquo;(X)$ の要素 $r$ は，各連結成分$Z$に， $\\sum_{Z \\in \\mathcal{Z}} t_Z = |X|$ となるように非負整数 $t_Z$ を 割り当てて，$Z$から$t_Z$本の辺に対して端点を選択することによって 決まる．正確には，\n $Q(Z, t) := \\{ r \\in S\u0026rsquo;(Y) \\mid Y \\subseteq I(Z), \\; |Y| = t \\}$ $Q(t) := \\{ ((Z, r_Z) \\mid Z \\in \\mathcal{Z} ) \\mid r_Z \\in Q(Z, t_Z),\\; \\sum_{Z \\in \\mathcal{Z}} t_Z = t\\}$ $\\rho_t : \\bigcup \\{ S\u0026rsquo;(X) \\mid |X| = t \\} \\to Q(t), \\; \\rho(r) = ( r \\downarrow I(Z) \\mid Z \\in \\mathcal{Z} )$  と書いたときに，$\\rho_t$ が全単射を与える．したがって， $|Q(t)|$ を求めれば良い．\nまず，$|Q(Z, t)|$ を求めよう．これは，$t$ にはもちろん依存するが， $Z$ に関しては，そのサイズ $s = |Z|$ にしか依存しないのは明らかであるので， $|Q(Z, t)|$ を $f(s, t)$ と書くことにする．\nまず，あきらかに，$ f(1, 1) = 1$であり，$t \u0026gt; 1$ のとき，$f (1, t) = 0$ である． $s \u0026gt;= 2$ については，DP で求める． $Z$ が円環状になっているので，次のように構成する． $I(Z)$ を $\\{ x_1, x_2, \\ldots, x_s \\}$ と， $q(x_{i}) = p(x_{i+1})$ が成り立つように列挙する．\n dp1[i][t][a][b] := 次を満たす r の数: ($a, b \\in \\{0, 1, 2\\}$)  $ \\text{dom}(r) \\subseteq \\{ x_1, \\ldots, x_i \\} $ $ t = |\\text{dom}(r)| $ a = 0: $x_s \\not\\in \\text{dom}(r)$ と矛盾しない． a = 1: $r(x_s) = p(x_s)$ と矛盾しない． a = 2: $r(x_s) = q(x_s)$ と矛盾しない． b = 0: $x_i \\not\\in \\text{dom}(r)$ b = 1: $r(x_i) = p(x_i)$ b = 2: $r(x_i) = q(x_i)$   初期値  dp1[0][0][a][0] = 1 (a = 0,1,2) dp1[0][1][a][1] = 1 (a = 0,1) dp1[0][1][a][2] = 1 (a = 0,1,2)   遷移  dp1[i+1][t][a][0] += dp[i][a][b] (b = 0,1,2) dp1[i+1][t+1][a][1] += dp[i][a][b] (b = 0,1) dp1[i+1][t+1][a][2] += dp[i][a][1] (b = 0,1,2)    DP実行後，$f(s, t) = dp1[s][t][0][0] + dp1[s][t][1][1] + dp1[s][t][2][2]$ で，$f$ が決定できる． 計算を振り返ってみると，$s$ ごとに別々にDPを実行する必要はなく， 1回のDPを $\\max(|Z|)$ まで実行することで， すべての必要な $f(s, t)$ を計算することができる． このDPの計算量は $O(N)$ である．\nこの準備のもとで，$|Q(t)|$ は，次のDPで求めることができる．\n $\\text{dp2}[i][t] := |\\{ ((j, r_j \\mid j \\leq i) \\mid r_j \\in Q(Z, t_j),\\; \\sum_{j\\leq i}t_j = t \\} |$ 遷移: $\\text{dp2}[i][t] = \\sum_{s \u0026lt; t} (\\text{dp2}[i-1][s] \\times f(|Z_i|, t - s))$  このDP実行終了後，$u := |\\mathcal{Z}|$ として， $|Q(t)| = \\text{dp2}[u][t]$ である． 計算量が心配になるが，遷移の式に現れる積の計算の回数は， $|Z_i| = a_i$ として， $a_1 + a_1 * a_2 + (a_1 + a_2) * a_3 + \u0026hellip;+ (a_1 + \u0026hellip; + a_{u-1}) * a_u \\leq (a_1 + \u0026hellip; + a_u)^2 = N^2$ なので，$O(N^2)$ である．\nACコード https://atcoder.jp/contests/abc214/submissions/25379311 ","permalink":"https://yamate11.github.io/blog/posts/2021/08-27-abc214g-three-permutations/","summary":"調べた結果分かった解法を記述します．いろいろ勉強になりました．","title":"Three Permutations - ABC 214 G"},{"content":"AtCoder Regular Contest (ARC) 124 E - Pass to Next の解法です． コンテスト後にも解けませんでした． 公式解説 を読んだだけではわからず， laycrsさんのツイートとコード を読んで，なんとか理解しました．\n問題へのリンク https://atcoder.jp/contests/arc124/tasks/arc124_e 問題概要 1, 2, \u0026hellip;, N の番号のついた人が円環状に並ぶ． 各人は a_i 個のボールを持っている． 0個以上 a_i 個のボールを右隣の人に一斉に渡す (1回限り)． その結果 人 i が持つボールの数を x_i とする． 有り得る $(x_i \\mid i \\in [1, N])$ 全体の集合を S とする． $\\sum \\{ \\prod \\{ x_i \\mid i \\in [1, N] \\} \\mid x \\in S \\}$ を mod 998244353 で求めよ．\n解法 (わかってしまえば，公式解説と書いていることは同じです)\n異なる渡し方が同じ $x$ を生成するための条件は，渡す個数の差が 全員同じであることであるから，「渡す個数が 0 の人が一人以上いる」 という条件をつけると，生成される $S$ には変化がなく，かつ，渡し方と $S$ が1対1に対応する．\n$x$ を一つ固定すると，$\\prod \\{ x_i \\mid i \\in [1, N] \\}$ は， 各人の操作後のボールから1つを選ぶ選び方の数と一致する．\n求める答は，以下の塗り方の数と一致する:\n 各 $i \\in [1, N] $ に対し，$a_i + 1$ 枚のカードが1列に横に並んで グループをなしており， 全体では円環上に並んでいる (グループ N の次にグループ 1 が来る)． 以下の条件を満たすように，いくつかのカードを黒く， いくつかのカードを赤く塗る．  各グループのカードのうち，ちょうど1枚を黒く塗る． 黒く塗るカードが右端のカードであるグループが1つ以上有る． どの2枚の黒いカードの間にも，赤いカードがちょうど1枚有る．    各グループの，黒いカードより右側のカードが，右隣の人に渡したボールに 対応し，黒いカードより右側のカードは，手元に残したボールに対応する． 赤いカードは，「選んだ」ボールに対応する．\nこのような塗り方を，以下の DP で数える．\n dp[i][a][b][c] := 第 $i$ グループまでを以下の条件を満たすように塗る方法の数  $a \\in \\{0, 1\\}$． $a = 0$ では，最後のグループで，黒いカードより右側に赤いカードが無いことを 仮定する． $a = 1$ では，有ることを仮定する． $b \\in \\{0, 1\\}$． $b = 0$ は，第 $i$ グループで，黒いカードよりも右に 赤いカードが無いことを示す． $b = 1$ は，有ることを示す． $c \\in \\{0, 1\\}$． $c = 0$ は，第 1 グループから第 $i$ グループまででは， 右端のカードを黒く塗ったものが無いことを示す． $c = 1$ は，有ることを示す．    遷移は下のコードを参照．\n求める答は，dp[N][0][0][1] + dp[N][1][1][1] である．\nACコード Fp binom(ll n, ll r) { // 二項係数．3までしか出てこない  if (r \u0026lt; 0 || n \u0026lt; r) return 0;  if (r == 0) return 1;  if (r == 1) return n;  if (r == 2) return Fp(n) * Fp(n - 1) / Fp(2);  if (r == 3) return Fp(n) * Fp(n - 1) * Fp(n - 2) / Fp(6);  assert(0); }  int main(/* int argc, char *argv[] */) {  ios_base::sync_with_stdio(false);  cin.tie(nullptr);  cout \u0026lt;\u0026lt; setprecision(20);   ll N; cin \u0026gt;\u0026gt; N;  vector\u0026lt;ll\u0026gt; A(N);  for (ll i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; A[i];   auto tbl_init = vector(2, vector(2, vector(2, Fp(0))));  auto tbl = tbl_init;  tbl[0][0][0] = tbl[1][1][0] = 1;  for (ll i = 0; i \u0026lt; N; i++) {  auto prev = move(tbl);  tbl = tbl_init;  for (ll a = 0; a \u0026lt; 2; a++) { // 遷移前後でaは変わらず  for (ll b = 0; b \u0026lt; 2; b++) { // 遷移前  for (ll b0 = 0; b0 \u0026lt; 2; b0++) { // 遷移後  for (ll c = 0; c \u0026lt; 2; c++) { // 遷移前  for (ll c0 = 0; c0 \u0026lt; 2; c0++) { // 遷移後  // n 枚から r 枚を選んで，下の (*) で更新する．  ll n = A[i] + 1;  // r は最大で 黒1, 赤2 の 3枚だが，  // グループ i-1 で選択されていたら1減じる．  // グループ i で選択しないのであれば1減じる．  ll r = 3 - b - (1 - b0);  if (c \u0026amp;\u0026amp; !c0) continue; // 矛盾  else if (!c \u0026amp;\u0026amp; c0) {  // このグループで右端を黒く塗る  if (b0) continue; // 右端より右には置けない  // 右端を黒に決めたので，n, r とも1減じる．  n--;  r--;  }else if (!c \u0026amp;\u0026amp; !c0 \u0026amp;\u0026amp; !b0) n--; // 右端は選べない  tbl[a][b0][c0] += binom(n, r) * prev[a][b][c]; // (*)  }  }  }  }  }  }  cout \u0026lt;\u0026lt; tbl[0][0][1] + tbl[1][1][1] \u0026lt;\u0026lt; endl;   return 0; } Fp は，mod 998244353 を計算するための構造体です． https://atcoder.jp/contests/arc124/submissions/25361161 ","permalink":"https://yamate11.github.io/blog/posts/2021/08-27-arc124e/","summary":"解けませんでした．解説を読んでも分からなかったので，自分なりの説明です．","title":"Pass to Next - ARC 124 E"},{"content":"鹿島建設プログラミングコンテスト2020 (AtCoder Regular Contest 110 - ARC110) の E - Shorten ABC の解法です．\n経緯 解説AC です．公式解説も皆さんの解説もたくさん参考にしています．\n問題概要 A, B, C からなる，長さ N の文字列がある． 隣り合った異なる文字を，どちらとも違う文字で置き換える操作ができる． 操作を0回以上行ってできる文字列の数を mod $10^9 + 7$ で求めよ．\n制約: $N \\leq 10^6$\n 問題へのリンク   解法 Python 流に，文字列 s と t の連結を s+t で， 文字列sの位置p(含む)から位置q(含まない)の部分文字列をs[p:q]で表す． 文字列長1の文字列と文字を同一視する．\n与えられた文字列が1種類の文字からなるときは，答は 1 である． 以下，そうでないとする．\nA,B,Cからなる文字列 s に対する e(s) を定義する．\n e(\u0026ldquo;A\u0026rdquo;) = 1 e(\u0026ldquo;B\u0026rdquo;) = 2 e(\u0026ldquo;C\u0026rdquo;) = 3 e(s + c) = e(s) XOR e(c) (len(c) = 1)  次が成り立つ．\n 文字列 s を文字 c に変換できるための必要十分条件は，以下の 両方が成り立つことである．  e(s) = e(c) len(s) = 1 であるか，または，s が2種類以上の文字を含む．    帰納法で簡単に証明できる．次も成り立つ．\n 長さ a の文字列 s が2種類以上の文字を含むとする． s を長さ b の文字列 t に変換できる必要十分条件は， $0 = p_0 \u0026lt; p_1 \u0026lt; \u0026hellip; \u0026lt; p_{b} = a$ なる列がとれて， $e(s[p_i:p_{i+1}]) = e(t[i])$ が成り立つことである．  必要性は明らかなので，十分性を示す． $s[p_i:p_{i+1}]$ が1種類の文字 X しか含まない場合が問題となる． $p_{i+1} - p_i$ は奇数で，t[i] = X である． このブロックより右か左に X 以外の文字が現れるところがある． どちらでも同じなので，右に現れるとしよう． $s[p_j:p_{j+1}]$ に X 以外の文字が現れ，$i \u0026lt; k \u0026lt; j$ なる $s[p_k:p_{k+1}] $ には，X しか現れないとする． この場合，$p_{k+1} - p_k$ は奇数で，t[k] = X である． そこで，切り方を変えて，$s[p_i], \\ldots, s[p_i + (j - i - 1)]$ の各 1文字を t[i], \u0026hellip;, t[j-1] に対応させ， $s[p_i + (j-i-1):p_{j+1}]$ を t[j] に対応させる．t[j] に対応させる文字列は，元の対応文字列に 偶数個の X を追加したものであるから，XOR の値は変わらない． したがって，t に変換することが可能である．(終)\ns を与えられた文字列とする． 上で示したことから，s から変換可能な長さ b の文字列 t に対して， 「左から貪欲に切っていく分割」を対応させることができる．正確には， $0 = p_0 \u0026lt; p_1 \u0026lt; \u0026hellip; \u0026lt; p_{b} \\leq N$ であって，以下を満たすものを対応させる．\n $e(s[p_i:p_{i+1}]) = e(t[i]) \\qquad (i = 0, \\ldots, b-1)$ $e(s[p_i:q] \\neq e(t[i]) \\qquad (i = 0, \u0026hellip;, b-1; p_i \u0026lt; q \u0026lt; p_{i+1})$ $e(s[p_b:N]) = 0$  このような分割を数えれば良い．$p_b = i$ となるような分割の数 dp[i] を，配るDPを用いて数えよう． t = 0, 1, 2, 3 と，$0 \\leq i \u0026lt; N$ に対して，\n $\\textrm{nxt}(i, t) := \\min \\{ j \\mid e(s[p:j]) = t, i \u0026lt; j \\}$  とするとき，t = 1, 2, 3 に対して，\n dp[nxt(i, t)] += dp[i]  なる計算を行えば良い．求める答は， $\\sum \\{ dp[i] \\mid 1 \\leq i \\leq N; e(s[i:N]) = 0 \\}$ である．\n$e(s[i:N]) = 0$ を満たす i は，後ろから順に $O(N)$ で決定できる． nxt(i, t) も，t = 0 も含めて後ろから順に，\n nxt(i, e(s[i])) = i + 1 nxt(i, (t XOR e(s[i])) % 4) = nxt(i + 1, t)  と計算すれば，やはり $O(N)$ で求められる． 全体として $O(N)$ で問題を解くことができた．\nACコード Fp は，mod $10^9 + 7$ を取るためのクラスです．\nint main(/* int argc, char *argv[] */) {  ios_base::sync_with_stdio(false);  cin.tie(nullptr);  cout \u0026lt;\u0026lt; setprecision(20);   ll N; cin \u0026gt;\u0026gt; N;  string S; cin \u0026gt;\u0026gt; S;  if (all_of(S.begin(), S.end(), [\u0026amp;](char t) -\u0026gt; bool {return t == S[0];})) {  cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl;  return 0;  }  vector\u0026lt;ll\u0026gt; E(N);  for (ll i = 0; i \u0026lt; N; i++) E[i] = S[i] - \u0026#39;A\u0026#39; + 1;  vector nxt(4, vector\u0026lt;ll\u0026gt;(N + 1));  for (ll t = 0; t \u0026lt; 4; t++) nxt[t][N] = N + 1;  for (ll i = N-1; i \u0026gt;= 0; i--) {  nxt[E[i]][i] = i + 1;  for (ll t = 1; t \u0026lt; 4; t++) nxt[E[i] ^ t][i] = nxt[t][i + 1];  }  vector\u0026lt;Fp\u0026gt; tbl(N + 2);  tbl[0] = 1;  for (ll i = 0; i \u0026lt; N; i++) {  for (ll t = 1; t \u0026lt; 4; t++) tbl[nxt[t][i]] += tbl[i];  }  vector\u0026lt;ll\u0026gt; accE(N + 1);  for (ll i = N-1; i \u0026gt;= 0; i--) accE[i] = E[i] ^ accE[i + 1];  Fp ans = 0;  for (ll i = 1; i \u0026lt;= N; i++) if (accE[i] == 0) ans += tbl[i];  cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl;   return 0; } ","permalink":"https://yamate11.github.io/blog/posts/2021/08-26-shorten-abc/","summary":"解説AC です．公式解説も皆さんの解説もたくさん参考にしています．","title":"Shorten ABC - AtCoder Regular Contest 110 E"},{"content":"問題へのリンク https://atcoder.jp/contests/arc125/tasks/arc125_e 経緯 ARC125 には参加できなかったので，バーチャルコンテストで解きました． Cまでしか解けなかったので，バーチャルコンテスト終了後に考えましたが， 全然解けませんでした．フローは考えたのですが，間に合うはずがない (それは正しい) と思って，そこから先には進めませんでした．\n問題概要 正の整数列 $(A_i \\mid i \\in [1, N]), (B_j \\mid j \\in [1, M]), (C_j \\mid j \\in [1, M]) $ が与えられる． $(D_{ij} \\mid i \\in [1, N], j \\in [1, M])$ を次を満たすように取るとき， $\\sum \\{ D_{ij} \\mid i \\in [1, N], j \\in [1, M] \\}$ の最大値を求めよ．\n $\\sum \\{ D_{ij} \\mid j \\in [1, M] \\} \\leq A_i$ $D_{ij} \\leq B_j$ $\\sum \\{ D_{ij} \\mid i \\in [1, N] \\} \\leq C_j$  制約: $N, M \\leq 2\\times 10^5$, $A_i, C_j \\leq 10^{12}$, $B_j \\leq 10^7$\n解法 次のフローの最大流問題として定式化できる．\n Source $\\to L_i$ 容量 $A_i$ $L_i \\to R_j$ 容量 $B_j$ $R_j \\to$ Sink 容量 $C_j$  容量が大きくノードが多いので，Dinic などでは解けない．\n最小カット $(A, B)$ を求める．Source $\\in A$ とする． $L_i$ たちのうち，$A$ に属するものの集合を $X$, $|X| = n$ とする． $R_j$ については，\n $R_j \\in A$ とすると，カット容量への寄与は $C_j$ $R_j \\in B$ とすると，カット容量への寄与は，$n B_j$  であるから，$(A, B)$ の最小性より，\n $C_j \u0026lt; n B_j$ なら $R_j \\in A$ $C_j \u0026gt; n B_j$ なら $R_j \\in B$  となる必要がある．カット容量は全体として，\n$$ \\sum \\{ A_i \\mid i \\in [1, N] - X \\} + \\sum \\{ \\min(C_j, n B_j) \\mid j \\in [1, M] \\} $$\nであるから，$A_i$ の大きい方から $n$ 個が $X$ に属するとして良い． $n = 1, \\ldots, N$ について計算して最小値を取れば良い．\nACコード https://atcoder.jp/contests/arc125/submissions/25313748 ","permalink":"https://yamate11.github.io/blog/posts/2021/08-24-snack/","summary":"解法です．公式解説そのままです．","title":"Snack - Atcoder Regular Contest 125 E"},{"content":"問題へのリンク https://atcoder.jp/contests/abc215/tasks/abc215_h 経緯 コンテスト中は，そもそもHには到達もしませんでした． コンテスト後に考えましたが，歯が立ちませんでした．\n Hall の定理は，見たことはあったけど，覚えていなかった 高速ゼータ変換や高速メビウス変換のライブラリは持っていたのですが， どう使うか知らなかった．  というわけなので，解けるはずがありませんでした．\n問題概要 正の整数$N$, $M$; 各 $i\\in [1, N]$ と 各 $j \\in [1, M]$ に対して 正の整数 $A_i$, $B_j$, および $C_{ij} \\in \\{0, 1\\}$ が与えられる． ただし，任意の $j$ に対して $i$ が存在して $C_{ij} = 1$ である．\n$i\\in [1, N]$ に対して $|D_i| = A_i$ となる互いに素な集合 $D_i$ を固定し， $D = \\bigcup \\{ D_i \\mid i \\in [1, N] \\}$ と書く． $D$ の部分集合 $E$ と $i \\in [1, N]$ に対して，$E_i := E \\cap D_i$ とする． $E$ に関する次の条件を考える．\n $E$ の $M$ 個の分割 $(F_1, \\ldots, F_M)$ で，以下を満たすものは存在しない  $F_j \\cap E_i \\neq \\emptyset \\implies C_{ij} = 1$ 各 $i \\in [1,N]$ に対して， $ \\bigcup \\{ F_j \\cap E_i \\mid j \\in [1,M] \\} \\geq B_j $    条件を満たす $E$ のうち，$X = |D - E|$ の最小値を求めよ． また，最小値を与える $E$ の個数を，mod 998244353 で求めよ．\n制約: $N \\leq 20$; $M \\leq 10^4$; $A_i, B_j \\leq 10^5$\n予備知識 Hall の定理 $A$, $B$ を有限集合，$G \\subseteq A \\times B$ とするとき， 以下の2条件は同値である．\n 単射 $f: A \\to B$ で，$(a, f(a)) \\in G$ であるものが存在する． 任意の $X \\subseteq A$ に対して，$ |X| \\leq |f[X]|$．  ただし，$f[X] := \\{ b \\in B \\mid \\exists a \\in A. f(a) = b \\}$．\n証明は，たとえば高校数学の美しい物語 に載っています．\nゼータ変換，メビウス変換 $A$ を有限集合とする．$A$の冪集合を $ \\mathcal{P}(A) $ と書く．\n$ f : \\mathcal{P}(A) \\to M $ に対して， $ \\zeta_{U}(f) : \\mathcal{P}(A) \\to M $ と $ \\zeta_{L}(f) : \\mathcal{P}(A) \\to M $ を， 次で定義する．\n $ \\zeta_{U}(f)(X) = \\sum \\{ f(Y) \\mid X \\subseteq Y \\} $ $ \\zeta_{L}(f)(X) = \\sum \\{ f(Y) \\mid Y \\subseteq X \\} $  作り方を考えると，$\\zeta_{U}$, $\\zeta_{L}$ には，逆変換が存在する． これらを，$\\mu_{U}$, $\\mu_L$ と書く．\n高速ゼータ変換，高速メビウス変換 以下のアルゴリズムによって， $(f(X) \\mid X \\subseteq A)$ が与えられた時に $\\alpha = \\zeta_U, \\zeta_L, \\mu_U, \\mu_L$ に対し， $(\\alpha(f)(X) \\mid X \\subseteq A)$ を，$O(|A| \\log|A|)$ で 計算できる．\n 配列 $P := [(X, f(X)) \\mid X \\subseteq A]$ 各 $x \\in A$ に対して以下によって $P$ を更新する．  各 $X \\subseteq A \\setminus \\{x\\}$ に対して $Y := X \\cup \\{x\\}$ とおいて， $(P[X], P[Y]) := (P[X] + u P[Y], v P[X] + P[Y])$    ただし，$u$, $v$ は，以下の値を使う\n $\\zeta_U$ \u0026hellip; $(u, v) = (1, 0)$ $\\zeta_L$ \u0026hellip; $(u, v) = (0, 1)$ $\\mu_U$ \u0026hellip; $(u, v) = (-1, 0)$ $\\mu_L$ \u0026hellip; $(u, v) = (0, -1)$  妥当性の説明は，「高速ゼータ変換」で検索すると，いろいろなところに出ています．\n解法 公式解説 そのままです．\n次のように定める．\n $T_j := \\{ i \\in [1, N] \\mid C_{ij} = 1 \\}\\qquad (j \\in [1, M])$ $f(S) := \\sum \\{ A_i \\mid i \\in S \\} \\qquad S \\subseteq [1, N]$ $g(S) := \\sum \\{ B_j \\mid T_j ⊆ S \\}\\qquad S \\subseteq [1, N]$  $f$ は，愚直に $O(N 2^N)$ で計算できる． $g$ は，$\\zeta_L$ を使って $O(NM + N 2^N)$ で計算できる．\nHall の定理を使うために，$j \\in [1, M]$ に対して $|H_j| = B_j$ なる互いに素な集合を用意して， $H := \\bigcup \\{H_j \\mid j \\in [1, M]\\}$ とする． $G := \\{(d, h) \\in E \\times H \\mid d \\in E_i, h \\in H_j, C_{i,j} = 1 \\}$ Hall の定理から，$E$ が上記の条件を満たすための必要十分条件は\n $f(E, S) \u0026lt; g(S)$ となる $S \\subseteq [1, N]$ が存在する  ことである．ただし，\n $f(E, S) := \\sum \\{ | E_i | \\mid i \\in S \\} \\qquad S \\subseteq [1, N]$  である．したがって，$f(S) \u0026gt; 0$ である 全部の $S \\subseteq [1, N]$ に対する $ f(S) - g(S) + 1 $ の最小値が，求める $X$ の値となる． (ただし，0以下の時にはそもそも$A$が分割できないので，$X=0$)．\n後半は，$X= 0$ なら個数は 1 なので，$X\u0026gt; 0$ とする．\n $F := \\{ S \\subseteq [1, N] \\mid f(S) - g(S) + 1 = X \\}$  とする．$S \\subseteq [1, N]$ に対し，\n $h(S)$ := $D$ から $X$ 個の要素を選ぶ方法のうち，選ばれた要素の添字の 集合がちょうど $S$ となるものの数  とする．求める答は\n $\\sum \\{ h(S) \\mid \\exists S\u0026rsquo; \\in F.\\; S \\subseteq S\u0026rsquo; \\}$  である．$S \\subseteq [1, N]$ が $\\exists S\u0026rsquo; \\in F.\\; S \\subseteq S\u0026rsquo;$ を満たすかどうかは， $F$ の特性関数を $\\zeta_U$ で変換することで分かる． また，$p := \\zeta_L(h)$ とおくと，\n $p[S] = \\bigcup \\{ D_i \\mid i \\in S \\}$ から X 個の要素を選ぶ方法の数 = $\\binom{f(S)}{X}$  である．したがって，$h$ は，$\\mu_L(p)$ で求めることができる．\nACコード https://atcoder.jp/contests/abc215/submissions/25289505 ","permalink":"https://yamate11.github.io/blog/posts/2021/08-23-cabbage-master/","summary":"公式解説そのままですけれど，予備知識を一応書きました．","title":"Cabbage Master - Atcoder Beginner Contest 215 H"},{"content":"xor畳み込み 長さ $2^K$ の数列 $X$, $Y$ があるとき， これらのxor畳み込みを，以下を満たす長さ $2^K$ の列 $Z$ として定める． ただし，$x \\oplus y$ は $x$ と $y$ の xor とする．\n $ Z_k = \\sum \\{ X_i Y_j \\mid i \\oplus j = k \\} $  以下では，$Z = X * Y$ と書く．\nアダマール変換 長さ $2^K$ の数列に作用するアダマール変換は，以下の行列 $H_K$ で定義される 1次変換である．\n$$ H_0 = 1 $$\n$$ H_{k + 1} = \\begin{bmatrix} H_k \u0026amp; H_k \\\\ H_k \u0026amp; -H_k \\end{bmatrix} $$\n本来は，正規化のために定数倍するが， ここでは，結果を整数にするためにそうしていない．\n$ H_k H_k = 2^k I $ が成り立つので，$(H_k)^{-1} = 2^{-k} H_k$ である．\n畳み込みとアダマール変換 以下が成り立つことが，計算することで容易に分かる．\n$$ (H_K X) (H_K Y) = H_K (X * Y) $$\nただし，左辺は，成分ごとの積．したがって，xor 畳み込みは，下のように計算できる．\n$$ X * Y = 2^{-K} H_K ((H_K X) (H_K Y)) $$\nアダマール変換は，定義に従って $O(n \\log n)$ で計算できる．($n = 2^K$)\nメモリを賢く使って計算している例が kazuma8128\u0026#39;s blog に載っている．\nこれを使える問題 ABC212 H Nim Counting ","permalink":"https://yamate11.github.io/blog/posts/2021/08-10-xor-conv/","summary":"高速アダマール変換によって，xor畳み込みをする方法についての記事 (自分用のメモ) です．","title":"xor畳み込み"},{"content":"C++ での型の変換などのいろいろな変換方法を書いておきます．競技プログラミング用途です．ソース冒頭に次のように書いてあるものとします．\n#include \u0026lt;bits/stdc++.h\u0026gt;typedef long long int ll; using namespace std; 文字列→数値 std::stoi, std::stoll を使う．2進数などを読みたいときは，base を指定すれば良い．\nint stoi( const string\u0026amp; str, size_t* pos=0, int base=10 ); long long stoll( const string\u0026amp; str, size_t* pos=0, int base=10 ); 使用例\n string s1 = \u0026#34;101\u0026#34;;  ll x = stoll(s1); // x == 101  ll y = stoll(s1, 0, 2); // y == 5 似たような名前で std::strtoll などもあるが， これらは引数に const char* を取る． const string\u0026amp; を引数に取る stoll などの方が便利だろう．\n実数への変換は，std::stod, std::stold を使う．\ndouble stod( const string\u0026amp; str, size_t* pos = 0 ); long double stold( const string\u0026amp; str, size_t* pos = 0 ); 数値→文字列 std::to_string を用いる．\nstring to_string( int value ); string to_string( long long value ); string to_string( unsigned value ); string to_string( unsigned long long value ); string to_string( double value ); string to_string( long double value ); 16進表記文字列にしたいとか 8進にしたいとかいう場合には， 1つの関数を適用して終わりというわけにはいかないように思う． 次のような感じだろう．\n ll value = 256;  stringstream ss;  ss \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; value;  string s = ss.str(); // s == \u0026#34;100\u0026#34; 8進にするときには hex の代わりに oct を用いる．\n2進の場合はbitsetを用いる． 下の例では，value2 の2進表現が長さ8の文字列になる．\n ll value2 = 30;  string s2 = bitset\u0026lt;8\u0026gt;(value2).to_string(); // s2 == \u0026#34;00011110\u0026#34; 実数→整数 普通にキャストすれば良い場合も多いが，いろいろ罠がある．\n double d = -26.001;  ll x = ll(d + 0.5); // x == -25 (!!) これは，dが負の場合には意図したようには動作しない． 0に向かって丸められてしまうからである． 次を用いる．\n double d = -26.001;  ll x = llround(d); // x == -26 round関数などのsignature は以下のようになっている．\ndouble round ( double arg ); long double roundl( long double arg ); long lround ( double arg ); long lroundl( long double arg ); long long llround ( double arg ); long long llroundl( long double arg ); 定数の 1,000,000,007 などを書くのが面倒で，\n const ll mod = 1e9 + 7; などと書いてしまうことがある．上の例は意図したように動くようであるが，\n const ll big1 = 1e18;  const ll big2 = 1e18 + 1; については，big1 も big2 も 同じ値になってしまう． (gccの場合) double の精度は十進で15桁くらい，long double は18桁くらいである．\n","permalink":"https://yamate11.github.io/blog/posts/2021/02-07-int-string-trans/","summary":"C++ での型の変換などのいろいろな変換方法です．","title":"文字列，数値変換"},{"content":"Atcoder Regular Contest 104 (ARC 104) E Random LIS に関する記事です．\n問題文へのリンク https://atcoder.jp/contests/arc104/tasks/arc104_e 経緯 過去問埋めで解いてみようとしましたが，全然わかりませんでした． 公式解説 を読んでもやっぱりわからず， けんちょんさんの解説 を読んで，なんとか理解することができました．\n解法 例えば，N = 4 として，数列 10 7 10 15 と数列 5 1 5 2000 は， 数値の差こそあれ，大小関係は同一である．これらを 1 0 1 2 というパターンとして 1つのグループとしてまとめることにする．以下を実行する．\n 全パターンを列挙する． 各パターンについて，  LISの長さを求める． そのパターンに属する数列の数を数える．    グループがいくつあるかは， Ordered Bell number として知られているということである．N = 6 の場合には，4683個． 丁寧に列挙することもできるであろうが，$6^6 = 46656$ であるから，0 から N-1 までの 数の N 個の並びから，不適なものを弾いても十分速い． 各グループに属する数列では，LIS の長さは同じであり，N \u0026lt;= 6 だからこれを求めるのは容易である． 各グループに属する数列の数を求めるのが主要なタスクとなる．\n$\\{0, 1\\} \\cup \\{A_i + 1\\mid i = 1, \\ldots, N\\}$ を昇順にソートして $p_0, p_1, .., p_M$ とし，$P_i$ を整数の半開区間 $[p_i, p_{i+1})$ とする．\nパターンを1つとる．パターン中に現れる数が $0, 1, \\ldots, D-1$ だとする． 各 $d \\in [0, D)$ について，これが現れる位置を $q_1, \\ldots, q_k$ としたとき，$\\min(A_{q_1}, \\ldots, A_{q_k})$ を $B_d$ とする． たとえば，パターン 2 2 2 0 1 1 については，$B_0 = A_3$, $B_1 = \\min(A_4, A_5)$, $B_2 = \\min(A_0, A_1, A_2)$ である． すると，パターンに属する数列の数は，数列 $( x_d | d \\in [0, D) )$ であって $x_d \\in [1, B_d + 1)$ を満たすものの数に等しいので，これを数えることにする．\n動的計画法による． 「長さ i の列 $( x_d | d \\in [0, i) )$ で $x_d \\in [1, B_d + 1)$ を満たし，$ x_{i-1} \\in P_j $ であるもの」の集合を $S_{i,j}$ とし，dp[i][j] を，$S_{i,j}$ の要素の数とする． 普通に dp[i][j] → dp[i+1][j\u0026rsquo;] の遷移を書こうとすると， j = j\u0026rsquo; の時にうまくいかない． そこで，次のことに注目する: 長さ i の列 $(x_d \\mid d \\in [0, i) )$ について，次の2つは同値である．\n $( x_d \\mid d \\in [0, i) ) \\in S_{i,j}$ $k \u0026lt; i$, $u \u0026lt; j$ が存在して，以下が成り立つ．  $(x_d \\mid d \\in [0, k) ) \\in S_{k, u}$ 各 $e \\in [k, i)$ に対して，$B_e + 1 \\geq p_{j+1}$ $i - k \\leq p_{j+1} - p_j$    そこで，以下のように遷移を定義することができる:\n dp[i][j] ← dp[k][u] * binom(p[j+1] - p[j], i - k)  where  * i \u0026gt; k and  * j \u0026gt; u and  * i - k \u0026lt;= p[j+1] - p[j] and  * forall e in [k, i). B[e] + 1 \u0026gt;= p[j+1] ACコード https://atcoder.jp/contests/arc104/submissions/25160111 ","permalink":"https://yamate11.github.io/blog/posts/2021/08-19-random-lis/","summary":"Atcoder Regular Contest 104 (ARC 104) E Random LIS に関する記事です．\n問題文へのリンク https://atcoder.jp/contests/arc104/tasks/arc104_e 経緯 過去問埋めで解いてみようとしましたが，全然わかりませんでした． 公式解説 を読んでもやっぱりわからず， けんちょんさんの解説 を読んで，なんとか理解することができました．\n解法 例えば，N = 4 として，数列 10 7 10 15 と数列 5 1 5 2000 は， 数値の差こそあれ，大小関係は同一である．これらを 1 0 1 2 というパターンとして 1つのグループとしてまとめることにする．以下を実行する．\n 全パターンを列挙する． 各パターンについて，  LISの長さを求める． そのパターンに属する数列の数を数える．    グループがいくつあるかは， Ordered Bell number として知られているということである．N = 6 の場合には，4683個． 丁寧に列挙することもできるであろうが，$6^6 = 46656$ であるから，0 から N-1 までの 数の N 個の並びから，不適なものを弾いても十分速い． 各グループに属する数列では，LIS の長さは同じであり，N \u0026lt;= 6 だからこれを求めるのは容易である． 各グループに属する数列の数を求めるのが主要なタスクとなる．","title":"Random LIS - Atcoder Regular Contest 104 E"},{"content":"発端 自分で書いた SCC (強連結成分分解) ライブラリを使っているのですが， これが，AC-library の SCC に比べて，4倍くらい遅いのです． どこが遅いのか調べてみたら，意外なところにもネックがありました．\n最初は，主に使っているアルゴリズムのせいだと思ったのです． 深さ優先探索を2回行うアルゴリズム (たとえばここ を参照) を使っていました． AC-library は，Tarjan のアルゴリズム を使っているようなので，合わせれば速くなるだろう，と思って 書きかえました．\nたしかに速くなったのですが，それでもまだAC-libraryより3倍ほど遅いです．\nvector\u0026lt;vector\u0026lt;*\u0026gt; \u0026gt; 部分に分けて測定してみたところ，どうも，グラフの情報を設定しているところも 遅い，ということが分かりました． こんな感じのコードなのですが:\nint N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; // N は頂点数, M は辺の数 vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; edges; for (int i = 0; i \u0026lt; M; i++) {  int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; // 0-indexed で入力されると仮定  edeges.emplace_back(u, v); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; fwd(N); // fwd[i] は，i から直接行ける頂点たち． // (1) for (auto [u, v] : edges) {  fwd[u].push_back(v); } // (2) この，(1)から(2)までの部分で，結構時間を食っています． Tarjan のアルゴリズムを実行するのと同程度の時間がかかっているように見えました．\nCSR AC-library はそこをどう処理しているのか，と，見てみましたら， CSR なる構造体を使っていました． おそらく， Compressed Sparse Row のことだと思います． すべて1次元のベクトルでの処理になります．\nたとえば，{(0, 5), (0, 7), (1, 4), (2, 3), (2, 8)} を格納する場合には， まず，遷移先の {5, 7, 4, 3, 8} を vector\u0026lt;int\u0026gt; に格納します． それで，別の vector\u0026lt;int\u0026gt; に，{0, 2, 3, 5} を格納します． これは，遷移元が 0 の遷移先は [0, 2) に格納されており， 遷移元が1 の遷移先は [2, 3) に格納されており，遷移元が2の 遷移先は，[3, 5) に格納されている，ということを示しています．\nちょっと上のリンクで説明されているCSRより簡略になっていますが， 考え方は同じだと思います．\n性能比較 ここで，CSR と vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; を使った場合の SCC の性能比較を書くべきところですが， ちょっといろいろあって，まだできていないので， 代わりに木DPで試してみました．\nランダムに作成した木の辺を与えて，各ノードの子孫のノードの数を 数えるというプログラムです． 木のノード数を$2\\times 10^5$ 程度にしてみると，次のようになりました:\n   Sとして何を使うか vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; CSR     標準入力から vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; への読み込み 47ms 47ms (左と同じコード)   vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; から S への変換 48ms 31ms   S を使って子孫ノード数を数える 47ms 14ms    \u0026hellip;. あっと驚くほどには違っていませんね．羊頭狗肉でした．\n性能比較に使ったファイルは こちら です．(gen.py は，データ生成用スクリプト)\n","permalink":"https://yamate11.github.io/blog/posts/2021/08-15-perf-vect-vect/","summary":"発端 自分で書いた SCC (強連結成分分解) ライブラリを使っているのですが， これが，AC-library の SCC に比べて，4倍くらい遅いのです． どこが遅いのか調べてみたら，意外なところにもネックがありました．\n最初は，主に使っているアルゴリズムのせいだと思ったのです． 深さ優先探索を2回行うアルゴリズム (たとえばここ を参照) を使っていました． AC-library は，Tarjan のアルゴリズム を使っているようなので，合わせれば速くなるだろう，と思って 書きかえました．\nたしかに速くなったのですが，それでもまだAC-libraryより3倍ほど遅いです．\nvector\u0026lt;vector\u0026lt;*\u0026gt; \u0026gt; 部分に分けて測定してみたところ，どうも，グラフの情報を設定しているところも 遅い，ということが分かりました． こんな感じのコードなのですが:\nint N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; // N は頂点数, M は辺の数 vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; edges; for (int i = 0; i \u0026lt; M; i++) {  int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; // 0-indexed で入力されると仮定  edeges.emplace_back(u, v); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; fwd(N); // fwd[i] は，i から直接行ける頂点たち． // (1) for (auto [u, v] : edges) {  fwd[u].","title":"vector\u003cvector\u003c*\u003e\u003e はあんまり速くない"},{"content":"JOI 2020/2021 二次予選 「イベント巡り (Event Hopping)」 に関する記事です． 公式解説 を読みきれなかったので\u0026hellip;.\n問題へのリンク https://atcoder.jp/contests/joi2021yo2/tasks/joi2021_yo2_c 解法 ちょっと不思議な感じで，小課題3 を (私の感覚では) 自然に解くと， それが満点解法にもなっているという\u0026hellip; (解説を読むまでわからなかったのですけれど)\nソートして，$S_i$ が昇順になっているとします． ナイーブに考えると，次の DP になります．\n dp[i][j] := i番目のイベントに参加する直前までに参加したイベントの 回数が j であるような方法がある (True/False)  遷移としては，dp[i][j] = True となる j について，\n 町 $P_i$ で行われるイベントで，時刻 $S_i + 1$ 以降最も早いものを i1 町 $3 - P_i$ で行われるイベントで， 時刻 $S_i + 1 + D + K(j + 1)$ 以降最も早いものを i2  として，\n dp[i1][j+1] := True dp[i2][j+1] := True  と設定することになります．でも，これは $\\Omega(N^2)$ なので，間に合いません．\n実は，回数を全部見る必要がなくて，各々のイベントに参加するまでに， 最も多くの回数のイベントに参加してきた方法だけ考えれば十分です． ただし，「ある時点までに多くの回数のイベントに参加した方が， 最終的なイベント参加回数が多い」ということは言えません． 次のような例があります．\n $D = 1$, $K = 100$ $S_1 = 1$, $P_1 = 1$ $S_2 = 1000$, $P_2 = 2$ $S_3 = 1150$, $P_3 = 1$ $S_4 = 1151$, $P_4 = 1$  町 1 から出発して イベント 1 に参加した直後に 2 に移る (方法A) と， イベント2 の直前に，今まで参加した回数は 1 です． 一方，町2から出発する (方法B) と，イベント2の直前に， 今まで参加した回数は 0 で，方法Aの方が多いです． しかし，方法B の方は，このあと イベント2, 3, 4 に参加して最終の回数が3回にできますが， 方法Aは，最終的に2回しか参加できません．\nしかし，以下は成り立ちます:\n補題 各イベント $i$ に対し，そのイベントに参加する前に参加できるイベント数の 最大値を $M(i)$ とする． 求める答を $X$ とする． 条件を満たしてイベントに参加していく方法 $e_0, \\ldots, e_{X-1}$ であって， 任意の $j = 0, \\ldots, X-1$ に対して，$M(e_j) = j$ となるものが存在する．\n補題が言えれば，DP として，以下のものをとれます:\n dp[i] := $M(i)$  遷移としては，$dp[i]$ が計算できたらば，上で述べた i1 と i2 を取って，\n dp[i1] := max(dp[i1], dp[i] + 1) dp[i2] := max(dp[i2], dp[i] + 1)  とすれば良いです．(仮想的に，十分遅く行われるN番目のイベントを考えて) dp[N] が求める答となります．このDPは，$O(N\\log N)$ で実行できます．\n補題の証明です．帰謬法によることにして，そのような方法がないとすると， $X$を達成するどの方法についても $M(e_j) \u0026gt; j$ となる $j$ があります． 各方法 $\\alpha$ についてそのような $j$ の最大値を$j_\\alpha$ とし， その最小値を与える $\\alpha$ を取ります． すなわち，$M(e_{j_\\alpha}) \u0026gt; j_\\alpha$ です． イベント $e_{j_\\alpha}$ が行われる町を $p$ として， イベント $e_{j_\\alpha + 1}$ が行われる町を $q$ とすると， $ p \\neq q $ であることに注意します． $M(e_{j_\\alpha})$ を与える方法$\\beta$ をとり， $\\beta$の$j_\\alpha$番目のイベント $e$ までの部分を $\\beta\u0026rsquo;$ とします． イベント $e$ が $q$ で行われる場合には，$\\beta\u0026rsquo;$ の後に， $q$ に $e_{j_\\alpha + 1}$ まで残り続けて，その後 $\\alpha$ と 同じに振る舞う方法を $\\gamma$ とします． イベント $e$ が $p$ で行われる場合には，$\\beta\u0026rsquo;$ の直後に$q$に 移り，その後$e_{j_\\alpha + 1}$ まで $q$ にいて，その後 $\\alpha$ と 同じに振る舞う方法を $\\gamma$ とします． いずれの場合にも，$\\gamma$ は $X$ を達成する方法であり， $j_\\gamma \u0026lt; j_\\alpha$ となり，矛盾しました．\nACコード https://atcoder.jp/contests/joi2021yo2/submissions/25099364 ","permalink":"https://yamate11.github.io/blog/posts/2021/08-16-event-hopping/","summary":"JOI 2020/2021 二次予選 「イベント巡り (Event Hopping)」 に関する記事です． 公式解説 を読みきれなかったので\u0026hellip;.\n問題へのリンク https://atcoder.jp/contests/joi2021yo2/tasks/joi2021_yo2_c 解法 ちょっと不思議な感じで，小課題3 を (私の感覚では) 自然に解くと， それが満点解法にもなっているという\u0026hellip; (解説を読むまでわからなかったのですけれど)\nソートして，$S_i$ が昇順になっているとします． ナイーブに考えると，次の DP になります．\n dp[i][j] := i番目のイベントに参加する直前までに参加したイベントの 回数が j であるような方法がある (True/False)  遷移としては，dp[i][j] = True となる j について，\n 町 $P_i$ で行われるイベントで，時刻 $S_i + 1$ 以降最も早いものを i1 町 $3 - P_i$ で行われるイベントで， 時刻 $S_i + 1 + D + K(j + 1)$ 以降最も早いものを i2  として，\n dp[i1][j+1] := True dp[i2][j+1] := True  と設定することになります．でも，これは $\\Omega(N^2)$ なので，間に合いません．","title":"イベント巡り (Event Hopping) - JOI 2020/2021 二次予選"},{"content":"Atcoder Beginner Contest 213 (ABC-213) H - Stroll の解法です．\n問題へのリンク \r解法 公式解説 を読んでもよくわからなかったのですが， Motsu_xeさんによる，オフライン・オンライン変換 の説明がわかりやすかったです． 以下の説明は，ほとんど，上の2つの記事に依っています．\n記法を定めます．\n $f(x, i) :=$ 地点$x$に距離$i$で到達する方法の数 $p(x, y, i) :=$ 地点 $x$ と地点 $y$ を結ぶ距離 $i$ の道の数 $X := \\{1, \\ldots, N\\}$  したがって，$f(1, T)$ が求める答です．次の関係が成り立ちます:\n $f(1, 0) = 1$ $f(y, 0) = 0\\quad(y \\neq 1)$ $f(x, i) = \\sum \\{ f(y, j) \\cdot p(x, y, i - j) \\mid y \\in X, j \\in [0, i) \\}$  最後の式は，一見，畳み込みですが，右辺にも $f$ が出てきてしまうので， ただちには FFT に渡せません．ここを 分割統治FFTなる手法で求めようという趣旨であるようです．\nさらに記法です．上の最後の式を少しいじります．\n $ s(x, i, l, m) := \\sum \\{ f(y, j) \\cdot p(x, y, i - j) \\mid y \\in X, j \\in [l, m) \\}$  見比べて，次が成り立ちます:\n $ f(x, i) = s(x, i, 0, i) $  DPで，dp[x, i] を計算していきます． 2つの手続き solve(l, r) と induce(l, m, r) を次のように定めます． a:b は，Python風に半開区間 [a,b) を表すものとします． 配列 v に対して，v[a:b] は，vの，添字a以上b未満の部分です．\nprocedure solve(l, r) {  assume(forall i \\in [0,l), x \\in X. dp[x, i] == f(x, i))  assume(forall i \\in [l,r), x \\in X. dp[x, i] == s(x, i, 0, l))  if (l + 1 == r) return;  m := floor((l + r) / 2);  call solve(l, m);  call induce(l, m, r);  call solve(m, r);  assert(forall i \\in [0,r), x \\in X. dp[x, i] == f(x, i)) }  procedure induce(l, m, r) {  assume(forall i \\in [0,m), x \\in X. dp[x, i] == f(x, i))  assert(forall i \\in [m,r), x \\in X. dp[x, i] == s(x, i, 0, l))  for (x,y such that p[x,y] is non-zero) {  v1 = convolution(dp[x][l:m], p[x, y][0:r-l])  dp[y][m:r] += v1[m-l:r-l]  v2 = convolution(dp[y][l:m], p[x, y][0:r-l])  dp[x][m:r] += v2[m-l:r-l]  }  assert(forall i \\in [0,m), x \\in X. dp[x, i] == f(x, i))  assert(forall i \\in [m,r), x \\in X. dp[x, i] == s(x, i, 1, m)) } $f(x, i) = s(x, i, 0, i)$ であることと， assume と assert の主張から， dp[x, i] == s(x, i, 0, g(i)) (for all x \\in X) となる関数 g が， solve と induce によって，以下のように変化することが分かります．\ninduce を実行する際に，dp[.][l:m] が f(.)[l:m] に一致しているので， (オフラインになって) ここに FFT が使える，ということになります．\n以下を実行すると，答が dp[1][T] に求められます．\nfor x in 1:(N+1) { dp[x, 0] := if x == 1 then 1 else 0 } solve(0, T + 1) 計算量については特に付け加えることはないので，参照している記事をご覧下さい．\nACコード https://atcoder.jp/contests/abc213/submissions/24966725 ","permalink":"https://yamate11.github.io/blog/posts/2021/08-11-stroll/","summary":"解けませんでした．オンライン・オフライン変換を調べて書きました．","title":"Stroll - Atcoder Beginner Contest 213 H"},{"content":"距離を求める際の，ダイクストラ, 0-1BFS, BFSのコーディング方法のまとめです．\n記法 ノードを表すデータ型を Node とする． int や long long や pair\u0026lt;int, int\u0026gt; など．\nダイクストラ  前提: ノード間の距離δ(x,y)が全部非負 距離の候補を優先度付きキューに入れていく． あるノードがキューから初めて取り出されたときにそのノードへの距離が確定する． 使用するデータと初期化  priority_queue のメソッドは，push(), emplace(), pop(), top() など．    using P = pair\u0026lt;ll, Node\u0026gt;; // 距離とノード priority_queue\u0026lt;P, vector\u0026lt;P\u0026gt;, greater\u0026lt;P\u0026gt;\u0026gt; pque; // 優先度付きキュー  // 値 (d, x) は，ノードxへ，長さdのパスがあることを示す． pque.emplace(0, initial_node); // 始点をキューに vector\u0026lt;ll\u0026gt; dist(N, LLONG_MAX); // 距離．始点以外は∞  // Node型 によっては，map\u0026lt;Node, ll\u0026gt; dist; など． dist[initial_node] = 0; // 始点の距離は0   ループ\n pque から取り出した (d, x) について，  dist[x] \u0026lt; d なら，もっと良い d があるということなので，単に捨てる． そうでなければこの d が x への最短距離であることが確定したので， 先に進む． x の 隣接ノード y について，newd = x + δ(x, y) が y への距離の候補なので以下を行う．  dist[y] \u0026lt;= newd なら，単に捨てる そうでなければ，先に進む． dist[y] を newd に更新する． (newd, y) を pque に入れる．        ゴール\n キューから取り出した時点で判断する． キューに入れる時点では，後からもっと短いものがくるかもしれない．    0-1 BFS  前提: ノード間の距離 δ(x,y) がどれも 0 または 1． 基本的にはダイクストラの考え方だが， 優先度付きキューの代わりに，両端キューが使える． 使用するデータと初期化  基本的には，ダイクストラと同じ． deque のメソッドは， { push | emplace | pop }_{ back | front }(), back(), front() など．    using P = pair\u0026lt;ll, Node\u0026gt;; // 距離とノード deque\u0026lt;P\u0026gt; deq; // 両端キュー  // 値 (d, x) は，ノードxへ，長さdのパスがあることを示す． deq.emplace_back(0, initial_node); // 始点をキューに vector\u0026lt;ll\u0026gt; dist(N, LLONG_MAX); // 距離．始点以外は∞  // Node型 によっては，map\u0026lt;Node, ll\u0026gt; dist; など． dist[initial_node] = 0; // 始点の距離は0   ループ\n 基本的にはダイクストラと同じ．違うのは，キューに入れるところだけ． deq から取り出した (d, x) について，  dist[x] \u0026lt; d なら，もっと良い d があったということなので， 単に捨てる． そうでなければこの d が x への最短距離であることが確定したので， 先に進む． x の 隣接ノード y について，newd = x + δ(x, y) が y への距離の候補なので以下を行う．  dist[y] \u0026lt;= newd なら，単に捨てる． そうでなければ，先に進む． dist[y] を newd に更新する． (newd, y) を deq に挿入する．  δ(x, y) = 0 なら，deq の左から挿入する． δ(x, y) = 1 なら，deq の右から挿入する．          ゴール\n ダイクストラと同じ．deq から取り出すときに判断する． (δ(x,y) = 0 なら入れるときに確定するが，気にしなくても良いであろう)    BFS  前提: ノード間の距離が全部1 ノードを初めて見たときに距離が確定する． FIFOキューには距離を入れる必要が無く，ノードだけで良い． 使用するデータと初期化  queue のメソッドは，push(), emplace(), pop(), front(), back() など．    queue\u0026lt;Node\u0026gt; que; // FIFOキュー  // キューに入っているノードは，  // 「自分の距離は確定したが，隣接ノードは未処理」のもの que.push(initial_node); // 始点をキューに vector\u0026lt;ll\u0026gt; dist(N, -1); // 距離．始点以外は未確定  // Node型 によっては，map\u0026lt;Node, ll\u0026gt; dist; など． dist[initial_node] = 0; // 始点の距離は0   ループ\n que から取り出したノード x の各隣接ノード y について，  dist[y] \u0026gt;= 0 (すでに距離が確定) の場合は，単に捨てる． 未確定ならば，先に進む． dist[y] に dist[x] + 1 を設定する． y をキューに入れる．      ゴール\n dist[] に値を設定するときに判断する．    ","permalink":"https://yamate11.github.io/blog/posts/2021/07-03-bfs-dijkstra/","summary":"距離を求める際の，ダイクストラ, 0-1BFS, BFSのコーディング方法のまとめです．\n記法 ノードを表すデータ型を Node とする． int や long long や pair\u0026lt;int, int\u0026gt; など．\nダイクストラ  前提: ノード間の距離δ(x,y)が全部非負 距離の候補を優先度付きキューに入れていく． あるノードがキューから初めて取り出されたときにそのノードへの距離が確定する． 使用するデータと初期化  priority_queue のメソッドは，push(), emplace(), pop(), top() など．    using P = pair\u0026lt;ll, Node\u0026gt;; // 距離とノード priority_queue\u0026lt;P, vector\u0026lt;P\u0026gt;, greater\u0026lt;P\u0026gt;\u0026gt; pque; // 優先度付きキュー  // 値 (d, x) は，ノードxへ，長さdのパスがあることを示す． pque.emplace(0, initial_node); // 始点をキューに vector\u0026lt;ll\u0026gt; dist(N, LLONG_MAX); // 距離．始点以外は∞  // Node型 によっては，map\u0026lt;Node, ll\u0026gt; dist; など． dist[initial_node] = 0; // 始点の距離は0   ループ","title":"距離: BFSとダイクストラ"},{"content":"キーエンスプログラミングコンテスト 2021 E - Greedy Ant に関する記事です．\n問題へのリンク https://atcoder.jp/contests/keyence2021/tasks/keyence2021 解法 公式解説 の通りではありますが，若干表現を変えます．\nすぬけ君が，蟻から遠い飴を取っても，蟻の行動には直ちには影響を与えません． そういう状況ではすぬけ君は「スキップ」することにして，後から蟻がその飴に近づいてきたとき (左右いずれかで蟻の最も近い飴になったとき) に取ることにしても，ゲームの意味が変わりません． つまり，次のようにゲームを言い変えることができます． (両端などの扱いはサボっています)\n初期化: // 蟻の初期位置を 2n + 1 とする．  l := n // 蟻に最も近い左の飴の位置が 2l  r := n + 1 // 蟻に最も近い右の飴の位置が 2r  k := 0 // すぬけ君の「スキップ」回数 ループ:  k += 1  while k \u0026gt; 0:  match すぬけ君の選択():  case なし: break  case 左: すぬけ君が 2l の飴を取る; l -= 1  case 右: すぬけ君が 2r の飴を取る; r += 1  k -= 1  蟻が，2l, 2r の飴のおいしい方を取る  取った方に応じて l -= 1 または r += 1 そこで， f(l,r,k) を，「上記 while の先頭位置で，l,r,k がこの値である時に，すぬけ君がこのあと取る得点の最大値」として 定義します． 次の漸化式が書けます．\nf(l, r, k) = max( none(l, r, k)  , a[l] + f(l - 1, r, k - 1)  , a[r] + f(l, r + 1, k - 1)  ) ただし，a[l] \u0026gt; a[r] のとき，none(l, r, k) = f(l - 1, r, k + 1) そうでないとき， none(l, r, k) = f(l, r + 1, k + 1) f(n, n + 1, 1) が求める答です． fは，メモ化再帰で計算でき，時間計算量は O(N^3)です．\n経緯 コンテスト中も解けず，復習でも答を思い出せませんでした．blogに書くことで覚えられるか???\n","permalink":"https://yamate11.github.io/blog/posts/2021/07-22-greedy-ant/","summary":"キーエンスプログラミングコンテスト 2021 E - Greedy Ant に関する記事です．\n問題へのリンク https://atcoder.jp/contests/keyence2021/tasks/keyence2021 解法 公式解説 の通りではありますが，若干表現を変えます．\nすぬけ君が，蟻から遠い飴を取っても，蟻の行動には直ちには影響を与えません． そういう状況ではすぬけ君は「スキップ」することにして，後から蟻がその飴に近づいてきたとき (左右いずれかで蟻の最も近い飴になったとき) に取ることにしても，ゲームの意味が変わりません． つまり，次のようにゲームを言い変えることができます． (両端などの扱いはサボっています)\n初期化: // 蟻の初期位置を 2n + 1 とする．  l := n // 蟻に最も近い左の飴の位置が 2l  r := n + 1 // 蟻に最も近い右の飴の位置が 2r  k := 0 // すぬけ君の「スキップ」回数 ループ:  k += 1  while k \u0026gt; 0:  match すぬけ君の選択():  case なし: break  case 左: すぬけ君が 2l の飴を取る; l -= 1  case 右: すぬけ君が 2r の飴を取る; r += 1  k -= 1  蟻が，2l, 2r の飴のおいしい方を取る  取った方に応じて l -= 1 または r += 1 そこで， f(l,r,k) を，「上記 while の先頭位置で，l,r,k がこの値である時に，すぬけ君がこのあと取る得点の最大値」として 定義します． 次の漸化式が書けます．","title":"Greedy Ant - キーエンスプログラミングコンテスト2021 E"},{"content":"gcc (g++) の policy-based data structure の中にある tree (の競技プログラミングでの利用) に関する記事です．\nリンク  Policy-based Data Structure (GCC online docs) Codeforces admant\u0026#39;s blog   まとめ 以下の操作ができる set や map\n x を指定して，x より小さい要素がいくつあるか数える n を指定して，n 番目に小さい要素へのイテレータを取得する  先頭部分 #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;using namespace __gnu_pbds; 型の定義 例: pair\u0026lt;int, int\u0026gt; の集合 using pair_t = pair\u0026lt;int, int\u0026gt;; using ordered_set = tree\u0026lt;  pair_t,  null_type,  less\u0026lt;pair_t\u0026gt;,  rb_tree_tag,  tree_order_statistics_node_update  \u0026gt;; 例: string から int へのマップ using ordered_map = tree\u0026lt;  string,  int,  less\u0026lt;string\u0026gt;,  rb_tree_tag,  tree_order_statistics_node_update \u0026gt;; 機能の呼び出し  ordered_set os;  os.insert(pair_t(0,0));  os.insert(pair_t(1,0));  os.insert(pair_t(1,1));  os.insert(pair_t(2,0));  os.insert(pair_t(2,1));  // order_of_key: 指定した値よりも小さい要素の数  assert(os.order_of_key(pair_t(-1,0)) == 0);  assert(os.order_of_key(pair_t(0,0)) == 0);  assert(os.order_of_key(pair_t(0,1)) == 1);  assert(os.order_of_key(pair_t(1,0)) == 1);  assert(os.order_of_key(pair_t(1,1)) == 2);  assert(os.order_of_key(pair_t(100,0)) == 5);  // find_by_order: 指定した位置の要素へのイテレータ  assert(*os.find_by_order(0) == pair_t(0,0));  assert(*os.find_by_order(2) == pair_t(1,1));  assert(*os.find_by_order(4) == pair_t(2,1));  assert(os.find_by_order(5) == os.end()); 注意  必ずしも速くないらしい．Fenwick tree なり segment tree の倍くらい遅いというレポートがある multiset や multimap に相当する機能はない (リンク )  ","permalink":"https://yamate11.github.io/blog/posts/2021/06-05-policy-based-ds/","summary":"gcc (g++) の policy-based data structure の中にある tree (の競技プログラミングでの利用) に関する記事です．\nリンク  Policy-based Data Structure (GCC online docs) Codeforces admant\u0026#39;s blog   まとめ 以下の操作ができる set や map\n x を指定して，x より小さい要素がいくつあるか数える n を指定して，n 番目に小さい要素へのイテレータを取得する  先頭部分 #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;using namespace __gnu_pbds; 型の定義 例: pair\u0026lt;int, int\u0026gt; の集合 using pair_t = pair\u0026lt;int, int\u0026gt;; using ordered_set = tree\u0026lt;  pair_t,  null_type,  less\u0026lt;pair_t\u0026gt;,  rb_tree_tag,  tree_order_statistics_node_update  \u0026gt;; 例: string から int へのマップ using ordered_map = tree\u0026lt;  string,  int,  less\u0026lt;string\u0026gt;,  rb_tree_tag,  tree_order_statistics_node_update \u0026gt;; 機能の呼び出し  ordered_set os;  os.","title":"policy-based data structure の tree"},{"content":"きたまさ法に関する記事です． よすぽさんの記事 を参照して書きました．\n問題設定 整数 $ d_0 , \\ldots, d_{ k - 1 }$ と $a_0, \\ldots, a_{k - 1}$ が与えられている． 漸化式 $ a_{n + k} = d_{0} a_{n} + \\cdots + d_{ k - 1 } a_{n + k - 1}$ で定義される数列の $a_n$ を $O( k^2 \\log n )$ で求める．\n行列 $$ A = \\begin{bmatrix} d_{ k - 1 } \u0026amp;\\cdots \u0026amp; \\cdots \u0026amp; d_{ 0 } \\\\ 1 \u0026amp; \u0026amp; \\Large{0} \u0026amp; 0 \\\\ \u0026amp; \\ddots \u0026amp; \u0026amp; 0\\\\ \\Large{0} \u0026amp; \u0026amp; 1 \u0026amp; 0 \\\\ \\end{bmatrix} $$\nとすれば，\n$$ \\begin{bmatrix} a_n \\\\ \\vdots \\\\ a_{ n - k + 1} \\end{bmatrix} = A^{ n - k + 1 } \\begin{bmatrix} a_{ k - 1 } \\\\ \\vdots \\\\ a_{ 0 } \\end{bmatrix} $$\nなので，$A^n$ が計算できれば良い．あるいは，$A^n$ の最上行だけでも良い． 計算量が $O( k^2 \\log n)$ で押さえられて欲しいが， 普通の行列累乗だと$O( k^3 \\log n)$ になる．\n計算 $\\newcommand{\\bsww}{\\boldsymbol{w}}$ $\\newcommand{\\bsx}{\\boldsymbol{x}}$ $\\newcommand{\\bsy}{\\boldsymbol{y}}$ $\\newcommand{\\bsdd}{\\boldsymbol{d}}$ $\\bsy_i$ たちを行ベクトルとする．$\\bsdd = [d_{ k - 1 }, \\ldots, d_0]$ とする． また，$\\text{sft}([z_0, \\ldots, z_{ k - 1 }]) = [z_1, \\ldots, z_{ k - 1 }, 0]$ とする． 計算することによって以下がわかる:\n$$ A \\left[ \\begin{array}{c} \\bsy_1 \\\\ \\bsy_2 \\\\ \\vdots \\\\ \\bsy_k \\end{array}\\right] = \\left[ \\begin{array}{c} * \\\\ \\bsy_1 \\\\ \\vdots \\\\ \\bsy_{ k - 1 } \\end{array}\\right] ,\\quad \\left[\\begin{array}{c} \\bsy_1 \\\\ \\vdots \\\\ \\bsy_k \\end{array}\\right] A = \\left[\\begin{array}{c} y_{11}\\bsdd + \\text{sft}( \\bsy_{1} ) \\\\ \\vdots \\\\ y_{k1}\\bsdd + \\text{sft}( \\bsy_{k} ) \\\\ \\end{array}\\right] \\tag{1}$$\nしたがって，$ A^n $ の最下行の行ベクトルを $\\bsx(n)$ と書くと，以下が成り立つ:\n$$ A^n = \\left[\\begin{array}{c} \\bsx( n + k - 1) \\\\ \\vdots \\\\ \\bsx( n ) \\\\ \\end{array}\\right] \\tag{2} $$\n(1)の右の式より， $\\bsx(n)$ の第1成分を $x$ とすると， $$ \\bsx (n + 1) = x \\bsdd + \\text{sft}( \\bsx(n) ) \\tag{3}$$ であることが分かる． また，$A^n$ の列ベクトルを $\\bsww_1^T, \\ldots, \\bsww_k^T$ とし，\n$$ \\left[\\begin{array}{c} \\bsx(2n + k - 1) \\\\ \\vdots \\\\ \\bsx(2n) \\\\ \\end{array}\\right] = A^{2n} = (A^{n})^{2} = \\left[\\begin{array}{c} \\bsx(n + k - 1) \\\\ \\vdots \\\\ \\bsx(n) \\\\ \\end{array}\\right] \\left[\\begin{array}{c} ~ \\\\ \\bsww_1^T \u0026amp; \\cdots \u0026amp; \\bsww_k^T \\\\ ~ \\\\ \\end{array}\\right] $$\nと書いて，最下行を比較すると，\n$$ \\bsx(2n) = [ \\bsx(n)\\cdot \\bsww_1, \\ldots, \\bsx(n)\\cdot \\bsww_k ] \\tag{4}$$\nである．\n以上より，次の手順で $a_n$ を計算することができる．\n $a_n = \\bsx(n - k + 1 + k - 1) \\cdot [a_{ k - 1 }, \\cdots, a_{ 0 }]$ なので，$\\bsx(n)$ が求められれば良い． $n$ を，「$+1$」 と 「$\\times 2$」 で書く．たとえば，$n = 18$ なら，$n = ((1 \\times 2 \\times 2 \\times 2) + 1) \\times 2$． この内側から順に $\\bsx(n)$ を求めていく． $+1$ のときには，(3) を適用する．この計算量は，$O(k)$ $\\times 2$ のときには，まず (3) を $k - 1$ 回適用して，$\\bsx(n), \\ldots, \\bsx(n + k - 1)$ を求める． すると(2) より $A^{n}$ が決まるので，(4) の右辺が計算できる．この計算量は，$O(k^2)$  ","permalink":"https://yamate11.github.io/blog/posts/2021/04-30-kitamasa/","summary":"きたまさ法に関する記事です． よすぽさんの記事 を参照して書きました．\n問題設定 整数 $ d_0 , \\ldots, d_{ k - 1 }$ と $a_0, \\ldots, a_{k - 1}$ が与えられている． 漸化式 $ a_{n + k} = d_{0} a_{n} + \\cdots + d_{ k - 1 } a_{n + k - 1}$ で定義される数列の $a_n$ を $O( k^2 \\log n )$ で求める．\n行列 $$ A = \\begin{bmatrix} d_{ k - 1 } \u0026amp;\\cdots \u0026amp; \\cdots \u0026amp; d_{ 0 } \\\\ 1 \u0026amp; \u0026amp; \\Large{0} \u0026amp; 0 \\\\ \u0026amp; \\ddots \u0026amp; \u0026amp; 0\\\\ \\Large{0} \u0026amp; \u0026amp; 1 \u0026amp; 0 \\\\ \\end{bmatrix} $$","title":"きたまさ法"},{"content":"二項係数 binom(n, r) を，小さい素数 p に対して mod p で求める方法に関する記事です．\n観察 p = 3 に関していくつか書いてみると次のようになっている．\n 0 1  1 1 1  2 1 2 1  10 1 0 0 1  11 1 1 0 1 1  12 1 2 1 1 2 1  20 1 0 0 2 0 0 1  21 1 1 0 2 2 0 1 1  22 1 2 1 2 1 2 1 2 1 100 1 0 0 0 0 0 0 0 0 1 101 1 1 0 0 0 0 0 0 0 1 1 102 1 2 1 0 0 0 0 0 0 1 2 1 110 1 0 0 1 0 0 0 0 0 1 0 0 1 111 1 1 0 1 1 0 0 0 0 1 1 0 1 1 112 1 2 1 1 2 1 0 0 0 1 2 1 1 2 1 120 1 0 0 2 0 0 1 0 0 1 0 0 2 0 0 1 こんな感じの構造になっている:\n  例: p = 3 例として $p = 3$ の場合には， 上の図から，以下のように計算できる．ただし，$q \u0026lt; 3^k$．\n$$ \\begin{eqnarray} % \\binom00 \u0026amp;=\u0026amp; 1 \\\\ % \\binom{3^k + q}{r} \u0026amp;=\u0026amp; \\begin{cases} \\displaystyle{\\binom{q}{r}} \u0026amp; \\text{if }\\; 0 \\leq r \\leq q \\\\ \\displaystyle{\\binom{q}{r - 3^k}} \u0026amp; \\text{if }\\; 3^k \\leq r \\\\ 0 \u0026amp; \\text{if }\\; q \u0026lt; r \u0026lt; 3^k \\\\ \\end{cases} \\\\ % \\binom{2\\cdot 3^k + q}{r} \u0026amp;=\u0026amp; \\begin{cases} \\displaystyle{\\binom{q}{r}} \u0026amp; \\text{if }\\; 0 \\leq r \\leq q \\\\ \\displaystyle{2\\binom{q}{r - 3^k}} \u0026amp; \\text{if }\\; 3^k \\leq r \\leq 2\\cdot 3^k + q \\\\ \\displaystyle{\\binom{q}{r - 2\\cdot 3^k}} \u0026amp; \\text{if }\\; 2\\cdot 3^k \\leq r \\\\ 0 \u0026amp; \\text{if }\\; q \u0026lt; r \u0026lt; 3^k,\\; 3^k + q \u0026lt; r \u0026lt; 2\\cdot 3^k \\\\ \\end{cases} \\\\ % \\end{eqnarray} $$\n列 $s(n) := [\\binom{n}{r} \\mid 0 \\leq r \\leq n]$ が必要ならば，以下のように計算できる． $$ \\begin{eqnarray} s(0) \u0026amp;=\u0026amp; [1] \\\\ s(3^k + q) \u0026amp;=\u0026amp; s(q) ⧺ z ⧺ s(q) \\\\ s(2\\cdot 3^k + q) \u0026amp;=\u0026amp; s(q) ⧺ z ⧺ 2 \\cdot s(q) ⧺ z ⧺ s(q) \\end{eqnarray} $$ ただし，$z$ は，$0$ を $3^k - q - 1$ 個並べた列．\nbinom(n, r) 一般に，小さい素数$p$ に対しては，以下のようになる．\n$n = c\\cdot p^k + q$，$1 \\leq c \u0026lt; p$，$q \u0026lt; p^k$，$r = d\\cdot p^k + t$，$0 \\leq d \u0026lt; p$，$t \u0026lt; p^k$ とすると，\n$$ \\begin{eqnarray} \\binom{0}{0} \u0026amp;=\u0026amp; 1 \\\\ \\binom{n}{r} = \\binom{c\\cdot p^k + q}{d\\cdot p^k + t} \u0026amp;=\u0026amp; \\begin{cases} \\displaystyle{\\binom{c}{d}\\binom{q}{t}} \u0026amp; \\text{if }\\; 0 \\leq t \\leq q \\\\ 0 \u0026amp; \\text{if }\\; q \u0026lt; t \\\\ \\end{cases} \\\\ \\end{eqnarray} $$\n$\\binom{n}{r}$ の時間計算量は $O(\\log n)$．\n列 $s(n) := [\\binom{n}{r} \\mid 0 \\leq r \\leq n]$ が必要ならば，以下のように計算できる． 記号は上と同様． $$ \\newcommand{\\mybinom}[2]{\\displaystyle{\\binom{#1}{#2}}} \\begin{eqnarray} s(0) \u0026amp;=\u0026amp; [1] \\\\ s(n) = s(c\\cdot p^k + q) \u0026amp;=\u0026amp; \\mybinom{c}{0}s(q) ⧺ z ⧺ \\mybinom{c}{1}s(q) ⧺ z ⧺ \\cdots ⧺ \\mybinom{c}{c}s(q) \\\\ \\end{eqnarray} $$ $z$は，$0$ を $p^k - q - 1$ 個並べた列． $s(n)$ の時間計算量は $O(n)$．\nAtCoder AtCoder ARC117 C - Tricolor Pyramid で，上の手順が使える．ただし，解説 の方法の方が思いつきやすいし，(列を求めるだけだから) 計算量は同じ．\n","permalink":"https://yamate11.github.io/blog/posts/2021/04-27-binom-mod/","summary":"二項係数 binom(n, r) を，小さい素数 p に対して mod p で求める方法に関する記事です．\n観察 p = 3 に関していくつか書いてみると次のようになっている．\n 0 1  1 1 1  2 1 2 1  10 1 0 0 1  11 1 1 0 1 1  12 1 2 1 1 2 1  20 1 0 0 2 0 0 1  21 1 1 0 2 2 0 1 1  22 1 2 1 2 1 2 1 2 1 100 1 0 0 0 0 0 0 0 0 1 101 1 1 0 0 0 0 0 0 0 1 1 102 1 2 1 0 0 0 0 0 0 1 2 1 110 1 0 0 1 0 0 0 0 0 1 0 0 1 111 1 1 0 1 1 0 0 0 0 1 1 0 1 1 112 1 2 1 1 2 1 0 0 0 1 2 1 1 2 1 120 1 0 0 2 0 0 1 0 0 1 0 0 2 0 0 1 こんな感じの構造になっている:","title":"binom(n, r) を小さい素数pに対して mod p で求める"},{"content":"Lagrange補間に関する記事です．\n要約 $$ f(x) = \\sum_{i = 0}^{k}\\frac{ f(i) }{ (-1)^{k - i} \\; i ! \\; (k - i) ! } \\cdot \\frac{ 1 }{ x - i } \\cdot \\prod_{j=0}^{k} ( x - j ) $$\n詳細 \\( k \\) 次多項式 $f(x)$ について，$x = 0, \\ldots, k$ の値が，$f(0) = v_0, \\ldots, f(k) = v_k$ と分かっているときに， $f(x)$ (の各係数) を決める方法． 連立方程式を解く方法だと，逆行列を計算する必要があるから，\\( \\Omega( k^3 ) \\) になってしまうが， Lagrange補間だと，$O(k^2)$ で済む．\n$I = \\{0, \\ldots, k\\}$, $I_i = I \\setminus \\{ i \\}$ とする．$i = 0, \\ldots, k$ について，$k$ 次の多項式 $g_i(x)$ を， 次で定義する．\n$$g_i(x) = \\frac{ \\prod \\{ x - j \\mid j \\in I_i \\} }{ \\prod \\{ i - j \\mid j \\in I_i \\} } $$\n$j = 0, \\ldots, k$ について，\n$$ g_i (j) = \\begin{cases} 1 \u0026amp; \\text{ if } i =j \\\\ 0 \u0026amp; \\text{ if } i \\neq j \\end{cases}$$\nであることに注意すると，\n$$ f(x) = \\sum_{i = 0}^{k} g_i(x)v_i $$\nとなることがわかる (左右両辺とも $k$ 次多項式で，$k+1$ 個の値が一致する)．\n$ g_i(x) $ の分母を $c_i$ と書くと，\n$$ c_i = (-1)^{k - i} \\; i ! \\; (k - i) ! $$\nであるから，これらは，事前に $k$ までの階乗を $O(k)$ で計算しておけば，$O(1)$ で求められる．\n$g_i(x)$ の分子は，\n$$ \\frac{1}{x - i}\\cdot\\prod_{j=0}^{k} (x-j) $$\nであるから，まず $\\prod_{j=0}^{k} (x-j)$ を $O(k^2)$ で計算しておけば，各$i$について$O(k)$で，全体で$O(k^2)$で 計算できる．\nAtCoder AtCoder ABC137 F - Polynomial Construction は， Lagrange補間を用いて解ける． ただし，解説 に書かれている方法の方が簡単．\n","permalink":"https://yamate11.github.io/blog/posts/2021/04-22-lagrange/","summary":"Lagrange補間に関する記事です．\n要約 $$ f(x) = \\sum_{i = 0}^{k}\\frac{ f(i) }{ (-1)^{k - i} \\; i ! \\; (k - i) ! } \\cdot \\frac{ 1 }{ x - i } \\cdot \\prod_{j=0}^{k} ( x - j ) $$\n詳細 \\( k \\) 次多項式 $f(x)$ について，$x = 0, \\ldots, k$ の値が，$f(0) = v_0, \\ldots, f(k) = v_k$ と分かっているときに， $f(x)$ (の各係数) を決める方法． 連立方程式を解く方法だと，逆行列を計算する必要があるから，\\( \\Omega( k^3 ) \\) になってしまうが， Lagrange補間だと，$O(k^2)$ で済む．\n$I = \\{0, \\ldots, k\\}$, $I_i = I \\setminus \\{ i \\}$ とする．$i = 0, \\ldots, k$ について，$k$ 次の多項式 $g_i(x)$ を， 次で定義する．","title":"Lagrange補間"},{"content":"行列木定理についての記事です． これを使う問題が，第二回日本最強プログラマー学生選手権 の G - Spanning Tree として出題されました．\n定理 自己ループのない無向グラフ $G$ がある．頂点を $1, \\ldots, N$ とする． 対称 $N\\times N$ 行列 $A = (a_{ij})$ を，次で定める:\n $a_{ii} = $ 頂点$i$の出次数 $a_{ij} = - ( i \\text{と} j \\text{を結ぶ辺の数} )$  このとき，A のすべての余因子は等しく，G の全域木の数と一致する．\n例   上のグラフでは，\n$$ A = \\begin{bmatrix} 3 \u0026amp; -1 \u0026amp; 0 \u0026amp; -2 \\\\ -1 \u0026amp; 3 \u0026amp; -1 \u0026amp; -1 \\\\ 0 \u0026amp; -1 \u0026amp; 2 \u0026amp; -1 \\\\ -2 \u0026amp; -1 \u0026amp; -1 \u0026amp; 4 \\end{bmatrix} $$\n$(4,4)-$余因子行列は\n$$ M_{4,4} = \\begin{bmatrix} 3 \u0026amp; -1 \u0026amp; 0 \\\\ -1 \u0026amp; 3 \u0026amp; -1 \\\\ 0 \u0026amp; -1 \u0026amp; 2\n\\end{bmatrix} $$\nこの行列式の値 13 が，グラフの全域木の数である．\n","permalink":"https://yamate11.github.io/blog/posts/2021/04-18-kirchhoff/","summary":"行列木定理についての記事です． これを使う問題が，第二回日本最強プログラマー学生選手権 の G - Spanning Tree として出題されました．\n定理 自己ループのない無向グラフ $G$ がある．頂点を $1, \\ldots, N$ とする． 対称 $N\\times N$ 行列 $A = (a_{ij})$ を，次で定める:\n $a_{ii} = $ 頂点$i$の出次数 $a_{ij} = - ( i \\text{と} j \\text{を結ぶ辺の数} )$  このとき，A のすべての余因子は等しく，G の全域木の数と一致する．\n例   上のグラフでは，\n$$ A = \\begin{bmatrix} 3 \u0026amp; -1 \u0026amp; 0 \u0026amp; -2 \\\\ -1 \u0026amp; 3 \u0026amp; -1 \u0026amp; -1 \\\\ 0 \u0026amp; -1 \u0026amp; 2 \u0026amp; -1 \\\\ -2 \u0026amp; -1 \u0026amp; -1 \u0026amp; 4 \\end{bmatrix} $$","title":"行列木定理"},{"content":"CodeForces Round #431 (Div.2) E - Goodbye Souvenir についての記事です．\n問題へのリンク https://codeforces.com/contest/849/problem/E 経緯 Yoika さんが主催している Morningforces というバーチャルコンテスト で出て，解けませんでした． 公式解説 を読んだのですが，最後に出てくる座標圧縮云々がよく分かりませんでした．\n問題概要 整数列 $a = a_1, \\ldots, a_k $ に対して，$m(a)$ を，$a$ に現れる各数 $x$ に対して，$x$ が最後に現れる位置と最初に現れる位置との差の総和として定義する．例えば，$m(1, 2, 3, 1, 3, 2, 1) = (7-1) + (6-2) + (5- 3) = 12$．最初に長さ n の整数列 a が与えられる．各要素は1以上n以下．次の2種類のクエリ (全部で$m$個) を処理せよ．$ 1 \\leq n, m \\leq 100,000$．\n p, x が与えられて，aのp番目の要素をxに書き換える． l, r が与えられて，$ m(a[l:r]) $ を求める．  解法 ということで，実装手段を除いては公式解説をなぞっています．\n$x$ が出てくる位置を $p_1, \\ldots, p_k$ と書くと，$x$ による寄与は $ (p_2 - p_1) + \\cdots + ( p_k - p_{ k - 1 } ) $ である． ある数が位置 s に現れ，次には位置 t に現れるという状況の時，2次元平面内の 点 $(t, s)$ に値 $ t - s $ を割り振ることにする． すると，位置 p から q までの a の部分列での値は，2次元平面内の長方形 $ [ p, q + 1) \\times [p, n + 1) $ に割り振られた値の総和に等しい．\nつまり，長方形 $ [1, n + 1) \\times [1, n + 1) $ に対して，以下の操作が高速に行えれば良い．\n 1点に値を割り振る． 部分長方形に割り振られた値の総和を求める．  セグメント木と同じ考え方でできる． 通常のセグメント木は1次元で区間を2分割していくが， 2次元になっても，長方形を4分割することにすれば原理は同じ． ただし，最初に全部のセルを作ろうとすると $ \\Omega ( n^2 )$ 必要なので間に合わない． そこで，ノードは必要になったときだけ生成する． 下のコードを見れば， 普通のセグメント木と同じように書けることが分かると思う． どちらのクエリも $O(\\log n)$ で処理できるので， 全体で計算量は $ O(m\\log n) $ となる．\nACコード https://codeforces.com/contest/849/submission/104679665 ","permalink":"https://yamate11.github.io/blog/posts/2021/01-18-goodbye-souvenir/","summary":"CodeForces Round #431 (Div.2) E - Goodbye Souvenir についての記事です．\n問題へのリンク https://codeforces.com/contest/849/problem/E 経緯 Yoika さんが主催している Morningforces というバーチャルコンテスト で出て，解けませんでした． 公式解説 を読んだのですが，最後に出てくる座標圧縮云々がよく分かりませんでした．\n問題概要 整数列 $a = a_1, \\ldots, a_k $ に対して，$m(a)$ を，$a$ に現れる各数 $x$ に対して，$x$ が最後に現れる位置と最初に現れる位置との差の総和として定義する．例えば，$m(1, 2, 3, 1, 3, 2, 1) = (7-1) + (6-2) + (5- 3) = 12$．最初に長さ n の整数列 a が与えられる．各要素は1以上n以下．次の2種類のクエリ (全部で$m$個) を処理せよ．$ 1 \\leq n, m \\leq 100,000$．\n p, x が与えられて，aのp番目の要素をxに書き換える． l, r が与えられて，$ m(a[l:r]) $ を求める．  解法 ということで，実装手段を除いては公式解説をなぞっています．","title":"CodeForces Round #431 (Div.2) E - Goodbye Souvenir"},{"content":"C++ での乱数の使い方のメモです．\n典型的なコード ll n; cin \u0026gt;\u0026gt; n;  random_device rand_dev; mt19937 rng(rand_dev()); uniform_int_distribution\u0026lt;ll\u0026gt; dist(1, n);  for (ll i = 0; i \u0026lt; 10; i++) cout \u0026lt;\u0026lt; dist(rng) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; クラス random_device  マニュアル  オブジェクトは乱数発生器．non-deterministic な乱数を生成する． operator() を実行すると，unsigned int の乱数が返り，状態が進む． 実行は高価である可能性がある．  クラス mt19937  マニュアル  32bitメルセンヌツィッター乱数発生器 64bitメルセンヌツィッター乱数発生器 の mt19937_64 というクラスもある． o.operator() を実行すると，uint_fast32_t の乱数が返り，状態が進む． コンストラクタに seed を渡す． デフォルトコンストラクタは引数をとらず，seed = 5489u を用いる．したがって，次のように書けば，どの実行でも同じ値が生成される．  mt19937 rng; クラス uniform_int_distribution  マニュアル  乱数分布を一様分布とする．constructor に a, b を指定すると，a以上b以下の一様分布． T は int や ll など．デフォルトは int． operator() は，引数に乱数発生器を取り，一様分布を生成する． 他の乱数分布クラスとコンストラクタの例:  uniform_real_distribution\u0026lt;double\u0026gt; dist1(a, b); normal_distribution\u0026lt;double\u0026gt; dist2(mean, stddev); ","permalink":"https://yamate11.github.io/blog/posts/2021/01-13-random/","summary":"C++ での乱数の使い方のメモです．\n典型的なコード ll n; cin \u0026gt;\u0026gt; n;  random_device rand_dev; mt19937 rng(rand_dev()); uniform_int_distribution\u0026lt;ll\u0026gt; dist(1, n);  for (ll i = 0; i \u0026lt; 10; i++) cout \u0026lt;\u0026lt; dist(rng) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; クラス random_device  マニュアル  オブジェクトは乱数発生器．non-deterministic な乱数を生成する． operator() を実行すると，unsigned int の乱数が返り，状態が進む． 実行は高価である可能性がある．  クラス mt19937  マニュアル  32bitメルセンヌツィッター乱数発生器 64bitメルセンヌツィッター乱数発生器 の mt19937_64 というクラスもある． o.operator() を実行すると，uint_fast32_t の乱数が返り，状態が進む． コンストラクタに seed を渡す． デフォルトコンストラクタは引数をとらず，seed = 5489u を用いる．したがって，次のように書けば，どの実行でも同じ値が生成される．  mt19937 rng; クラス uniform_int_distribution  マニュアル  乱数分布を一様分布とする．constructor に a, b を指定すると，a以上b以下の一様分布． T は int や ll など．デフォルトは int． operator() は，引数に乱数発生器を取り，一様分布を生成する． 他の乱数分布クラスとコンストラクタの例:  uniform_real_distribution\u0026lt;double\u0026gt; dist1(a, b); normal_distribution\u0026lt;double\u0026gt; dist2(mean, stddev); ","title":"乱数の作り方"},{"content":"AtCoder Regular Contest (ARC) 056 D - サケノミ についての記事です．\n問題へのリンク  状況 解けないだけではなく，答を見てもなかなかわからなかったので，整理するために書いています．下記を参考にしています．\n 公式解説  kmjpさんのブログ   解法 時刻 $2j+1$ にドリンクを飲むような飲み方全部に関する，時刻 $2j+1$ 時点での美味しさの総和の最大値を $x(j)$ とする． 時刻 $2i$ に全部のグラスが空だったとき，半開区間 $(2i, 2j]$ に属する時刻に注がれるドリンクの美味しさの総和を $y(i, j)$ とすると， $x(j) = \\max \\{ x(i) + y(i, j) \\mid i \u0026lt; j \\} $ である．ここで，$z(i, j) = x(i) + y(i, j)$ と書くことにする．時刻 $j$ に注がれるドリンク全体の集合を $P$ とし，$ p \\in P $ に対して時刻 $2j$ の一回前にドリンク $p$ が注がれる時刻を $l_p$ とする (時刻 j が初回なら，$l_p = 0$ とする)．すると，次が成り立つ．\n $x(j) = z(j,j) = \\max \\{ z(i,j) \\mid i \u0026lt; j \\}$ $z(i,j) - z(i, j-1) = \\sum \\{ w_p \\mid p \\in P,; i \\in [l_p, j) \\}$  したがって，ベクトル $ v_j = ( z(i,j) \\mid i \u0026lt; j ) $ を $j$ に関して遅延伝搬セグメント木 (区間和，区間最大値) で更新していくことができ，$O(M \\log M)$ (ここに $M = \\sum \\{ M_i \\mid i \\leq N \\}$ )で計算できる．答は最終時刻 $T$ に対する $x(T) = z(T, T)$ である．\nその他 似たような問題を見たことがあるような気がして探してみると，EDPC の W. Intervals とほぼ同じでした．こちらの方が古いですが．何度やっても解けません．\n","permalink":"https://yamate11.github.io/blog/posts/2021/01-06-sakenomi/","summary":"AtCoder Regular Contest (ARC) 056 D - サケノミ についての記事です．\n問題へのリンク  状況 解けないだけではなく，答を見てもなかなかわからなかったので，整理するために書いています．下記を参考にしています．\n 公式解説  kmjpさんのブログ   解法 時刻 $2j+1$ にドリンクを飲むような飲み方全部に関する，時刻 $2j+1$ 時点での美味しさの総和の最大値を $x(j)$ とする． 時刻 $2i$ に全部のグラスが空だったとき，半開区間 $(2i, 2j]$ に属する時刻に注がれるドリンクの美味しさの総和を $y(i, j)$ とすると， $x(j) = \\max \\{ x(i) + y(i, j) \\mid i \u0026lt; j \\} $ である．ここで，$z(i, j) = x(i) + y(i, j)$ と書くことにする．時刻 $j$ に注がれるドリンク全体の集合を $P$ とし，$ p \\in P $ に対して時刻 $2j$ の一回前にドリンク $p$ が注がれる時刻を $l_p$ とする (時刻 j が初回なら，$l_p = 0$ とする)．すると，次が成り立つ．","title":"AtCoder Regular Contest 056 D - サケノミ"}]