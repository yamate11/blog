[{"content":"AtCoder Regular Contest 128 (ARC 128) C - Max Dot を解説ACしました． 公式解説より，多少行間が埋まっていると思います．\n問題概要 整数N, M, Sと整数列 A = (A_1, .., A_N) が与えられる． 次の条件を満たす非負実数列 (x_1, ..., x_N) を作る: ・ 0 \u0026lt;= x_1 \u0026lt;= x_2 \u0026lt;= ... \u0026lt;= x_N \u0026lt;= M ・ x_1 + x_2 + ... + x_N = S \\sum {A_i × x_i | i = 1, ..., N } の最大値を求めよ． 制約: N \u0026lt;= 5000; M,S,A_i \u0026lt;= 10^6; S \u0026lt;= NM; 問題へのリンク 解法 $x_0 := 0$ として，$y_i := x_{i+1} - x_i$ ($i = 0, \\ldots, N-1$) とすると， 次のように言い換えられる:\n 求める最大値: $\\sum_{i = 0}^{N-1} B_i y_i$． ただし，$B_i := \\sum_{j = i + 1}^{N} A_j$． 満たすべき条件:  $y_i \\geq 0$ $y_0 + \\cdots + y_{N-1} \\leq M$ $N \\cdot y_0 + (N-1) \\cdot y_1 + \\cdots + 1\\cdot y_{N-1} = S$    さらに，$z_i := (N - i)\\cdot y_i$ とすると， 次のように言い換えられる:\n 求める最大値: $\\sum_{i = 0}^{N-1} C_i z_i$． ただし，$C_i := B_i / (N - i)$． 満たすべき条件:  $z_i \\geq 0$ $\\displaystyle\\frac{z_0}{N} + \\displaystyle\\frac{z_1}{N - 1} + \\cdots + \\displaystyle\\frac{z_{N-1}}{1} \\leq M$ $z_0 + z_1 + \\cdots + z_{N-1} = S$    $C_i$ たちの最大値を与える $i$ を $I$ と書く (複数あったら 一番小さいものを取る)． もし，$\\displaystyle\\frac{S}{N - I} \\leq M$ であれば， $z_I = S$, $z_i = 0 \\;(i \\neq I)$ とすることで，最大値が実現できる． 以下，そうでないとする．\n最大値を与える $(x_i)$ を取り，対応する $(y_i)$, $(z_i)$ を取る． もし，$i \u0026gt; I$ かつ $z_i \u0026gt; 0$ なる $i$ があったとすると，$z_{I}$ を $z_i$ だけ増やして，$z_i$ を $0$ に変えると， 条件を満たしたまま，値が増加してしまう．したがって， $i \u0026gt; I$ ならば $z_i = 0$．すなわち， $x_{I + 1} = x_{I + 2} = \\cdots x_{N}$ である．\nここで，$x_{I + 1} \u0026lt; M$ だと仮定する． $x_1 + \\cdots x_I = S - (x_{I + 1} + \\cdots x_N) = S - (N - I) x_{I + 1} \u0026gt; (N - I) (M - x_{I + 1}) \u0026gt; 0$ であるので，$0 = x_{i-1} \u0026lt; x_i$ となる $i \\leq I$ が存在する． 小さな $\\varepsilon \u0026gt; 0$ をとって，$x_i$ を $\\varepsilon$ 減らし， $x_{I+1}$ を $\\varepsilon$ 増やすことによって，条件を満たしたまま 値を大きくすることができてしまう．したがって，$x_{I+1} = M$ で なければならない．\n以上により，もとの問題は，次の2条件を満たす列において， $\\sum_{i = 1}^{I} A_i x_i$ の最大値を求める問題に帰着された．\n $0 \\leq x_1 \\leq x_2 \\leq \\cdots \\leq x_I \\leq M$ $x_1 + x_2 + \\cdots + x_I = S - M(N - I)$  これを繰り返せば良い．計算量は $O(N^2)$．\nACコード 提出 ","permalink":"https://yamate11.github.io/blog/posts/2021/10-29-arc128c-max-dot/","summary":"AtCoder Regular Contest 128 (ARC 128) C - Max Dot を解説ACしました． 公式解説より，多少行間が埋まっていると思います．\n問題概要 整数N, M, Sと整数列 A = (A_1, .., A_N) が与えられる． 次の条件を満たす非負実数列 (x_1, ..., x_N) を作る: ・ 0 \u0026lt;= x_1 \u0026lt;= x_2 \u0026lt;= ... \u0026lt;= x_N \u0026lt;= M ・ x_1 + x_2 + ... + x_N = S \\sum {A_i × x_i | i = 1, ..., N } の最大値を求めよ． 制約: N \u0026lt;= 5000; M,S,A_i \u0026lt;= 10^6; S \u0026lt;= NM; 問題へのリンク 解法 $x_0 := 0$ として，$y_i := x_{i+1} - x_i$ ($i = 0, \\ldots, N-1$) とすると， 次のように言い換えられる:","title":"Max Dot -- AtCoder Regular Contest 128 C"},{"content":"AtCoder Beginner Contest 224 (ABC 224) に参加して， ABCDE 5完 415位でした．\nA\tTires cout \u0026lt;\u0026lt; (S[S.size() - 2] == 'e' ? \u0026quot;er\\n\u0026quot; : \u0026quot;ist\\n\u0026quot;);\nB\tMongeness 4重ループで全数探索します．\nC\tTriangle? 3重ループで全数探索します．\n(x0, y0), (x1, y1), (x2, y2) を頂点とする三角形が正の面積を持つ条件は， (dx1, dy1) := (x1, y1) - (x0, y0), (dx2, dy2) := (x2, y2) - (x0, y0) として， dx1 * dy2 != dx2 * dy1 です．\nD\t8 Puzzle on Graph 次のような無向グラフを考えます．\n ノードは配置全体． 配置uが配置vから一回の操作で得られるとき，uとvの間に辺がある．  初期配置から，目的とする配置までの距離を普通のBFSで求めます．\nC++なので，配置は普通に長さ9の vector\u0026lt;int\u0026gt; で持って， すでに配置を見たかどうかも set\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; で管理して 間に合いました．時間制限4秒のところ，1.4秒くらいでした．\nE\tIntegers on Grid $a_i$ の大きい順に決定していきます．各行・列ごとに 「その行・列のマスから始めてできるもっとも長い回数」を記憶しておけば， $(r_i, c_i, a_i)$ の答は， max($r_i$行から始められる最も長い回数, $c_i$列から始められる最も長い回数) + 1 になります．$a_i$ が等しいものは一気に処理する必要があります．\nF\tProblem where +s Separate Digits コンテスト中は F は飛ばして G に行きました．\n短いもので実験してみると，次のことが分かります．\n 右端の数は，すべてで右端(一の位)の数として現れる． 右から2番目の数は，半分で一の位，残りで十の位の数として現れる． 右から3番目の数は，半分で一の位，残りの半分で十の位，残りで百の位の数として現れる．  以下同様なので，このとおりに計算すれば良いです．\nG\tRoll or Increment 解けませんでした．残り15分の時点で以下の考察はできていたのに，デバッグしきれませんでした．\n最適解は，次のような形になっています:\n T, T-1, \u0026hellip;, T-(k-1) の k 個では，出目を1増やす． (1 \u0026lt;= k \u0026lt;= T) その他では，振り直す．  k を決めれば良いです．\n上の k 個の位置での期待値の平均は (k - 1) / 2 * A です． したがって，振り直す位置での期待値を e とすると，\ne = B + (k / N) * ((k - 1) / 2 * A) + ((N - k) / N) * e\nとなりますので，これを解いて\ne = (N * B + k * (k - 1) * A / 2) / p\nを得ます．T - k の位置では，k 回出目を増やすよりもランダムの方が 期待値が小さいので，\nN * B + k * (k - 1) * A / 2) / p \u0026lt; A * k\nが成り立ち，k はこれを成り立たせる最小の数ですから，二分探索で k を決定できます．\n誕生日前に黄色になれる最後のチャンスだったので，一発狙ってGに行ってみたけど解けませんでした．来週から地道にやろうと思います．\nyamate11さんのAtCoder Beginner Contest 224での成績：415位\nパフォーマンス：1839相当\nレーティング：1946→1936 (-10) :(#AtCoder #ABC224\n\u0026mdash; yamate11 (@_yamate11) October 23, 2021  ","permalink":"https://yamate11.github.io/blog/posts/2021/10-23-abc224/","summary":"AtCoder Beginner Contest 224 (ABC 224) に参加して， ABCDE 5完 415位でした．\nA\tTires cout \u0026lt;\u0026lt; (S[S.size() - 2] == 'e' ? \u0026quot;er\\n\u0026quot; : \u0026quot;ist\\n\u0026quot;);\nB\tMongeness 4重ループで全数探索します．\nC\tTriangle? 3重ループで全数探索します．\n(x0, y0), (x1, y1), (x2, y2) を頂点とする三角形が正の面積を持つ条件は， (dx1, dy1) := (x1, y1) - (x0, y0), (dx2, dy2) := (x2, y2) - (x0, y0) として， dx1 * dy2 != dx2 * dy1 です．\nD\t8 Puzzle on Graph 次のような無向グラフを考えます．\n ノードは配置全体． 配置uが配置vから一回の操作で得られるとき，uとvの間に辺がある．  初期配置から，目的とする配置までの距離を普通のBFSで求めます．","title":"ABC224 参加記"},{"content":"自然数の集合 $N$ を，XORを加算とする， 体 $\\textrm{F}_2 = \\{0,1\\}$ 上のベクトル空間と見たときに， $x_1, .., x_n \\in Z$ が張る部分空間の基底の求め方に関する記事です． 熨斗袋さんのツイートで紹介されていた方法です:\nxor の掃き出しすごい簡単に出来るんですね\nvector\u0026lt;int\u0026gt; basis;\nfor(int e : a){\nfor(int b : basis)\nchmin(e, e ^ b);\nif(e)\nbasis.push_back(e);\n}\nこれで数列 a の基底が basis に入る\n\u0026mdash; 熨斗袋 (@noshi91) November 30, 2019  記法など 自然数の集合 $\\{0, 1, \\ldots\u0026hellip;\\}$ を $N$ と書く． 以下では，$N$ を， XOR を加算とする，体 $\\textrm{F}_2 = \\{0, 1\\}$ 上の ベクトル空間と見る． $X \\subseteq N$ が張る空間を $S(X)$ と書く．\n$x \\in N \\setminus \\{0\\}$ の最上位ビットを $\\textrm{MSB}(x)$ と書く． たとえば， $\\textrm{MSB}(1) = 0$, $\\textrm{MSB}(5) = 2$． $2^{\\textrm{MSB}(x)}$ を $r(x)$ と書く．\n命題  $x_1, \\ldots, x_n \\in N$ に対し， $y_1, \\ldots, y_n \\in N$ を 次で定義する:\n $z_{i, 1} := x_i$ $z_{i,j} := \\min(z_{i,{j-1}}, \\text{XOR}(z_{i,{j-1}}, y_j))$ ($j = 2, \\ldots, i$) $y_i := z_{i,i}$  $W := \\{i \\in [1, n] \\mid y_i \\neq 0\\}$ とするとき， $\\{y_i \\mid i \\in W\\}$ および $\\{x_i \\mid i \\in W\\}$ は， $S(\\{x_1, \\ldots, x_n\\})$ の基底である．\nまた，前者に関しては，$a \\in N$ のこの基底による表現 $ a = \\textrm{XOR}\\{y_i \\mid i \\in U\\}$ を，次のように計算することができる:\n $a_1 := a$ $a_{j + 1} := \\min(a_j, \\textrm{XOR}(a_j, y_j))$ ($j = 1, \\ldots, i - 1$) $U := \\{ j \\in W \\mid a_{j + 1} = \\textrm{XOR}(a_j, y_j)\\}$   証明 $i \\in W$ に対して， $M_i := \\{ \\textrm{MSB}(y_j) \\mid j \\in [1, i) \\cap W \\}$ とする．以下が帰納法で証明できる:\n $m \\in M_i$ ならば，$\\textrm{AND}(2^{\\textrm{MSB}(m)}, y_i) = 0$．  従って，$\\{y_i \\mid i \\in W\\}$ は線形独立である． また，$\\{y_i \\mid i \\in [1, j) \\cap W\\}$ が， $\\{x_1, x_2, \\ldots, x_j\\}$ を生成することも帰納法で証明できる．\n従って， $\\{y_i \\mid i \\in W\\}$ は， $S(\\{x_1, \\ldots, x_n\\})$ の基底である．\n$y_i$ は，$\\{x_j \\mid j in [1, i] \\cap W\\}$ の線形結合で書けるので， $\\{x_i \\mid i \\in W \\}$ は，$S(\\{x_1, \\ldots, x_n\\})$ を生成する． $x_i$ たちが線形独立でないと仮定すると， $x_i = \\textrm{XOR}(\\{x_j \\mid j \\in J\\})$ となる $i \\in W$ と $J \\subseteq [1, i) \\cap W$ がとれる．しかし，すると $\\textrm{XOR}(\\{x_j \\mid j \\in J\\}) = \\textrm{XOR}(\\{y_j \\mid j \\in J'\\})$ となる $J' \\subseteq [1, i) \\cap W$ がとれる．$y_i$ の構成を考えると，$j \\in J'$ のとき， $z_{i,j} = x_i + \\textrm{XOR}(\\{y_j \\mid j \\in J'\\})$, そうでないとき $z_{i,j} = z_{i, j-1}$ となり，したがって，$y_i = 0$ となり， 矛盾する．(終)\n","permalink":"https://yamate11.github.io/blog/posts/2021/10-22-basis-using-min/","summary":"Z を，XORを加算とする，体 F2 = {0,1} 上のベクトル空間と見たときに，x_1, .., x_n ∈ Z が張る部分空間の基底の求め方","title":"XORに関する基底"},{"content":"AtCoder Beginner Contest 223 (ABC223) H - Xor Query の解法です．解説ACですが，基底は熨斗袋さんの方法で求めました．\n問題概要 正の整数 N と長さN の正の整数列 A = (A_i)_{i\u0026lt;=N} が与えられる． Q個のクエリを処理せよ．クエリでは，(L, R, X) が与えられるので， A_L, A_{L+1}, ..., A_R から1つ以上を選んでそれらの XOR を X に できるかどうか判定する． 制約: N \u0026lt;= 4e5, Q \u0026lt;= 2e5, 1 \u0026lt;= A_i,X_i \u0026lt; 2^60, TL: 3sec 問題へのリンク 解法 $A_i$ や $X_i$ を，$\\textrm{F}_2$ のベクトルと見る．\n$(A_{i}, A_{i-1}, \\ldots, A_1)$ が張る空間の基底 $B_i = (A_{j_p} \\mid p = 1, 2, .., m_i)$ を次のように選ぶ\n $B_0 = $空リスト $B_i'$ を，$B_{i-1}$ の先頭に $A_i$ を追加したものとするとき， $B_i$ は，予備知識 に記載した方法で$B_i'$ から選んだ基底．  この場合，$B_i = (A_{j_1}, \\ldots, A_{j_{m_i}})$ は， $A_i, A_{i-1}, \\ldots, A_1$ が張る空間の基底で， $i = j_1 \u0026gt; j_2 \u0026gt; \\cdots \u0026gt; j_{m_i}$ となっており，$j_k \\geq j \u0026gt; j_{k+1}$ のとき，$A_j$ は，$A_{j_1}, \\ldots, A_{j_k}$ が張る空間に属する．\nクエリ $(L, R, X)$ は，次のように処理できる: $B_R = (A_{j_1}, \\ldots, A_{j_m})$ とする． $X$ が $(A_{j_1}, \\ldots, A_{j_k})$ が張る空間に属するような 最小の $k$ を，予備知識 に記載した方法で決定する． $L \\leq {j_k}$ なら「Yes」を，そうでなければ「No」を出力する．\n$A_i$ などのビット数を$p$として，$B_i$ の決定は $O(p^2)$ で， $k$ の決定は $O(p)$ でできるので，全体の計算量は $O(p^2 N + pQ)$ である．\n一般に，$x$ が $y_1, \\ldots, y_m$ が張る空間に属するかどうかは， 熨斗袋さんの方法で $O(m)$ で計算できるので， 上の手続きの計算量は， $O(p^2 (N + Q))$ である．\nACコード #include \u0026lt;bits/stdc++.h\u0026gt;#include \u0026lt;cassert\u0026gt;typedef long long int ll; using namespace std; #define REP2(i, a, b) for (ll i = (a); i \u0026lt; (b); i++) #define REP2R(i, a, b) for (ll i = (a); i \u0026gt;= (b); i--) #define REP(i, b) REP2(i, 0, b) #define ALL(coll) (coll).begin(), (coll).end() #define SIZE(v) ((ll)((v).size()))  int main(/* int argc, char *argv[] */) { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout \u0026lt;\u0026lt; setprecision(20); auto func1 = [\u0026amp;](ll x, const auto\u0026amp; v) -\u0026gt; pair\u0026lt;ll, ll\u0026gt; { REP(j, SIZE(v)) if ((x = min(x, x ^ v[j].second)) == 0) return {j, 0}; return {-1, x}; }; ll N, Q; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; Q; vector\u0026lt;ll\u0026gt; A(N); REP(i, N) cin \u0026gt;\u0026gt; A[i]; using sta = pair\u0026lt;ll, ll\u0026gt;; vector\u0026lt;vector\u0026lt;sta\u0026gt;\u0026gt; B(N); REP(i, N) { B[i].emplace_back(i, A[i]); if (i == 0) continue; ll sz = SIZE(B[i - 1]); ll j0 = [\u0026amp;]() -\u0026gt; ll { REP(j, sz) { auto [p, y] = B[i - 1][j]; auto [k, x] = func1(y, B[i]); if (k \u0026lt; 0) B[i].emplace_back(p, x); else return j + 1; } return sz; }(); REP2(j, j0, sz) B[i].push_back(B[i - 1][j]); } REP(i, Q) { ll l, r, x; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; x; l--; r--; auto [j, dummy] = func1(x, B[r]); cout \u0026lt;\u0026lt; (j \u0026gt;= 0 \u0026amp;\u0026amp; l \u0026lt;= B[r][j].first ? \u0026#34;Yes\\n\u0026#34; : \u0026#34;No\\n\u0026#34;); } return 0; } ","permalink":"https://yamate11.github.io/blog/posts/2021/10-21-abc223-h-xor-query/","summary":"AtCoder Beginner Contest 223 (ABC223) H - Xor Query の解法です．解説ACですが，基底は熨斗袋さんの方法で求めました．","title":"Xor Query -- AtCoder Beginner Contest 223 H"},{"content":"AtCoder Beginner Contest 223 (ABC 223) に参加して， ABCDEFの6完92'59\u0026quot; 259位でした．記録です．\n問題へのリンク A -\tExact Price cout \u0026lt;\u0026lt; (X \u0026gt; 0 and X % 100 == 0 ? \u0026quot;Yes\\n\u0026quot; : \u0026quot;No\\n\u0026quot;;\nB -\tString Shifting 回数に制限はないので，全部左シフトだとして良いです． 0 回から S.size() - 1 回までの左シフトを順に作って， 辞書順最小と最大のものを作れば良いです．\n$O(N^3)$ のような気が一瞬してしまいましたが，そんなことはなくて $O(N^2)$ ですから間に合います．($N := $S.size())\nC -\tDoukasen 公式解説 に載っている賢い解にびっくりしてしまいましたが，コンテストでは 次のように解きました．\n以下の(1),(2),(3)が成り立つ間，(4)を実行する．\n  (1) 左の火が区間 i に時刻 p に入ろうとしている．\n  (2) 右の火が区間 j に時刻 q に入ろうとしている．\n  (3) i \u0026lt; j\n  (4) p \u0026lt; q なら，p += A[i] / B[i]; i++; そうでなければ， q += A[j] / B[j]; j--;\n  このループを抜けると，左右の火が時間差 p-q で同じ区間 i に 入ろうとしているので，どこで出会うか計算できる．\nD -\tRestricted Permutation 各 i = 1, \u0026hellip;, N に対して，2つの集合 prv, nxt を用意します． 気分は次の通りです．\n prv[i] \u0026hellip; i よりも先に来なければならない数 nxt[i] \u0026hellip; i よりも後に来なければならない数  実際には，各 $(A_i, B_i)$ に対して，$A_i$ を $\\text{prv}[B_i]$ に， $B_i$ を $\\text{nxt}[A_i]$ に入れます．\n答を左から書いていくことにして，prv[i] が空なら，i を書くことができます． 辞書順最小にしたいので，priority queue を使います．\n 最初の状態で prv[i] が空である i を全部キューに入れておきます． キューがからでない間ループ:  キューから i を取り出して出力します． nxt[i] の要素 j に対して，  prv[j] から i を取り除きます． prv[j] が空になったら，j をキューに入れます．      このままだと，同じ j が複数回キューに入ってしまう可能性があります． キューに入れる前に重複チェックが必要です．これを忘れて， また，直し方を間違えて，2 ペナルティーでした．もったいない\u0026hellip;.\nE -\tPlacing Rectangles 3つの長方形の配置は以下のいずれか (ということを無証明で通してしまいました)\n 3つ縦に並ぶ 3つ横に並ぶ 横2行で，1行に1個，もう1行に2個． 縦2列で，1列に1個，もう1列に2個．  各々の場合について，A, B, C が X, Y に入るかどうか判定します．\nF -\tParenthesis Checking ( を 1 に，) を -1 に置き換えて，位置 i までの累積和を $S_i$ と すると，括弧列が全体として正しいための 必要十分条件は，$S_N = 0$ かつ すべての $i$ について $S_i \\geq 0$ であることです． したがって，位置 l から 位置 r までの括弧列が正しいための条件は， 下の両方が成り立つことです．\n $S_{l-1} = S_r$ すべての $i \\in [l, r]$ に対して，$S_i \\geq S_r$  これは，次のように言い換えられます:\n $S_{l-1} = S_r$ かつ $\\min\\{S_i \\mid i \\in [l, r]\\} = S_r$  また，位置$l$と$r$の文字を入れ替えたときには，$S$ は次のように変わります:\n 両方が同じ文字なら，変化無し ( と ) の場合には，$i \\in [l, r-1]$ について，$S_i$ が 2 減る． ) と ( の場合には，$i \\in [l, r-1]$ について，$S_i$ が 2 増える．  したがって，$S_i$ の値を，区間加算と区間最小値取得ができる セグメント木で管理することで答が得られます．\nG -\tVertex Deletion E が解けた時点で残り40分でした． F と G の問題文をざっと読んで，G は解けそうになく (そもそもマッチングという ことばが分からない (ので検索した))，F は解けそうだったので，F に 行きました．結果的には， G は 40分あれば解けたことがわかったので失敗だったのですが， すぐには方針が思いつかなかったのでやむを得ないですかねえ．うーむ．\n最小マッチングというのは，pairwise に頂点を共有しない辺の集合 $X$ で 要素数最小のもの，ということが検索して分かったので，それで考えます． グラフは木ですから，$X$ は，葉から順に貪欲に取っていけば良いです (ということにすぐ思い当たれば G に行けたかもしれない．未練たらしい\u0026hellip;)\n正確には次のようになるでしょうか: 適当に根を考えたとき， $X$ に入っている辺の両端の頂点のうち，根に近い方の点からなる集合を $Y$ とします．$Y$ は次の条件を満たすとして良いです: 頂点 $v$ に関し，\n $v$ の子がすべて $Y$ に属していれば $v$ は $Y$ に属さない． $v$ の子で $Y$ に属していないものがあれば，$v$ は $Y$ に属する．  上の条件は当然で，下の条件はもし満たしていなければ， 満たすように $X$ を (要素数を変えずに) 変更することができます． 上の条件から，根 $r$ を決めたときに $Y$ は確定します．これを $Y_r$ と 書くことにします． $r$ が $Y_r$ に属するときには，$r$ とその辺を取り除いてしまうと 最小マッチングが減り，$r$ が $Y_r$ に属さなければ，最小マッチングは 減りません．ということで，各$r$に対して $r \\in Y_r$ かどうかを判定すれば よいことになりました．\n$r \\in Y_r$ かどうかは， $f(p) = \\bigvee \\{ \\neg f(q) \\mid q \\text{ は } p \\text{ の子 }\\}$ と，子の値からモノイド演算で定義した $f(r)$ の値として決定できますから， 全方位木DPで求めることができます．\nH -\tXor Query 問題も読めませんでした． あとで解説ACしました ．\n微減ですんだからOK... という気持ちには今日はなれないなあ．残念．\nyamate11さんのAtCoder Beginner Contest 223での成績：259位\nパフォーマンス：1916相当\nレーティング：1949→1946 (-3) :(#AtCoder #ABC223 https://t.co/61p9VRUfwY\n\u0026mdash; yamate11 (@_yamate11) October 17, 2021  ","permalink":"https://yamate11.github.io/blog/posts/2021/10-17-abc223/","summary":"AtCoder Beginner Contest 223 (ABC 223) に参加して， ABCDEFの6完92'59\u0026quot; 259位でした．記録です．\n問題へのリンク A -\tExact Price cout \u0026lt;\u0026lt; (X \u0026gt; 0 and X % 100 == 0 ? \u0026quot;Yes\\n\u0026quot; : \u0026quot;No\\n\u0026quot;;\nB -\tString Shifting 回数に制限はないので，全部左シフトだとして良いです． 0 回から S.size() - 1 回までの左シフトを順に作って， 辞書順最小と最大のものを作れば良いです．\n$O(N^3)$ のような気が一瞬してしまいましたが，そんなことはなくて $O(N^2)$ ですから間に合います．($N := $S.size())\nC -\tDoukasen 公式解説 に載っている賢い解にびっくりしてしまいましたが，コンテストでは 次のように解きました．\n以下の(1),(2),(3)が成り立つ間，(4)を実行する．\n  (1) 左の火が区間 i に時刻 p に入ろうとしている．\n  (2) 右の火が区間 j に時刻 q に入ろうとしている．","title":"ABC 223 参加記"},{"content":"エクサウィザーズプログラミングコンテスト2021 (AtCoder Beginner Contest 222 - ABC 222) G - 222 を解説ACしました．公式解説そのままですが，予備知識のところを self-contained になるように書きました．\n問題概要 整数 K が与えられる． 数列 2, 22, 222, 2222, .... に，初めて K の倍数が現れるのは何項目か? 現れなければ -1 と答えよ．T個のケースが与えられる． 制約: T \u0026lt;= 200, K \u0026lt;= 10^8 問題へのリンク 予備知識 フェルマーの小定理  整数 $a$ が素数 $p$ と互いに素ならば， $a^{p - 1} \\equiv 1 \\text{ (mod } p \\text{)}$．\n 証明 $a^p \\equiv a$ を言えば良い．帰納法． $a^p = (a - 1 + 1)^p = (a-1)^p + 1 + \\sum_{r = 1}^{p-1}\\binom{p}{r}(a-1)^r \\equiv (a-1)^p + 1 \\equiv a - 1 + 1 = a$．(終)\nオイラーの$\\varphi$関数 正の整数 $n$ に対し，$n$ と互いに素である $n$ 以下の正の整数の 個数を $\\varphi(n)$ とする．\n命題  $n$ の素因数分解を $\\prod_{k=1}^{d}p_k^{e_k}$ とするとき， $\\varphi(n) = \\prod_{k=1}^{d}(p_k^{e_k} - p_k^{e_k - 1})$\n 証明 素数 $p$ に対して $\\varphi(p^e) = p^e - p^{e-1}$ であることと， $m, n$が互いに素であるとき $\\varphi(mn) = \\varphi(m)\\varphi(n)$ であることを言えば良い．前半は明らか． 後半: $t$ と互いに素である $t$ 以下の正の整数の集合を $P(t)$ とする． $x \\in P(mn)$ に対して $(x \\% m, x \\% n) \\in P(m)\\times P(n)$ を対応させる写像が1対1, onto になる (中国剰余定理)．(終)\nオイラーの定理  $a$ と $n$ が互いに素ならば， $a^{\\varphi(n)} \\equiv 1 \\text{ (mod } n \\text{)}$\n 証明 $X = \\{ ax \\% n \\mid x \\in P(n) \\}$ とすると， $X \\subseteq P(n)$ と $|X| = |P(n)|$ より，$X = P(n)$． したがって，$d := \\prod_{x \\in P(n)} x$ とすれば， $a^{\\varphi(n)} d \\equiv d$．$d$ と $n$ は互いに素なので， $a^{\\varphi(n)} \\equiv 1$．(終)\n解法 数列の第 n 項は，$2 (10^n - 1) / 9$ と書ける． $K$ が奇数のとき，$\\alpha = 9K$，$K$ が偶数の時，$\\alpha = 9K/2$ とすると， $2 (10^n - 1) / 9 \\equiv 0$ (mod $K$) $\\iff 2 (10^n - 1) \\equiv 0$ (mod $9K$) $\\iff 10^n \\equiv 1$ (mod $\\alpha$)．\nここで，$\\alpha$ が 2か5で割り切れる場合には，$10^n$ は mod $\\alpha$ で 1 にはなり得ない． そうでない場合， $10^n \\equiv 1$ となる正の $n$ の最小値を取る． $n = q\\varphi(\\alpha) + r$, $0 \\leq r \u0026lt; \\varphi(\\alpha)$ とすると， オイラーの定理より $10^r \\equiv 1$ となるので，最小性より $r = 0$． すなわち，$n$ は $\\varphi(\\alpha)$ の約数．これを全探索すれば良い．\n計算量は，$\\varphi(\\alpha)$ を求めるために $K$ を素因数分解 するところで，$O(\\sqrt{K})$ と，約数列挙が $O(\\sqrt{K})$ で，合わせて $O(\\sqrt{K})$．\nACコード https://atcoder.jp/contests/abc222/submissions/26539813 ","permalink":"https://yamate11.github.io/blog/posts/2021/10-13-abc222-g-222/","summary":"エクサウィザーズプログラミングコンテスト2021 (AtCoder Beginner Contest 222 - ABC 222) G - 222 を解説ACしました．公式解説そのままですが，予備知識のところを self-contained になるように書きました．","title":"222 -- AtCoder Beginner Contest 222 G"},{"content":"木の直径についての記事です．今週 (2021/10/09) と先週に引き続いて，AtCoder Beginner Contest に木の直径に関する問題が出たので，基本事項をまとめました．\n仮定 木の各辺に，正の重み (距離) がついているとする．\n記法  ノードの集合を $N$ と書く．辺の集合を$E$ と書く． 2ノード $a$, $b$ を結ぶパスを $p(a, b)$ と書く． $(a,b) \\in E$ のとき，辺$ab$に付された重みを $d(a,b)$ と書く． $p(a, b)$ を構成する辺に付された重みの和も， 同じ $d(a, b)$ で表す． $D := \\max\\{d(a,b) \\mid a, b \\in N\\}$ を，木の直径の長さと呼ぶ． $d(a, b) = D$ であるとき，$p(a, b)$ を，木の直径と呼ぶ．  命題1  2つのパス$\\pi_1 = p(x_1, y_1)$ および $\\pi_2 = p(x_2, y_2)$ が ともに直径であるとき， これらのパスは共通のノードを持つ．\n 証明 $\\pi_1$ と $\\pi_2$ が共通ノードを持たないと仮定して矛盾を導く． $\\pi = p(x_1, x_2)$ とする． $\\pi_1$, $\\pi_2$ と $\\pi$ との分岐点を $z_1$, $z_2$ とする． 仮定より $z_1 \\neq z_2$である． 以下が成り立つ．\n $d(x_1, z_1) + d(z_1, y_1) = D$ $d(x_2, z_2) + d(z_2, y_2) = D$ $d(x_1, z_1) + d(z_1, z_2) + d(z_2, y_2) \\leq D$ $d(x_2, z_2) + d(z_1, z_2) + d(z_1, y_1) \\leq D$  第3,4式を加えて第1,2式を代入すると $d(z_1, z_2) \\leq 0$ が得られ，矛盾が生じた．\n命題2  パス $p(a, b)$ が直径であるとき，任意の $x \\in N$ に対して， $a$ または $b$ が，木の中で $x$ から最も遠い点になる．すなわち， 任意の $w \\in N$ に対して，$d(x, w) \\leq \\max(d(x, a), d(x, b))$\n 証明 $d(x, a) \\geq d(x, b)$ として良い．$w \\in N$ が， $d(x, w) \u0026gt; d(x, a)$ を満たすと仮定して，矛盾を導く．\nCase1: $p(x, w)$ と $p(a, b)$ が共通部分を持つ場合\n共通部分を$p(x', w')$ とする． ただし，$x$に近い方を $x'$，$w$に近い方を $w'$ とする．\nCase1-1: $x'$と$w'$ のうち，$x'$ が $b$ 寄りで，$w'$ が $a$ 寄りの場合\n$d(x, w') + d(w', w) = d(x, w) \u0026gt; d(x, a) = d(x, w') + d(w', a)$ であるから，$d(w', w) \u0026gt; d(w', a)$ であることに 注意する． $d(w, b) = d(w, w') + d(w', x') + d(x', b) \u0026gt; d(a, w') + d(w', x') + d(x', b) = d(a, b) = D$ となり，直径の定義に反する．\nCase1-2: $x'$と$w'$ のうち，$x'$ が $a$ 寄りで，$w'$ が $b$ 寄りの場合\n$d(x, x') + d(x', a) = d(x, a) \\geq d(x, b) = d(x, x') + d(x', b)$ であるから，$d(x', a) \\geq d(x', b)$ である． また，$d(x, x') + d(x', w) = d(x, w) \u0026gt; d(x, a) = d(x, x') + d(x', a)$ であるから，$d(x', w) \u0026gt; d(x', a)$ である． すると，$d(a, w) = d(a, x') + d(x', w) \u0026gt; d(a, x') + d(x', a) \\geq d(x', b) + d(x', a) = d(a, b) = D$ となり，直径の定義に反する．\nCase2: $p(x, w)$ と $p(a, b)$ が共通部分を持たない場合\n$p(x, w)$ と $p(x, a)$ との共通部分を $p(x, x')$ とする． $p(x, a)$ と $p(b, a)$ との共通部分を $p(b', a)$ とする． $p(x, x') + p(x', w) = p(x, w) \u0026gt; p(x, a) = p(x, x') + p(x', b') + p(b', a)$ であるから，$p(x', w) \u0026gt; p(b', a)$ である． $p(b, w) = p(b, b') + b(b', x') + p(x', w) \u0026gt; p(b, b') + p(b', a) = p(b, a) = D$ となり，直径の定義に反する．\n命題3  $x \\in N$ をとる．$x$ からもっとも遠い点を $a$ として， $a$ からもっとも遠い点を $b$ とすると，$p(a, b)$ は，木の直径である．\n 証明 $p(c, d)$ を木の直径とする． 命題2より，$c$ もまた，$x$ から最も遠い点であるとしてよい． $p(x, a)$ と $p(x, c)$ の共通部分を $p(x, x')$ とする． $d(a, x') = d(c, x')$ である．\n$p(c, d)$ と $p(c, a)$ の共通部分を $p(c, y)$ とする．\nCase1: $y$ が $p(c, x')$ 上にある場合． このときには，$d(a, b) \\geq d(a, d) = d(a, x') + d(x', d) = d(c, x') + d(x', d) = d(c, d) = D$ となり，したがって，$p(a, b)$ は木の直径である．\nCase2: $y$ が $p(x', a)$ 上にある場合． このときには，$d(x, x') + d(x', y) + d(y, a) = d(x, a) \\geq d(x, d) = d(x, x') + d(x', y) + d(y, d)$ より，$d(y, a) \\geq d(y, d)$ である． したがって，$d(a, b) \\geq d(a, c) = d(a, y) + d(y, x') + d(x', c) \\geq d(d, y) + d(y, x') + d(x', c) = d(d, c) = D$ となり， $p(a, b)$ は木の直径である．\n命題4  木の直径の長さを $D$ とすると，次のいずれかが成り立つ．\n $c \\in N$ が存在して，すべての直径 $p(a, b)$ は $c$ を通り， $d(a, c) = d(c, b) = D/2$ である． $(c_1, c_2) \\in E$ と非負の $D_1, D_2$ が存在して， すべての直径 $p(a, b)$ は $c_1, c_2$ を通り， $D_1 + D_2 + d(c_1, c_2) = D$ が成り立ち， (必要なら$a$, $b$を入れ替えることによって) $d(a, c_1) = D_1$, $d(c_2, b) = D_2$ が成り立つ．   証明 直径 $p(a, b)$ を取る．\nCase1: $p(a, b)$ 上のノード $c$ で，$d(a, c) = d(c, b) = D/2$ となる ものが存在するとき．\n他の直径 $p(p, q)$ を取る．命題1により $p(a, b)$ と $p(p, q)$ は 共通のノードを持ち，これらは長さ0以上のパスをなす．これを $p(x, y)$ とする (xの側を a, p; y の側を b, q とする)． $c$ が $p(x, y)$ に含まれないとすると，$p(a, p)$ ないし $p(b, q)$ のいずれか の長さが $D$ より大きくなってしまう．したがって，$c$ は $p(x, y)$ に 含まれる．すなわち，$c$ は $p(p, q)$ 上にある．\nCase2: そうでないとき\n$d(a, c_1) \u0026lt; D/2$, $d(c_2, b) \u0026lt; D/2$, $(c_1, c_2) \\in E$ となる $c_1$, $c_2$ が取れる． 他の直径 $p(p, q)$ を取る． Case1と同様にして，$c_1, c_2 \\in p(p, q)$ であることと， $d(a, c_1) = d(p, c_1)$, $d(c_2, b) = d(c_2, q)$ であることがわかる．\n","permalink":"https://yamate11.github.io/blog/posts/2021/10-10-tree-diameter/","summary":"木の直径についての記事です．今週 (2021/10/09) と先週に引き続いて，AtCoder Beginner Contest に木の直径に関する問題が出たので，基本事項をまとめました．","title":"木の直径"},{"content":"エクサウィザーズプログラミングコンテスト2021（AtCoder Beginner Contest 222） (ABC 222) に参加して，ABCDE 5完498位でした．参加記です．\n問題へのリンク 思ったよりも冷えなかった．よかった (よくない)．\nyamate11さんのエクサウィザーズプログラミングコンテスト2021での成績：498位\nパフォーマンス：1818相当\nレーティング：1963→1949 (-14) :(#AtCoder #エクサウィザーズプログラミングコンテスト2021（ABC222） https://t.co/ajMzOdKgza\n\u0026mdash; yamate11 (@_yamate11) October 9, 2021  A - Four Digits 文字列として読み込んで，(4 - 長さ) 個の 0 を出力した後に出力．\n%04d という書式指定は浮かんだんですけど，printf の使い方に自信が持てず， 止めました．\nB\tFailing Grade 言われたとおりに数えます．\nC\tSwiss-System Tournament シミュレーションします．\nD\tBetween Two Arrays DPをします．\ndp[i][j] = $c_i$ の値が $j$ 以下であって条件を満たす列 $(c_1, \\ldots, c_i)$ の数．\nE\tRed and Blue Tree 色の塗り方にかかわらず，各辺を通る回数は決まっているので，まず， この回数を求めます．2頂点を結ぶ最短経路は，LCA を使って求められます．\n回数が決まったら，DPをします．\ndp[e][k] = 辺 1, \u0026hellip;, e を塗る方法で，そこまでの赤の回数と青の回数の 差が k であるような塗り方の数．\nk の取り得る範囲は - (M * (N - 1)) 以上 (M * (N - 1)) 以下なので， 計算量は $O(MN^2)$ となります．危ないかな，と思いましたが 280ms でセーフ．\n求める答は dp[N-1][K] なのですが，|K| が M * (N-1) より大きいときには 0 にすることが必要です．そういうサンプルを入れてくれてあったので 助かりました．全然気がついていなかったので，サンプルが無かったら 相当悩んだと思います．\nG\t222 Eまで49'11\u0026quot; で，私としては相当速く解けた感じです． もしGが解ければラッキー，と思って考え始めましたが， 歯が立ちませんでした．15分くらい考えて降参． この辺の判断が遅いんですよね．\nF\tExpensive Expense twitter で，みなさん，全方位木DP と言っています． チラッと考えはしたのですが，以下の方針で解ける，と思って実装を始めました． 結局間に合いませんでした．(コンテスト後に一応ACしました．) やっぱり全方位木DPで行くべきでしたでしょうか．\nDFSの行きがけ順に街を並べて，$1 = s(1), \\ldots, s(N)$ とします． 街 $i$ の子孫の s-添字は区間になります． つまり，$i$ の子孫は， $\\{ s(j) \\mid j \\in [b(i), e(i)) \\}$ と書くことができます．\n最大値の問合せと和の更新ができる， ノード数 $N$ の遅延セグメント木を用意します． 初期状態では，ノード $i$ には，$E_{1, i}$ を設定しておきます． DFSで，セグメント木を更新していき，DFSで街$j$を見ているときには， ノード $i$ に $E_{j, i}$ が保持されるようにします．このためには， 木を$p$ から $q$ に下がるときに，\n 全体に $C_r$ を加える．($r$ は，$p$ と $q$ を結ぶ道の番号) $q$ の子孫には，$-2C_r$ を加える．(上と合わせて $C_r$ を減じたことになる)  を行います．ここで，\n セグメント木のノード $q$ には $D_q$ が設定されているので， $-D_q$ を加えて 0 にする． 全体の最大値を求める．  とすることで，$q$ における値が求められます．\n$q$から$p$ に戻るときに，上の逆を行って， セグメント木の値を元に戻します．\n","permalink":"https://yamate11.github.io/blog/posts/2021/10-09-abc222/","summary":"ABC222 に参加して，ABCDE 5完 498位でした．参加記です．","title":"ABC 222 参加記"},{"content":"AtCoder Beginner Contest (ABC221) に参加して， ABCDEF 6完2ペナルティ 238位でした．その記録です．\nA - Seismic magnitude scales $32^{B-A}$ が答です．\nB - typo S = T か，または， 隣り合う2文字を入れ替えてみて T と一致すれば Yes, そうでなければ No です．\n「隣り合う」というのを見落として1WA．良く読まなくちゃ．\nC - Select Mul $N$の桁数を $t$ として，2つに分離する方法が $2^t$ くらいあります (実際には両者1つ以上必要なので，$2^t - 2$)．これらを全部探索します． 2つに分けたら，各々降順ソートして掛け合わせます．\nD - Online games イベントソートです．\n ユーザが x 日目にログインした \u0026hellip; $(x, 1)$ ユーザが y 日目にログアウトした \u0026hellip; $(y, -1)$  これらを昇順にソートして，順に見ます．現在のログイン数を表す 変数 num に，一つ前に見た組の日付を表す変数 prev を使い， $(z, c)$ を見たら，次を実行します:\nanswer[num] += z - prev; num += c; prev = z; E - LEQ 解法 $i \u0026lt; j$ で $A_i \\leq A_j$ となっていたら， $i$ で始まって $j$ で終わる部分列 $2^{j - i - 1}$ 個は条件を満たします．これ以外に条件を満たす部分列はありません．\nしたがって，求める答は\n$$ \\sum_i \\frac{1}{2^{i+1}} \\sum \\{ 2^{j} \\mid i \u0026lt; j \\text{ and } A_i \\leq A_j \\} $$\nとなりますから， $i$ の大きい方から順に，和をセグメント木で求めていけば良いです． 座標圧縮が必要です．\n経緯 $i$ を大きい方から見ていくということは考えていたのですが， $i$ が減るたびに，\n 今ある値を全部2倍して， A_i のところに 1 を追加する  という操作をしなくてはならず，これはできないよな，と思って 上の解法に至るまでだいぶ時間を使いました．終了後，それは 遅延セグメント木でできる，という指摘がありました．\nEは遅延セグ木で区間和、全体二倍、一点+1をしました。\n\u0026mdash; keijak (@keijak) October 2, 2021  F - Diameter set 解法 木の直径などに関しては以下が成り立ちます． maguroflyさんのまとめ がわかりやすい．\n 任意の点$x$に対し，$x$ から $y$ が最遠で，$y$ から $z$ が最遠であるとき， $y$ と $z$ を結ぶパスが直径パスになる． 最遠点までの距離が最小の点を中心と呼ぶことにすると，  直径$d$が偶数の時，中心がちょうど1つ存在する． これは，任意の直径パス $y$ \u0026ndash; $z$ に対して，パス上にあって $y$ から 距離 $d$ の点である． 直径$d$が奇数の時，中心がちょうど2つ存在する． これは，任意の直径パス $y$ \u0026ndash; $z$ に対して，パス上にあって $y$ から 距離 $(d - 1) / 2$ と $(d + 1) / 2$ の点である．    直径$d$が奇数の時には，各中心を根とする (もう一つの中心と反対方向の) 部分木の，深さ$(d - 1) / 2$ の点の数を $m$, $n$ とすれば， 答は $mn$ になります．\n直径$d$が偶数の時には，中心に隣接する点の集合を $A$ として， 各 $a \\in A$ を根とする (中心と反対方向の) 部分木の， 深さ $d/2 - 1$ の点の集合を $L_a$ と書くことにすれば， 各 $L_a$ から 1点または 0点を選んで赤く塗ることができます． ただし，全体として，部分木を2個以上選ばなくてはなりません． したがって答は，$m_a = |L_a|$ として， $\\prod_a (m_a + 1) - \\sum_a m_a - 1$ です．\n経緯 サンプルが通ったのが，終了5分前． 提出したらWAの山で，だめかなと思ったのですが， 偶然バグが見つかって，終了15秒前に通せました．ラッキー．\n","permalink":"https://yamate11.github.io/blog/posts/2021/10-03-abc221/","summary":"ABC221に参加して，ABCDEF 6完2ペナルティでした．その記録です．","title":"ABC 221 参加記"},{"content":"桁DPのコーディングに関する記事です． N 以下の整数で，ある条件を満たすものを数えます．\n参照 以下のoptさんの記事 をもとにして，少し追加しています:\n\rコーディングの方針  配るDP 表の更新を書く行は，ソース上で1箇所にする．  その桁に表れうる数 (0..9 とか 0..1 とか) をループで回し， 「この数を付け加えた時の格納先」を考える 格納先の添字を表す変数を，格納元で初期化して適宜変更する．   上位桁を 0-padding した状態で考える．  0以上N以下の数を数えることになる． 次のような場合は，すべてがゼロであることを表すフラグを使って対応する．  「左端の桁」の概念が出てくる 0以上ではなく，1以上を数える      #define REP(i, x) for (ll i = 0; i \u0026lt; (x); i++)  // N は各桁数値のベクトルで表現．ds[0] が最上位桁． // 問題文の都合で string にしても良い． vector\u0026lt;ll\u0026gt;\u0026amp; ds; // DP表 tbl[eq][az][p1][p2]... // eq: 上限値に等しいかどうかを表すフラグ // az: 全部の桁がゼロ (all zero) かどうかを表すフラグ // p1やp2の計算に使わなければ省略して良い // 「最上位桁」を特別に扱う場合などに必要 // p1,p2... : 考えるべき性質 (問題に応じて変わる) vector tbl_init(2, vector(2, vector(??, vector(??, 0LL)))); auto tbl = tbl_init; tbl[1][1][??][??] = 1 // 初期状態は，eq=1, az=1 for (auto d : ds) { auto prev = move(tbl); tbl = tbl_init; REP(eq,2) REP(az,2) REP(p1,??) REP(p2,??) { if (prev[eq][az][p1][p2] == 0) continue; // 性能的に重要かもしれない  REP(x,10) { // この桁で考える数  // eq, az, p1, p2 の新しい値 new_eq, new_az, new_p1, new_p2 を計算する  // たとえば new_p1 は，「直前の桁までで 性質 P1 の値が p1 であったとき，  // 次の桁として x を追加すると，P1 の値が new_p1 になる」もの．  if (eq \u0026amp;\u0026amp; x \u0026gt; d) continue; ll new_eq = eq \u0026amp;\u0026amp; x == d; ll new_az = az \u0026amp;\u0026amp; x == 0; // p1 などの計算に必要なら使う．  ll new_p1 = ....; ll new_p2 = ....; // 最後にテーブルを更新する  tbl[new_eq][new_az][new_p1][new_p2] += prev[eq][az][p1][p2]; }}} 問題集 \r\r","permalink":"https://yamate11.github.io/blog/posts/2021/07-06-digitdp/","summary":"桁DPのコーディングに関する記事です．N 以下の整数で，ある条件を満たすものを数えます．opt さんの記事をもとにしています．","title":"桁DPのコーディング"},{"content":"競技プログラミングのコードは，基本的には C++ で書いています． とても Python の方が書きやすいときには Python で書くこともありますが， ほとんどありません．\nいろいろな方がコーディングスタイルの話をされていて，参考にしました． ほとんど，今すぐ出てこないのですが， 競技プログラミングを始めた頃， koturnさんの記事 はとても勉強になりました．また， kimiyuki さんの記事 に書かれていることは，実施するようにしたことが多いです． (していないこともたくさんあります．) 以下，上記記事と多少重複しているところもあります．\n整数型は long long 整数型は，基本的には long long を使います． 例外はおおむね次のような感じです．\n bool で済む大きな vector で，スペースを節約したいとき (boolを使う) 64ビットフルに使うビット配列として用いるとき (unsigned long long を使う) ライブラリの中 (int や size_t も使う)  つまり，ループ変数なんかも，long long で回しています． int にすると必要な領域が半分になる，とか，ループがひょっとして 多少遅いかもしれない，とか思わないこともありませんが， ともかく「int を使わない」のを原則とすることで， うっかりオーバーフローをしてしまうのを避けようとしています．\nソース中では実際には，先頭に次の定義を置いて，ll と表記しています．\nusing ll = long long; また，基本的には，符号付きの変数を使います． たとえば (1) のようにと書くと警告が出ますが， (2) のように書き足してしのぎます． これは， これは，符号無し変数を使って，うっかり (3) の用に書いてしまう 間違いが怖いからです．\nfor (ll i = 0; i \u0026lt; vec.size(); i++) ... // (1) for (ll i = 0; i \u0026lt; (ll)vec.size(); i++) ... // (2) for (size_t i = N - 1; i \u0026gt;= 0; i--) .... // (3) ラムダ関数を使う 一部の処理をくくり出したいことが当然ありますが， 普通の関数(?)ではなく，ラムダ関数を使います．若干乱暴かもしれませんが， [\u0026amp;] を指定することで，その時点で有効な値を全部キャプチャしてしまいます．\nラムダ関数を使わないと， たとえば，入力に N, M, K がパラメータとして与えられている場合に， よく，以下のようなコードになります．\nint func(ll x, ll N, ll M, ll K, vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt;\u0026amp; A) { ... } int main() { ll N, M, K; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M \u0026gt;\u0026gt; K; vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; A(N); for (ll i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; A[i]; ... int t1 = func(x1, N, M, K, A); int t2 = func(x2, N, M, K, A); } この，func の引数に N, M, K, A たちを渡すのが面倒に感じるのです． おうおうにして，int func (ll x) { くらいで書き始めて， 書いていくうちに，「あ，Nが要る」「あ，Aも要る」と書き足していく ことになりがちです． ちゃんと設計して書かないのがいかん，という批判は当然あると思いますが， 現実としてそうなので\u0026hellip;．\nラムダ関数を使えば以下のように書けるのでらくちんです．\nint main() { ll N, M, K; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M \u0026gt;\u0026gt; K; vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; A(N); for (ll i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; A[i]; ... auto func = [\u0026amp;](ll x) -\u0026gt; ll { ... // N, M, K, A その他にアクセスできる．変更も可．  }; ll t1 = func(x1, N, M, K, A); ll t2 = func(x2, N, M, K, A); } よく最後のセミコロンを書き忘れてコンパイルやり直しますが．\n再帰関数はちょっと書き方がトリッキーですが， 慣れれば手が勝手に動きます(?)．\n... auto dfs = [\u0026amp;](auto f, ll node) -\u0026gt; void { // 引数の先頭に auto f と書いておく  // 再帰関数の時には復帰値型 (この場合は void) が省略不可  ... for (ll child : children[node]) { f(f, child); // 再帰呼び出し  } }; dfs(dfs, 0); // 関数 dfs の呼び出し．f には dfs 自身を渡す．  ... めったにありませんが，相互再帰の例:\nauto isOdd_rep = [\u0026amp;](auto f, ll x) -\u0026gt; bool { if (x == 0) return false; return ! f(f, x - 1); // f には isEven を入れて呼んでいる．  }; auto isEven_rep = [\u0026amp;](auto f, ll x) -\u0026gt; bool { if (x == 0) return true; return ! isOdd_rep(f, x - 1); // ここは isOdd_rep を呼ぶ．  }; auto isOdd = [\u0026amp;](ll x) -\u0026gt; bool { return isOdd_rep( isEven_rep, x); } auto isEven = [\u0026amp;](ll x) -\u0026gt; bool { return isEven_rep(isEven_rep, x); } assert(isOdd(5) == true); assert(isEven(6) == true); もちろん，isOdd などを定義せずに，直接 isOdd_rep(isEven_rep, 5) などと呼び出しても良いです．\nデバッグ出力 ときどき，「デバッグ用の printf を消し忘れてWA」という話を聞きます． 私は注意力散漫なので，なにかしないと絶対やってしまうにきまっているので， 対策しています．\n コンパイルは，必ず make で行う． ソースファイル名は固定 (cans.cc にしている)． Makefile を次のように書いておく:  単に make を実行すると，識別子 DEBUG の値が真で， 識別子 _GLIBCXX_DEBUG が定義 された状態でコンパイルされる．その他，-g と -O0 も指定される． make DEBUG=  で実行すると，上記識別子は定義されず，-O2 で コンパイルされる．   デバッグ用のライブラリを用意する:  識別子 DEBUG の値が真ならば，DLOGK() などのマクロが 定義される．DLOGK(e) などと呼び出すと，「e」という文字列と eの値が，標準エラー出力に出力される． 識別子 DEBUG が定義されていない状況では，デバッグ出力は 行われない．    識別子 _GLIBCXX_DEBUG は，C++ の STL をデバッグモードで動かすことを 指示するものです．これが定義されていると，vector のサイズを超えた アクセスなどがエラーとして報告されて，便利です． gdb を使えばソース上の位置などもわかります．\nこうしておくと，ソースを修正することなく， 手元では，デバッグ出力などが見えますし，提出先では DEBUG という識別子は定義されていないので，出力されません． また，標準エラー出力に出力しているので，想定回答との比較を行う プログラムで標準出力だけを見るようにすれば，デバッグ出力があっても (速度を除けば)問題無く機能します．速度に問題がある場合には make clean; make DEBUG=  でコンパイルし直します．\nあまりきれいじゃないかもしれませんが，コードです:\nMakefile (GNU make用):\nCXX := g++ ifeq ($(DEBUG),) DEBUGFLAGS := -O2 else DEBUGFLAGS := -g -O0 -D_GLIBCXX_DEBUG -DDEBUG=1 ifneq ($(DEBUG_LIB),) DEBUGFLAGS := $(DEBUGFLAGS) -DDEBUG_LIB=1 endif endif WARNINGS := -Wall -Wno-format-security -Wshadow -fconcepts CXXFLAGS := -std=gnu++17 $(DEBUGFLAGS) $(WARNINGS) CXXFLAGS := $(CXXFLAGS) -I/full/path/to/ac-library all: cans clean: $(RM) cans.o cans DLOGKなどの定義\ntemplate \u0026lt;class Head\u0026gt; void dbgLog(bool with_nl, Head\u0026amp;\u0026amp; head) { cerr \u0026lt;\u0026lt; head; if (with_nl) cerr \u0026lt;\u0026lt; endl; } template \u0026lt;class Head, class... Tail\u0026gt; void dbgLog(bool with_nl, Head\u0026amp;\u0026amp; head, Tail\u0026amp;\u0026amp;... tail) { cerr \u0026lt;\u0026lt; head \u0026lt;\u0026lt; \u0026#34; \u0026#34;; dbgLog(with_nl, forward\u0026lt;Tail\u0026gt;(tail)...); } #if DEBUG  #define DLOG(...) dbgLog(true, __VA_ARGS__) #else  #define DLOG(...) #endif  #define DUP1(E1) #E1 \u0026#34;=\u0026#34;, E1 #define DUP2(E1,E2) DUP1(E1), DUP1(E2) #define DUP3(E1,...) DUP1(E1), DUP2(__VA_ARGS__) #define DUP4(E1,...) DUP1(E1), DUP3(__VA_ARGS__) #define DUP5(E1,...) DUP1(E1), DUP4(__VA_ARGS__) #define DUP6(E1,...) DUP1(E1), DUP5(__VA_ARGS__) #define DUP7(E1,...) DUP1(E1), DUP6(__VA_ARGS__) #define DUP8(E1,...) DUP1(E1), DUP7(__VA_ARGS__) #define DUP9(E1,...) DUP1(E1), DUP8(__VA_ARGS__) #define DUP10(E1,...) DUP1(E1), DUP9(__VA_ARGS__) #define DUP11(E1,...) DUP1(E1), DUP10(__VA_ARGS__) #define DUP12(E1,...) DUP1(E1), DUP11(__VA_ARGS__) #define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12,NAME,...) NAME #define DUP(...) GET_MACRO(__VA_ARGS__, DUP12, DUP11, DUP10, DUP9, DUP\\ 8, DUP7, DUP6, DUP5, DUP4, DUP3, DUP2, DUP1)(__VA_ARGS__) #define DLOGK(...) DLOG(DUP(__VA_ARGS__)) #define DLOGKL(lab, ...) DLOG(lab, DUP(__VA_ARGS__)) ","permalink":"https://yamate11.github.io/blog/posts/2021/09-23-coding-style/","summary":"自分のコーディングスタイルについてです","title":"コーディングスタイル"},{"content":"stream の書式関連 参照: https://www.cs.fsu.edu/~myers/c\u0026#43;\u0026#43;/notes/formatting.html  stringstream は，str() メンバ関数で文字列になる．  stringstream ss; ss \u0026lt;\u0026lt; 100; assert(ss.str() == \u0026#34;100\u0026#34;);  16進表記は hex．10進表記(にもどす)は dec．大文字/小文字は [no]uppercase．  stringstream ss; ss \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; 253 \u0026lt;\u0026lt; uppercase \u0026lt;\u0026lt; 254 \u0026lt;\u0026lt; nouppercase \u0026lt;\u0026lt; 255; ss \u0026lt;\u0026lt; dec \u0026lt;\u0026lt; 100; assert(ss.str() == \u0026#34;fdFEff100\u0026#34;);  小数点以下の桁数は setprecision で制御  stringstream ss; double x = 1.0 / 3.0; ss \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; setprecision(20) \u0026lt;\u0026lt; x; assert(ss.str() == \u0026#34;0.333333 0.33333333333333331483\u0026#34;);  0詰めは setfill, 表示幅は，setw で制御  stringstream ss, ss1; ss \u0026lt;\u0026lt; setw(4) \u0026lt;\u0026lt; 10 \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; setw(4) \u0026lt;\u0026lt; (int)1e8; assert(ss.str() == \u0026#34; 10,100000000\u0026#34;); ss1 \u0026lt;\u0026lt; setfill(\u0026#39;0\u0026#39;) \u0026lt;\u0026lt; setw(4) \u0026lt;\u0026lt; 10 \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; setw(4) \u0026lt;\u0026lt; (int)1e8; assert(ss1.str() == \u0026#34;0010,100000000\u0026#34;);  ほとんどの manipulator は sticky (効果が持続) だが， setw は例外．  stringstream ss1, ss2; ss1 \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; 100 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; 200; assert(ss1.str() == \u0026#34;64 c8\u0026#34;); ss2 \u0026lt;\u0026lt; setw(4) \u0026lt;\u0026lt; 5 \u0026lt;\u0026lt; 6; assert(ss2.str() == \u0026#34; 56\u0026#34;); 例外  型宣言: struct Exc : exception {}; 投げる: throw Exc(); 受ける: try { ... } catch(const Exc\u0026amp; e) { ... }  使用例\nstruct Exc : exception {}; auto all_non_zero = [\u0026amp;](string s) -\u0026gt; bool { auto dfs = [\u0026amp;](auto f, size_t i) -\u0026gt; void { if (i == s.size()) return; if (s[i] == \u0026#39;0\u0026#39;) throw Exc(); f(f, i + 1); }; try { dfs(dfs, 0); return true; }catch (const Exc\u0026amp; e) { return false; } }; assert(all_non_zero(\u0026#34;11111\u0026#34;)); assert(! all_non_zero(\u0026#34;11101101\u0026#34;)); ビット処理 long long に対するもの．\n 1の数を数える \u0026ndash; __builtin_popcountll  assert(__builtin_popcountll(0xF) == 4); assert(__builtin_popcountll(0x100030007000F000) == 10);  右端の0の数 \u0026ndash; __builtin_ctzll  Count Trailing Zero であろう． __builtin_ctzll(x) は，x の LSB の添字に等しい． 引数は0ではいけない．    assert(__builtin_ctzll(0x1) == 0); assert(__builtin_ctzll(0x8) == 3); assert(__builtin_ctzll(1LL\u0026lt;\u0026lt;63) == 63);  左端の0の数 \u0026ndash; __builtin_clzll  Count Leading Zero であろう． __builtin_clzll(x) は，63 - (x の MSB の添字) に等しい 引数は0ではいけない．    assert(__builtin_clzll(0x1) == 63); assert(__builtin_clzll(1LL\u0026lt;\u0026lt;62) == 1); vector での 重複の削除 Unix の， sort | uniq に相当する操作\nvector\u0026lt;int\u0026gt; vec({10, 2, 5, 7, 5, 2, 5}); sort(vec.begin(), vec.end()); vec.erase(unique(vec.begin(), vec.end()), vec.end()); assert(vec == vector\u0026lt;int\u0026gt;({2, 5, 7, 10})); イタレータ iterator は，「要素を指す」と考えるより「要素と要素の間を指す」 と考えた方が話が分かりやすい．\nvector\u0026lt;int\u0026gt; vec({2, 4, 5, 5, 5, 6, 10, 12}); auto it1 = lower_bound(vec.begin(), vec.end(), 5); auto it2 = upper_bound(vec.begin(), vec.end(), 5); auto it3 = lower_bound(vec.begin(), vec.end(), 11); auto it4 = upper_bound(vec.begin(), vec.end(), 11); 逆方向イタレータ reverse_iterator\u0026lt;decltype(it)\u0026gt;(it) で， it の指している「要素間の位置」は変わらずに，方向だけが反転する． 上図で，5以下の要素を並べるコード:\nstringstream ss; vector\u0026lt;int\u0026gt; vec({2, 4, 5, 5, 5, 6, 10, 12}); auto itN = upper_bound(vec.begin(), vec.end(), 5); for (auto itR = reverse_iterator\u0026lt;decltype(itN)\u0026gt;(itN); itR != vec.rend(); itR++) { ss \u0026lt;\u0026lt; *itR; } assert(ss.str() == \u0026#34;55542\u0026#34;); set や map などに対しても，同様のことができる．\nstringstream ss; multiset\u0026lt;int\u0026gt; is({2, 4, 5, 5, 5, 6, 10, 12}); auto itN = is.upper_bound(5); for (auto itR = reverse_iterator\u0026lt;decltype(itN)\u0026gt;(itN); itR != is.rend(); itR++) { ss \u0026lt;\u0026lt; *itR; } cout \u0026lt;\u0026lt; ss.str() \u0026lt;\u0026lt; endl; assert(ss.str() == \u0026#34;55542\u0026#34;); set や priority queue の比較関数 集合 (set) のテンプレートの第2引数が比較クラスになる． イタレータが降順に動いていってほしい場合，次のように書けば良い．\nset\u0026lt;T, greater\u0026lt;T\u0026gt;\u0026gt; ss; 一般の比較関数 fn を書きたいときには，次のようにする．\nset\u0026lt;T, decltype(fn)\u0026gt;\u0026gt; ss(fn); 優先度付きキューを普通に次のように書くと降順になる:\npriority_queue\u0026lt;T\u0026gt; pque; 昇順にしたいときには，次のように書く:\npriority_queue\u0026lt;T, vector\u0026lt;T\u0026gt;, greater\u0026lt;T\u0026gt;\u0026gt; pque; 一般の比較関数 fn を書きたいときには，次のようにする． 指定した比較関数の「大きい」順に取り出される． つまり，fn(x, y) が真の時には，yがxより先に取り出される．\npriority_queue\u0026lt;T, vector\u0026lt;T\u0026gt;, decltype(fn)\u0026gt; pque(fn); 例:\nusing Pair = pair\u0026lt;int, int\u0026gt;; auto comp = [\u0026amp;](Pair x, Pair y) -\u0026gt; bool { if (x.first != y.first) return x.first \u0026lt; y.first; else return x.second \u0026gt; y.second; }; priority_queue\u0026lt;Pair, vector\u0026lt;Pair\u0026gt;, decltype(comp)\u0026gt; pque(comp); pque.emplace(2, 1); pque.emplace(3, 5), pque.emplace(3, 9); Pair p; p = pque.top(); pque.pop(); assert(p == Pair(3, 5)); p = pque.top(); pque.pop(); assert(p == Pair(3, 9)); p = pque.top(); pque.pop(); assert(p == Pair(2, 1)); ","permalink":"https://yamate11.github.io/blog/posts/2021/09-20-cpp-syntax-misc/","summary":"C++言語や，C++ Standard Template Library の書き方で，忘れやすいものをメモしておくページです．","title":"C++言語・STLメモ"},{"content":"AtCoder Beginner Contest 218 (ABC 218) H - Red and Blue Lamps に関する記事です． コンテストでは解けませんでした (到達しませんでした) し， 後で考えても分かりませんでした． まだ公式解説の3つの解法のうち，最初のしか読んでいませんが， 正当性証明が良く分からなかったので，少し詳しく書きます．\n問題概要 2以上の整数N, 正の整数Rと 正の整数の列 (A_i : i ∈ [1,N-1])が与えられる． X ⊆ [1,N] を，|X| = R となるようにとるとき， S := \\sum { A_i : i と i+1 のうち片方のみが X に属する．} の最大値を求めよ． 制約: N \u0026lt;= 2×10^5, A_i \u0026lt;= 10^9 問題へのリンク 解法 R \u0026gt; N/2 なら，X の代わりに [1,N] - X を考えれば良いので，R \u0026lt;= N/2 として 良い．\ni と i+1 が X に属しているような i は，無いとして良い．\n理由: そういうものがあったとする． R \u0026lt;= N/2 なので，以下のいずれかが成り立つ\n $1 \\not\\in X$ $N \\not\\in X$ $j \\not\\in X$, $j + 1 \\not\\in X$ なる $j$ がある．  どの場合も同様なので，3番目が成り立つ場合のみ扱う． これをみたす $j$ を1つとる．以下のいずれかが成り立つ．\n $i+1 \u0026lt; j$, $i\\in X$, $i+1\\in X$ なる $i$ がある． $j+1 \u0026lt; i$, $i\\in X$, $i+1\\in X$ なる $i$ がある．  どちらも同様なので，上が成り立つ場合のみ扱う．これを満たす最大の $i$ を とる．\n$i+1$ を $X$ から取り除き，$i+2$ を $X$ に加える．$i+3\\in X$ なら終了． そうでなければ $i+3$ を $X$ から取り除き，$i+4$ を $X$ に加える． 以下同様にこの操作をできるだけ繰り返す． 遅くとも $j$ に到達するまでに，この操作は終了する． この操作によって，Sの値は増加し，|X|の 値は変化しない． (理由終わり)\n$i \\in [1,N]$ に対して，$B_i := A_{i-1} + A_{i}$ とする (ただし，$A_0 := A_N := 0$)． 上のことから，問題を次のように言い換えられる: $|X| = R$ なる $X \\subseteq [1, N]$ を，どの $i\\in [1,N-1]$ に対しても $i\\not\\in X$ と $i+1\\not\\in X$ のすくなくともどちらかが成り立つように 取るとき，$S(X) := \\sum_{i \\in X} B_i$ の最大値を求めよ．\n記法として，$r - l$ が偶数の時， $E(l, r) := \\{l, l + 2, \\ldots, r - 2, r\\}$ と書くことにする． 特に $E(l, l) = \\{l\\}$．また，$l \u0026gt; r$ のとき，$E(l, r) = \\varnothing$．\n主張1 $X$ が $R$ に対する最大値を与える選択方法， $Z$ が $R + 1$ に対する最大値を与える選択方法であり， 区間$I = [p, q]$ について $|X\\cap I| + 1 = |Z\\cap I|$ であり， $p \\not\\in X, q \\not\\in X, p \\not \\in Z, q \\not\\in Z$ とする． $J := [1, N] \\setminus I$ とするとき， $Y := (X \\cap J) \\cup (Z \\cap I)$ は，$R + 1$ に対する最大値を与える 選択方法である．\n証明 $|Y| = R+1$ であることと，$i\\in Y, i+1\\in Y$ となる $i$ が存在しない ことは明らかであるから， $S(X \\cap J) \\geq S(Z \\cap J)$ を言えば良いが，そうでないとすると， $X' := (Z \\cap J) \\cup (X \\cap I)$ が，$R$ に対して $X$ よりも 良い解を与えることになってしまい，矛盾する． (終)．\n主張2 $X$ が $R$ に対する最大値を与える選択方法であるとき， $R+1$ に対する最大値を与える選択方法 $Y$ で，次のようなものが存在する: $l, r \\in [1, N]$ で，$l \\leq r$ かつ $r - l$ が偶数となるものが存在して， 以下が成り立つ．\n $[1, l)$ と $(r, N]$ では，$X$ と $Y$ は一致する．すなわち， $ J := [1, l) \\cup [r, N] $ と書くとき，$X \\cap J = Y \\cap J$ $X \\cap [l, r] = E(l + 1, r - 1)$ $Y \\cap [l, r] = E(l, r)$  証明 $R+1$に対する最大値を与える選択方法 $Z$ を1つとる． $X\\cap Z$ = $\\{t_1, \\ldots, t_k\\}$ と書いて，区間 $[1, t_1), (t_1, t_2), \\ldots, (t_k, N]$ を考える．これらの区間の 少なくとも一つ $I$ においては，$|X\\cap I| \u0026lt; |Z\\cap I|$ が成り立つ． $Z\\cap I = \\bigcup_{i = 1}^{m} E(l_i, r_i) $; ただし，$l_i \\leq r_i$，$r_{i} +3 \\leq l_{i+1}$ と書いたとき， $[l_i - 1, r_i + 1]$ たちは共通部分を持たないので， $|[l_i - 1, r_i + 1] \\cap X| \u0026lt; |[l_i - 1, r_i + 1] \\cap Z|$ となる $i$ が存在する． ここで，$[l_i - 1, r_i + 1] \\cap Z = E(l_i, r_i)$ であるから， $p + 2 \\leq q$ なる $p, q \\in E(l_i - 1, r_i + 1) \\setminus X $ をとることができ， さらに，$[p + 2, q - 2] \\cap X = E(p + 2, q - 2)$ とすることができる． $ l := p + 1 $, $r := q - 1$, $ Y := (X \\cap J) \\cup E(l, r)$ とする．各種関係式は，それが成り立つようにとった． $Y$ が $R+1$に対する最大値を与える選択方法であることは，主張1から従う． (終)．\nしたがって，以下のように貪欲に取っていけば良い．\n 最初は，$E(i,i)$ たちが候補になる．実際に取るのは，これらのうち， 値が最大のもの 最初の $E(i_0, i_0)$ が決まったら，新たに $E(i_0 - 1, i_0 + 1)$ が 候補になる．この候補に対する得点は， $S(E(i_0 - 1, i_0 + 1)) - S(E(i_0, i_0))$ である． 一般に，$E(l, r)$ を取ることが決まったら，新たに $E(l - 1, r + 1)$ が候補になる．ただし，たとえば，すでに $E(r + 1, m)$ が候補になっているときには， $E(r + 1, m)$ は候補から外され， $E(l - 1, r+ 1)$ ではなく，$E(l - 1, m)$ が新たな候補になる． 左側についても同様．  候補とその得点のペアを (得点を優先度として) 優先度付きキューで 管理し，各端点がどの端点との組で候補になっているかをベクトルで 管理することで，全体として $O(R \\log N)$ で答が求められる．\nACコード https://atcoder.jp/contests/abc218/submissions/25850606 int main(/* int argc, char *argv[] */) { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout \u0026lt;\u0026lt; setprecision(20); ll N, R; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; R; if (R \u0026gt; N / 2) R = N - R; vector\u0026lt;ll\u0026gt; A(N+1), B(N), P(N); for (ll i = 1; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; A[i]; for (ll i = 0; i \u0026lt; N; i++) B[i] = A[i] + A[i + 1]; using sta = tuple\u0026lt;ll, ll, ll\u0026gt;; priority_queue\u0026lt;sta\u0026gt; pque; for (ll i = 0; i \u0026lt; N; i++) { P[i] = i; pque.emplace(B[i], i, i); } ll ans = 0, cnt = 0; while (true) { auto [m, p, q] = pque.top(); pque.pop(); if (P[p] != q || P[q] != p) continue; ans += m; if (++cnt == R) break; assert(! (q == N-1 \u0026amp;\u0026amp; p == 0)); if (q == N-1) { assert(p - 1 \u0026gt;= 0); P[p - 1] = -1; }else if (p == 0) { assert(q + 1 \u0026lt; N); P[q + 1] = -1; }else { ll u = P[p - 1]; ll v = P[q + 1]; ll new_m = B[u] + B[v] - m; pque.emplace(new_m, u, v); P[u] = v; P[v] = u; B[u] = B[v] = new_m; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://yamate11.github.io/blog/posts/2021/09-13-abc218-h-red-and-blue-lamps/","summary":"公式解説にある貪欲法の証明を詳しく書きました．","title":"Red and Blue Lamps - AtCoder Beginner Contest 218 H"},{"content":"AtCoder Beginner Contest 218 - ABC 218 - C Shapes についてです．\n問題概要 問題へのリンク 2次元グリッドの，文字 # で示された2つの図形がある． 回転と平行移動で一致するかどうか判定せよ．\n制約: グリッドサイズ \u0026lt;= 200．\n経緯 コンテストでは，解けたのですが，30分以上かかりました． S と T の bounding box を作って，0, 90, 180, 270 の各度の回転で 一致するかどうかの判定をしました．\nこの手の，特別な考察が必要ではないけれど，たくさんコードを書かなければ 問題で，速く解答できるようになるには，どうすればよいのでしょうか? 今回の反省点は:\n 公式解説 にも あるように，bounding box を作るより，全体を回転した上で， 左上の # の位置を比較して 平行移動量を決めた方が簡単でした． 回転で一致するかどうかを，添字を動かす方向を変えることで調べたのですが， 実際に回転したデータを作ってしまった方が簡単でした．  ACコード ライブラリに回転を実行する関数を 追加した後のコードです．ライブラリ部分は省略しています． 全ソースは https://atcoder.jp/contests/abc218/submissions/25806964 にあります．\nint main(/* int argc, char *argv[] */) { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout \u0026lt;\u0026lt; setprecision(20); auto solve = [\u0026amp;]() -\u0026gt; bool { ll N; cin \u0026gt;\u0026gt; N; Board\u0026lt;char\u0026gt; S(N, N, \u0026#39;.\u0026#39;); cin \u0026gt;\u0026gt; S; Board\u0026lt;char\u0026gt; T(N, N, \u0026#39;.\u0026#39;); cin \u0026gt;\u0026gt; T; auto left_top = [\u0026amp;](const auto\u0026amp; B) -\u0026gt; BrdIdx { auto p = [\u0026amp;](auto\u0026amp; bi) -\u0026gt; bool { return B.at(bi) == \u0026#39;#\u0026#39;; }; return *find_if(ALL(BoardRange(B)), p); }; BrdIdx biT = left_top(T); return any_of(ALL(ItRange(0, 4)), [\u0026amp;](ll i) -\u0026gt; bool { auto SS = S.rotate(i); BrdIdx diff = left_top(SS) - biT; return all_of(ALL(BoardRange(T)), [\u0026amp;](auto\u0026amp; bi) -\u0026gt; bool { return SS.at(bi + diff) == T.at(bi) \u0026amp;\u0026amp; SS.at(bi) == T.at(bi - diff); }); }); }; cout \u0026lt;\u0026lt; (solve() ? \u0026#34;Yes\u0026#34; : \u0026#34;No\u0026#34;) \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://yamate11.github.io/blog/posts/2021/09-12-abc218-shapes/","summary":"重実装への対処は，どうしたらよいのでしょうか?","title":"Shapes -- AtCoder Beginner Contest 218 C"},{"content":"AtCoder Beginner Contest 217 - ABC 217 H - Snuketoon の解法です． slope trick を使う公式解説そのままです．\n問題概要  問題へのリンク   変数 P, S がある．時刻0には P = S = 0． 時刻1, 2, 3, ... に P に +1/-1/0 のいずれかを加えることができる． 列 ((T_i, D_i, X_i) : i ∈ [1, N]) が与えられる． T_i は単調増加する正の整数，D_i は 0または1，X_i は整数． 時刻 T_i (Pの値の変化後) において，S に dmg(P, i) を加える．ただし， dmg(P, i) = max(0, X_i - P) (D_i = 0 のとき) max(0, P - X_i) (D_i = 1 のとき) S を最小化するように P を変化させよ． 制約: N \u0026lt;= 2e5, 1 \u0026lt;= T_1 \u0026lt; T_2 \u0026lt; ... \u0026lt; T_N \u0026lt;= 1e9, | X_i | \u0026lt;= 1e9 解法  公式解説へのリンク   次の自然なDPが考えられますが，状態空間が大きすぎて間に合いません．\n 定義: dp[i][p] := 時刻 T_i において P = p の時の S の最小値 遷移: dp[i][p] := dmg(p, i) + min { dp[i-1][q] : | q - p | \u0026lt;= T_i - T_{i+1} }  関数 f_i(p) := dp[i][p] が，各 i に対して， 折れ線凸関数になることを利用します． 折れ線凸関数は，次の3つで特徴付けられます．\n 最小値 min(f) 傾きが 0→1, 1→2, \u0026hellip; と変化する点のリスト pos(f) 傾きが -1→0, -2→-1, \u0026hellip; と変化する点のリスト neg(f)  今回の問題の場合，次を実施すれば良いです．\n T_{i-1} から T_i までの時間経過の間に，t := T_i - T_{i-1} だけ 移動できます．これに対応して，pos(f) の各点が t だけ右に移動し， neg(f) の各点が t だけ左に移動します． dmg(p, i) が加えられることに対応して，X_i を pos(f) なり neg(f) なり の適切な位置に挿入します．さらに，  D_i = 1 で neg(f) に X_i を挿入した場合には，neg(f) の先頭を pos(f) の先頭に移します． D_i = 0 で pos(f) に X_i を挿入した場合には，pos(f) の先頭を neg(f) の先頭移します． これらの場合には，min(f) も適切に更新します．たとえば，pos(f) が {x0, x1, \u0026hellip; } だったときに，D_i = 0 で pos(f) に q が挿入されたとすると， x0 を neg(f) に移すとともに，min(f) に q - x0 を加えます．    第1点の移動を愚直に行うと間に合いませんので，移動距離を覚えておくだけにして， 先頭を移す操作や，X_i を挿入する操作の際には，移動距離を考慮に入れます．\nf_N の最小値が求める答です．\n実装は，pos(f) と neg(f) に優先度キューを用いました． 時刻 0 における f は，f(0) = 0 で，p != 0 のときには，f(p) = ∞ になっていてほしいです． これは，pos(f) と neg(f) の初期値が (0,0,0,\u0026hellip;) であることを意味します． しかし，実際にたくさんの0を入れてしまっては効率が悪いので， 0 はpopしないことで対処しました．\nACコード #include \u0026lt;bits/stdc++.h\u0026gt;#include \u0026lt;cassert\u0026gt;typedef long long int ll; using namespace std; int main(/* int argc, char *argv[] */) { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout \u0026lt;\u0026lt; setprecision(20); ll N; cin \u0026gt;\u0026gt; N; ll minf = 0; priority_queue\u0026lt;ll, vector\u0026lt;ll\u0026gt;, greater\u0026lt;ll\u0026gt;\u0026gt; posf; priority_queue\u0026lt;ll\u0026gt; negf; ll shift = 0; auto push_pos = [\u0026amp;](ll x) -\u0026gt; void { if (x \u0026lt; shift) posf.push(x - shift); }; auto push_neg = [\u0026amp;](ll x) -\u0026gt; void { negf.push(x + shift); }; auto top_pos = [\u0026amp;]() -\u0026gt; ll { return posf.top() + shift; }; auto top_neg = [\u0026amp;]() -\u0026gt; ll { return negf.top() - shift; }; auto pop_pos = [\u0026amp;]() -\u0026gt; void { if (posf.top() != 0) posf.pop(); }; auto pop_neg = [\u0026amp;]() -\u0026gt; void { if (negf.top() != 0) negf.pop(); }; posf.push(0); negf.push(0); for ( ; N \u0026gt; 0; N--) { ll t, d, x; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; d \u0026gt;\u0026gt; x; shift = t; if (d == 0) { ll y = top_pos(); if (x \u0026lt;= y) { push_neg(x); }else { minf += x - y; push_pos(x); pop_pos(); push_neg(y); } }else if (d == 1) { ll y = top_neg(); if (y \u0026lt;= x) { push_pos(x); }else { minf += y - x; push_neg(x); pop_neg(); push_pos(y); } } } cout \u0026lt;\u0026lt; minf \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://yamate11.github.io/blog/posts/2021/09-05-abc217-h-snuketoon/","summary":"slope trick というのは忘れていましたが，そもそもHまで到達しませんでした．この記事は公式解説そのままです．","title":"Snuketoon - ABC217 H"},{"content":"「牛ゲー」なる手法のまとめです． ABC216 G - 01Sequence で出てきました．\n適用できる問題 $(c_{ij} \\mid i, j \\in [1, N])$ と，$S, T \\in [1, N]$ が与えられる． 変数 $x_1, \\ldots, x_N$ に対する制約\n $x_i - x_j \\leq c_{ij}$  のもとで，$ x_T - x_S $ の最大値を求めよ．\n解法 集合 $\\{1, .., N\\}$ 上に，$i$ から $j$ に距離 $c_{ij}$ の辺がある グラフを考える． 以下のようになる (参照 ):\n 制約を満たす解がある $\\Leftrightarrow$ グラフに負閉路がない グラフに負閉路がない場合:  $ x_T - x_S $ の最大値がない (いくらでも大きくできる) $\\Leftrightarrow$ $T$ は $S$ から到達できない   グラフに負閉路がなく，$T$ が $S$ から到達できる場合  $ x_T - x_S $ の最大値は，グラフ上の $S$ から $T$ への最短路長に一致する．    最後の行が重要．特に，全部の $c_{ij}$ が非負なら， ダイクストラで解ける．\n","permalink":"https://yamate11.github.io/blog/posts/2021/08-30-ushi-game/","summary":"「牛ゲー」なる手法のまとめです","title":"「牛ゲー」"},{"content":"AtCoder Beginner Contest 216 (ABC216) G - 01Sequence の解法です． 公式解説 によると 「牛ゲー 」で解けるとのことですが，別の (より効率が悪い) 方法で解きました．\n問題へのリンク https://atcoder.jp/contests/abc216/tasks/abc216_g 問題概要 $N$ と $(L_i, R_i, X_i)$ ($i = 1, \\ldots , M$) が与えられる． 長さ$N$の0と1からなる数列 $(A_i \\mid i \\in [1, N])$ で， 条件 $ | \\{ i \\in [L_i, R_i] \\mid A_i = 1 \\}| \\geq X_i $ を満たすもののうち， 1の数が最小のものを一つ作れ．\n制約: $ N, M \\leq 2 \\times 10^5 $\n解法 0の数の条件に書き換える．$Y_i := R_i - L_i + 1 - X_i$ として， 条件 $ | \\{ i \\in [L_i, R_i] \\mid A_i = 0 \\}| \\leq Y_i $ のもとで， 全体の0の数を最大にする．\n$S_j := \\{ i \\in [1, M] \\mid L_i \\leq j \\leq R_i \\}$　と書く．\n$A_0, A_1, \\ldots$ の順に $A_i$ の値を，貪欲に 0 を 置くように決めていくことができる．理由は以下の通り． 今，$A$ が条件を満たすとする．$i \\in S_j$ に対し，\n$ t(i, j) := | \\{ k \\in [L_i, j) \\mid A_k = 0 \\} |$\nと書く．ある $j\\in [1, N]$ について，$A_j = 1$ であり，しかも すべての $i \\in S_j$ について $t(i, j) \u0026lt; Y_i$ であったとする．この次に$A$の値が0となる添字を $k$ とする， すなわち，$A_{k} = 0$ で，すべての $l \\in [j, k)$ に対して $A_l = 1$ とする．このとき，$A_j$ と $A_{k}$ の 0/1 を入れ替えた列も，条件を満たす． そのような $k$ が存在しないときは，単に $A_j$ の値を 0 にした列が 条件を満たす．\nしたがって，次の構成を行えば良い: $A_0, \\ldots, A_{j-1}$ まで決めたとして，$A_j$ を定める．\n すべての $i \\in S_j$ について，$t(i, j) \u0026lt; Y_i$ のとき，$A_j = 0$ そうでないとき，$A_j = 1$  イベントソートを用いて，次のようにすれば良いように考えられる．\n 初期時点 $j = -1$ では，すべての $i$ に対し，その残り容量は $\\infty$ である． 時点$j$ において，  $j = L_i$ となる $i$ の残り容量を $Y_i$ に設定する． $j = R_i$ となる $i$ の残り容量を $\\infty$ に設定する． 残り容量が 0 である $i$ がある場合，  $A_i := 1$ と定める．   残り容量が 0 である $i$ がない場合，  $A_i := 0$ と定める． 全部の $i$ の残り容量を 1 減らす．      しかし，全部の残り容量を愚直に減らしていては間に合わない． 代わりに， 「自分の区間が終わるまでに，0の累積個数 $n$ がいくつ以下でなければならない」 という量 $Z_i$ を持つことにする．\n 初期時点 $j = -1$  すべての $i$ に対し，$ Z_i := \\infty $ $n := 0$   時点$j$ において，  $j = L_i$ となる $i$ に対し，$ Z_i := n + Y_i $ $j = R_i$ となる $i$ に対し，$ Z_i := \\infty $ $Z_i$ たちの最小値が $n$ である場合:  $A_i := 1$   $Z_i$ たちの最小値が $n$ より大きい場合:  $A_i := 0$ $n := n + 1$      これは，$Z_i$ を優先度キューで管理することで実装できる．\nACコード https://atcoder.jp/contests/abc216/submissions/25452502 ","permalink":"https://yamate11.github.io/blog/posts/2021/08-30-abc216g-01sequence/","summary":"公式解説とは違う (より効率の悪い) 方法で解きました．","title":"01Sequence - ABC216 G"},{"content":"AtCoder Beginner Contest 214 - ABC 214 G - Three Permutations の解法です．\n解説ACです． 公式解説 も参考になりましたが，それだけでは解答は作れませんでした． kmjpさんのブログ が助けになりました．ありがとうございます．\n問題へのリンク https://atcoder.jp/contests/abc214/tasks/abc214_g 問題概要 $1, \\ldots, N$ の順列の全体を $\\textrm{Perm}$ と書く． $p, q \\in \\text{Perm}$ が与えられる． 条件「$x = p(i)$ または $x = q(i)$」を，$\\text{Coi}(x, i)$ と書く ことにする． $r \\in \\text{Perm}$ に対して， $C(r) := \\{ i \\in [1, N] \\mid \\text{Coi}(r(i), i) \\}$ とする． 集合 $\\{r \\in \\text{Perm} \\mid C(r) = \\varnothing \\}$ の要素数を mod $10^9 + 7$ で求めよ．\n解法 $r \\in \\text{Perm}$， $X \\subseteq [1, N]$， $k \\in [0, N]$ に対して，次のように書くことにする:\n $S(X) := \\{r \\in\\text{Perm} \\mid X \\subseteq C(r) \\}$ $R_k := \\sum \\{ |S(X)| \\mid X \\subseteq [1, N],\\; |X| = k \\}$ $r \\downarrow X := r$ の定義域を $X$ に制限したもの $\\text{Perm}'(X) := \\{ r \\downarrow X \\mid r \\in \\text{Perm} \\}$ $S'(X) := \\{ r \\downarrow X \\mid r \\in S(X) \\} = \\{r' \\in \\text{Perm}'(X) \\mid \\forall i \\in X.\\; \\text{Coi}(r'(i), i) \\} $  包除原理により，求める答は $N! - \\sum_{k=1}^{N} (-1)^{k - 1} R_k$ となるから，各$k$ に対する $R_k$ を求めれば良い． また，$|S(X)| = |S'(X)| \\times (N - |X|)!$ であるから， $\\sum\\{ |S'(X)| \\mid X \\subseteq [1, N],\\; |X| = k \\}$ を求めれば良い．\n集合 $[1, N]$ 上で，すべての $(p_i, q_i)$ を 結んだグラフを考える．どの頂点も次数は2以下である． 連結成分は，自己ループか，サイクルかのいずれかである． 連結成分全体の集合を $\\mathcal{Z}$ と書く． $Z\\in \\mathcal{Z}$ に対して， $Z$内にある辺に対応する番号の集合を $I(Z) := \\{ i \\in [1, N] \\mid p(i), q(i) \\in Z \\}$ と書く． $S'(X)$ の要素 $r$ は，各連結成分$Z$に， $\\sum_{Z \\in \\mathcal{Z}} t_Z = |X|$ となるように非負整数 $t_Z$ を 割り当てて，$Z$から$t_Z$本の辺に対して端点を選択することによって 決まる．正確には，\n $Q(Z, t) := \\{ r \\in S'(Y) \\mid Y \\subseteq I(Z), \\; |Y| = t \\}$ $Q(t) := \\{ ((Z, r_Z) \\mid Z \\in \\mathcal{Z} ) \\mid r_Z \\in Q(Z, t_Z),\\; \\sum_{Z \\in \\mathcal{Z}} t_Z = t\\}$ $\\rho_t : \\bigcup \\{ S'(X) \\mid |X| = t \\} \\to Q(t), \\; \\rho(r) = ( r \\downarrow I(Z) \\mid Z \\in \\mathcal{Z} )$  と書いたときに，$\\rho_t$ が全単射を与える．したがって， $|Q(t)|$ を求めれば良い．\nまず，$|Q(Z, t)|$ を求めよう．これは，$t$ にはもちろん依存するが， $Z$ に関しては，そのサイズ $s = |Z|$ にしか依存しないのは明らかであるので， $|Q(Z, t)|$ を $f(s, t)$ と書くことにする．\nまず，あきらかに，$ f(1, 1) = 1$であり，$t \u0026gt; 1$ のとき，$f (1, t) = 0$ である． $s \u0026gt;= 2$ については，DP で求める． $Z$ が円環状になっているので，次のように構成する． $I(Z)$ を $\\{ x_1, x_2, \\ldots, x_s \\}$ と， $q(x_{i}) = p(x_{i+1})$ が成り立つように列挙する．\n dp1[i][t][a][b] := 次を満たす r の数: ($a, b \\in \\{0, 1, 2\\}$)  $ \\text{dom}(r) \\subseteq \\{ x_1, \\ldots, x_i \\} $ $ t = |\\text{dom}(r)| $ a = 0: $x_s \\not\\in \\text{dom}(r)$ と矛盾しない． a = 1: $r(x_s) = p(x_s)$ と矛盾しない． a = 2: $r(x_s) = q(x_s)$ と矛盾しない． b = 0: $x_i \\not\\in \\text{dom}(r)$ b = 1: $r(x_i) = p(x_i)$ b = 2: $r(x_i) = q(x_i)$   初期値  dp1[0][0][a][0] = 1 (a = 0,1,2) dp1[0][1][a][1] = 1 (a = 0,1) dp1[0][1][a][2] = 1 (a = 0,1,2)   遷移  dp1[i+1][t][a][0] += dp[i][a][b] (b = 0,1,2) dp1[i+1][t+1][a][1] += dp[i][a][b] (b = 0,1) dp1[i+1][t+1][a][2] += dp[i][a][1] (b = 0,1,2)    DP実行後，$f(s, t) = dp1[s][t][0][0] + dp1[s][t][1][1] + dp1[s][t][2][2]$ で，$f$ が決定できる． 計算を振り返ってみると，$s$ ごとに別々にDPを実行する必要はなく， 1回のDPを $\\max(|Z|)$ まで実行することで， すべての必要な $f(s, t)$ を計算することができる． このDPの計算量は $O(N)$ である．\nこの準備のもとで，$|Q(t)|$ は，次のDPで求めることができる．\n $\\text{dp2}[i][t] := |\\{ ((j, r_j \\mid j \\leq i) \\mid r_j \\in Q(Z, t_j),\\; \\sum_{j\\leq i}t_j = t \\} |$ 遷移: $\\text{dp2}[i][t] = \\sum_{s \u0026lt; t} (\\text{dp2}[i-1][s] \\times f(|Z_i|, t - s))$  このDP実行終了後，$u := |\\mathcal{Z}|$ として， $|Q(t)| = \\text{dp2}[u][t]$ である． 計算量が心配になるが，遷移の式に現れる積の計算の回数は， $|Z_i| = a_i$ として， $a_1 + a_1 * a_2 + (a_1 + a_2) * a_3 + \u0026hellip;+ (a_1 + \u0026hellip; + a_{u-1}) * a_u \\leq (a_1 + \u0026hellip; + a_u)^2 = N^2$ なので，$O(N^2)$ である．\nACコード https://atcoder.jp/contests/abc214/submissions/25379311 ","permalink":"https://yamate11.github.io/blog/posts/2021/08-27-abc214g-three-permutations/","summary":"調べた結果分かった解法を記述します．いろいろ勉強になりました．","title":"Three Permutations - ABC 214 G"},{"content":"AtCoder Regular Contest (ARC) 124 E - Pass to Next の解法です． コンテスト後にも解けませんでした． 公式解説 を読んだだけではわからず， laycrsさんのツイートとコード を読んで，なんとか理解しました．\n問題へのリンク https://atcoder.jp/contests/arc124/tasks/arc124_e 問題概要 1, 2, \u0026hellip;, N の番号のついた人が円環状に並ぶ． 各人は a_i 個のボールを持っている． 0個以上 a_i 個のボールを右隣の人に一斉に渡す (1回限り)． その結果 人 i が持つボールの数を x_i とする． 有り得る $(x_i \\mid i \\in [1, N])$ 全体の集合を S とする． $\\sum \\{ \\prod \\{ x_i \\mid i \\in [1, N] \\} \\mid x \\in S \\}$ を mod 998244353 で求めよ．\n解法 (わかってしまえば，公式解説と書いていることは同じです)\n異なる渡し方が同じ $x$ を生成するための条件は，渡す個数の差が 全員同じであることであるから，「渡す個数が 0 の人が一人以上いる」 という条件をつけると，生成される $S$ には変化がなく，かつ，渡し方と $S$ が1対1に対応する．\n$x$ を一つ固定すると，$\\prod \\{ x_i \\mid i \\in [1, N] \\}$ は， 各人の操作後のボールから1つを選ぶ選び方の数と一致する．\n求める答は，以下の塗り方の数と一致する:\n 各 $i \\in [1, N] $ に対し，$a_i + 1$ 枚のカードが1列に横に並んで グループをなしており， 全体では円環上に並んでいる (グループ N の次にグループ 1 が来る)． 以下の条件を満たすように，いくつかのカードを黒く， いくつかのカードを赤く塗る．  各グループのカードのうち，ちょうど1枚を黒く塗る． 黒く塗るカードが右端のカードであるグループが1つ以上有る． どの2枚の黒いカードの間にも，赤いカードがちょうど1枚有る．    各グループの，黒いカードより右側のカードが，右隣の人に渡したボールに 対応し，黒いカードより右側のカードは，手元に残したボールに対応する． 赤いカードは，「選んだ」ボールに対応する．\nこのような塗り方を，以下の DP で数える．\n dp[i][a][b][c] := 第 $i$ グループまでを以下の条件を満たすように塗る方法の数  $a \\in \\{0, 1\\}$． $a = 0$ では，最後のグループで，黒いカードより右側に赤いカードが無いことを 仮定する． $a = 1$ では，有ることを仮定する． $b \\in \\{0, 1\\}$． $b = 0$ は，第 $i$ グループで，黒いカードよりも右に 赤いカードが無いことを示す． $b = 1$ は，有ることを示す． $c \\in \\{0, 1\\}$． $c = 0$ は，第 1 グループから第 $i$ グループまででは， 右端のカードを黒く塗ったものが無いことを示す． $c = 1$ は，有ることを示す．    遷移は下のコードを参照．\n求める答は，dp[N][0][0][1] + dp[N][1][1][1] である．\nACコード Fp binom(ll n, ll r) { // 二項係数．3までしか出てこない  if (r \u0026lt; 0 || n \u0026lt; r) return 0; if (r == 0) return 1; if (r == 1) return n; if (r == 2) return Fp(n) * Fp(n - 1) / Fp(2); if (r == 3) return Fp(n) * Fp(n - 1) * Fp(n - 2) / Fp(6); assert(0); } int main(/* int argc, char *argv[] */) { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout \u0026lt;\u0026lt; setprecision(20); ll N; cin \u0026gt;\u0026gt; N; vector\u0026lt;ll\u0026gt; A(N); for (ll i = 0; i \u0026lt; N; i++) cin \u0026gt;\u0026gt; A[i]; auto tbl_init = vector(2, vector(2, vector(2, Fp(0)))); auto tbl = tbl_init; tbl[0][0][0] = tbl[1][1][0] = 1; for (ll i = 0; i \u0026lt; N; i++) { auto prev = move(tbl); tbl = tbl_init; for (ll a = 0; a \u0026lt; 2; a++) { // 遷移前後でaは変わらず  for (ll b = 0; b \u0026lt; 2; b++) { // 遷移前  for (ll b0 = 0; b0 \u0026lt; 2; b0++) { // 遷移後  for (ll c = 0; c \u0026lt; 2; c++) { // 遷移前  for (ll c0 = 0; c0 \u0026lt; 2; c0++) { // 遷移後  // n 枚から r 枚を選んで，下の (*) で更新する．  ll n = A[i] + 1; // r は最大で 黒1, 赤2 の 3枚だが，  // グループ i-1 で選択されていたら1減じる．  // グループ i で選択しないのであれば1減じる．  ll r = 3 - b - (1 - b0); if (c \u0026amp;\u0026amp; !c0) continue; // 矛盾  else if (!c \u0026amp;\u0026amp; c0) { // このグループで右端を黒く塗る  if (b0) continue; // 右端より右には置けない  // 右端を黒に決めたので，n, r とも1減じる．  n--; r--; }else if (!c \u0026amp;\u0026amp; !c0 \u0026amp;\u0026amp; !b0) n--; // 右端は選べない  tbl[a][b0][c0] += binom(n, r) * prev[a][b][c]; // (*)  } } } } } } cout \u0026lt;\u0026lt; tbl[0][0][1] + tbl[1][1][1] \u0026lt;\u0026lt; endl; return 0; } Fp は，mod 998244353 を計算するための構造体です． https://atcoder.jp/contests/arc124/submissions/25361161 ","permalink":"https://yamate11.github.io/blog/posts/2021/08-27-arc124e/","summary":"解けませんでした．解説を読んでも分からなかったので，自分なりの説明です．","title":"Pass to Next - ARC 124 E"},{"content":"鹿島建設プログラミングコンテスト2020 (AtCoder Regular Contest 110 - ARC110) の E - Shorten ABC の解法です．\n経緯 解説AC です．公式解説も皆さんの解説もたくさん参考にしています．\n問題概要 A, B, C からなる，長さ N の文字列がある． 隣り合った異なる文字を，どちらとも違う文字で置き換える操作ができる． 操作を0回以上行ってできる文字列の数を mod $10^9 + 7$ で求めよ．\n制約: $N \\leq 10^6$\n 問題へのリンク   解法 Python 流に，文字列 s と t の連結を s+t で， 文字列sの位置p(含む)から位置q(含まない)の部分文字列をs[p:q]で表す． 文字列長1の文字列と文字を同一視する．\n与えられた文字列が1種類の文字からなるときは，答は 1 である． 以下，そうでないとする．\nA,B,Cからなる文字列 s に対する e(s) を定義する．\n e(\u0026ldquo;A\u0026rdquo;) = 1 e(\u0026ldquo;B\u0026rdquo;) = 2 e(\u0026ldquo;C\u0026rdquo;) = 3 e(s + c) = e(s) XOR e(c) (len(c) = 1)  次が成り立つ．\n 文字列 s を文字 c に変換できるための必要十分条件は，以下の 両方が成り立つことである．  e(s) = e(c) len(s) = 1 であるか，または，s が2種類以上の文字を含む．    帰納法で簡単に証明できる．次も成り立つ．\n 長さ a の文字列 s が2種類以上の文字を含むとする． s を長さ b の文字列 t に変換できる必要十分条件は， $0 = p_0 \u0026lt; p_1 \u0026lt; \u0026hellip; \u0026lt; p_{b} = a$ なる列がとれて， $e(s[p_i:p_{i+1}]) = e(t[i])$ が成り立つことである．  必要性は明らかなので，十分性を示す． $s[p_i:p_{i+1}]$ が1種類の文字 X しか含まない場合が問題となる． $p_{i+1} - p_i$ は奇数で，t[i] = X である． このブロックより右か左に X 以外の文字が現れるところがある． どちらでも同じなので，右に現れるとしよう． $s[p_j:p_{j+1}]$ に X 以外の文字が現れ，$i \u0026lt; k \u0026lt; j$ なる $s[p_k:p_{k+1}] $ には，X しか現れないとする． この場合，$p_{k+1} - p_k$ は奇数で，t[k] = X である． そこで，切り方を変えて，$s[p_i], \\ldots, s[p_i + (j - i - 1)]$ の各 1文字を t[i], \u0026hellip;, t[j-1] に対応させ， $s[p_i + (j-i-1):p_{j+1}]$ を t[j] に対応させる．t[j] に対応させる文字列は，元の対応文字列に 偶数個の X を追加したものであるから，XOR の値は変わらない． したがって，t に変換することが可能である．(終)\ns を与えられた文字列とする． 上で示したことから，s から変換可能な長さ b の文字列 t に対して， 「左から貪欲に切っていく分割」を対応させることができる．正確には， $0 = p_0 \u0026lt; p_1 \u0026lt; \u0026hellip; \u0026lt; p_{b} \\leq N$ であって，以下を満たすものを対応させる．\n $e(s[p_i:p_{i+1}]) = e(t[i]) \\qquad (i = 0, \\ldots, b-1)$ $e(s[p_i:q] \\neq e(t[i]) \\qquad (i = 0, \u0026hellip;, b-1; p_i \u0026lt; q \u0026lt; p_{i+1})$ $e(s[p_b:N]) = 0$  このような分割を数えれば良い．$p_b = i$ となるような分割の数 dp[i] を，配るDPを用いて数えよう． t = 0, 1, 2, 3 と，$0 \\leq i \u0026lt; N$ に対して，\n $\\textrm{nxt}(i, t) := \\min \\{ j \\mid e(s[p:j]) = t, i \u0026lt; j \\}$  とするとき，t = 1, 2, 3 に対して，\n dp[nxt(i, t)] += dp[i]  なる計算を行えば良い．求める答は， $\\sum \\{ dp[i] \\mid 1 \\leq i \\leq N; e(s[i:N]) = 0 \\}$ である．\n$e(s[i:N]) = 0$ を満たす i は，後ろから順に $O(N)$ で決定できる． nxt(i, t) も，t = 0 も含めて後ろから順に，\n nxt(i, e(s[i])) = i + 1 nxt(i, (t XOR e(s[i])) % 4) = nxt(i + 1, t)  と計算すれば，やはり $O(N)$ で求められる． 全体として $O(N)$ で問題を解くことができた．\nACコード Fp は，mod $10^9 + 7$ を取るためのクラスです．\nint main(/* int argc, char *argv[] */) { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout \u0026lt;\u0026lt; setprecision(20); ll N; cin \u0026gt;\u0026gt; N; string S; cin \u0026gt;\u0026gt; S; if (all_of(S.begin(), S.end(), [\u0026amp;](char t) -\u0026gt; bool {return t == S[0];})) { cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; return 0; } vector\u0026lt;ll\u0026gt; E(N); for (ll i = 0; i \u0026lt; N; i++) E[i] = S[i] - \u0026#39;A\u0026#39; + 1; vector nxt(4, vector\u0026lt;ll\u0026gt;(N + 1)); for (ll t = 0; t \u0026lt; 4; t++) nxt[t][N] = N + 1; for (ll i = N-1; i \u0026gt;= 0; i--) { nxt[E[i]][i] = i + 1; for (ll t = 1; t \u0026lt; 4; t++) nxt[E[i] ^ t][i] = nxt[t][i + 1]; } vector\u0026lt;Fp\u0026gt; tbl(N + 2); tbl[0] = 1; for (ll i = 0; i \u0026lt; N; i++) { for (ll t = 1; t \u0026lt; 4; t++) tbl[nxt[t][i]] += tbl[i]; } vector\u0026lt;ll\u0026gt; accE(N + 1); for (ll i = N-1; i \u0026gt;= 0; i--) accE[i] = E[i] ^ accE[i + 1]; Fp ans = 0; for (ll i = 1; i \u0026lt;= N; i++) if (accE[i] == 0) ans += tbl[i]; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://yamate11.github.io/blog/posts/2021/08-26-shorten-abc/","summary":"解説AC です．公式解説も皆さんの解説もたくさん参考にしています．","title":"Shorten ABC - AtCoder Regular Contest 110 E"},{"content":"問題へのリンク https://atcoder.jp/contests/arc125/tasks/arc125_e 経緯 ARC125 には参加できなかったので，バーチャルコンテストで解きました． Cまでしか解けなかったので，バーチャルコンテスト終了後に考えましたが， 全然解けませんでした．フローは考えたのですが，間に合うはずがない (それは正しい) と思って，そこから先には進めませんでした．\n問題概要 正の整数列 $(A_i \\mid i \\in [1, N]), (B_j \\mid j \\in [1, M]), (C_j \\mid j \\in [1, M]) $ が与えられる． $(D_{ij} \\mid i \\in [1, N], j \\in [1, M])$ を次を満たすように取るとき， $\\sum \\{ D_{ij} \\mid i \\in [1, N], j \\in [1, M] \\}$ の最大値を求めよ．\n $\\sum \\{ D_{ij} \\mid j \\in [1, M] \\} \\leq A_i$ $D_{ij} \\leq B_j$ $\\sum \\{ D_{ij} \\mid i \\in [1, N] \\} \\leq C_j$  制約: $N, M \\leq 2\\times 10^5$, $A_i, C_j \\leq 10^{12}$, $B_j \\leq 10^7$\n解法 次のフローの最大流問題として定式化できる．\n Source $\\to L_i$ 容量 $A_i$ $L_i \\to R_j$ 容量 $B_j$ $R_j \\to$ Sink 容量 $C_j$  容量が大きくノードが多いので，Dinic などでは解けない．\n最小カット $(A, B)$ を求める．Source $\\in A$ とする． $L_i$ たちのうち，$A$ に属するものの集合を $X$, $|X| = n$ とする． $R_j$ については，\n $R_j \\in A$ とすると，カット容量への寄与は $C_j$ $R_j \\in B$ とすると，カット容量への寄与は，$n B_j$  であるから，$(A, B)$ の最小性より，\n $C_j \u0026lt; n B_j$ なら $R_j \\in A$ $C_j \u0026gt; n B_j$ なら $R_j \\in B$  となる必要がある．カット容量は全体として，\n$$ \\sum \\{ A_i \\mid i \\in [1, N] - X \\} + \\sum \\{ \\min(C_j, n B_j) \\mid j \\in [1, M] \\} $$\nであるから，$A_i$ の大きい方から $n$ 個が $X$ に属するとして良い． $n = 1, \\ldots, N$ について計算して最小値を取れば良い．\nACコード https://atcoder.jp/contests/arc125/submissions/25313748 ","permalink":"https://yamate11.github.io/blog/posts/2021/08-24-snack/","summary":"解法です．公式解説そのままです．","title":"Snack - Atcoder Regular Contest 125 E"},{"content":"問題へのリンク https://atcoder.jp/contests/abc215/tasks/abc215_h 経緯 コンテスト中は，そもそもHには到達もしませんでした． コンテスト後に考えましたが，歯が立ちませんでした．\n Hall の定理は，見たことはあったけど，覚えていなかった 高速ゼータ変換や高速メビウス変換のライブラリは持っていたのですが， どう使うか知らなかった．  というわけなので，解けるはずがありませんでした．\n問題概要 正の整数$N$, $M$; 各 $i\\in [1, N]$ と 各 $j \\in [1, M]$ に対して 正の整数 $A_i$, $B_j$, および $C_{ij} \\in \\{0, 1\\}$ が与えられる． ただし，任意の $j$ に対して $i$ が存在して $C_{ij} = 1$ である．\n$i\\in [1, N]$ に対して $|D_i| = A_i$ となる互いに素な集合 $D_i$ を固定し， $D = \\bigcup \\{ D_i \\mid i \\in [1, N] \\}$ と書く． $D$ の部分集合 $E$ と $i \\in [1, N]$ に対して，$E_i := E \\cap D_i$ とする． $E$ に関する次の条件を考える．\n $E$ の $M$ 個の分割 $(F_1, \\ldots, F_M)$ で，以下を満たすものは存在しない  $F_j \\cap E_i \\neq \\emptyset \\implies C_{ij} = 1$ 各 $i \\in [1,N]$ に対して， $ \\bigcup \\{ F_j \\cap E_i \\mid j \\in [1,M] \\} \\geq B_j $    条件を満たす $E$ のうち，$X = |D - E|$ の最小値を求めよ． また，最小値を与える $E$ の個数を，mod 998244353 で求めよ．\n制約: $N \\leq 20$; $M \\leq 10^4$; $A_i, B_j \\leq 10^5$\n予備知識 Hall の定理 $A$, $B$ を有限集合，$G \\subseteq A \\times B$ とするとき， 以下の2条件は同値である．\n 単射 $f: A \\to B$ で，$(a, f(a)) \\in G$ であるものが存在する． 任意の $X \\subseteq A$ に対して，$ |X| \\leq |f[X]|$．  ただし，$f[X] := \\{ b \\in B \\mid \\exists a \\in A. f(a) = b \\}$．\n証明は，たとえば高校数学の美しい物語 に載っています．\nゼータ変換，メビウス変換 $A$ を有限集合とする．$A$の冪集合を $ \\mathcal{P}(A) $ と書く．\n$ f : \\mathcal{P}(A) \\to M $ に対して， $ \\zeta_{U}(f) : \\mathcal{P}(A) \\to M $ と $ \\zeta_{L}(f) : \\mathcal{P}(A) \\to M $ を， 次で定義する．\n $ \\zeta_{U}(f)(X) = \\sum \\{ f(Y) \\mid X \\subseteq Y \\} $ $ \\zeta_{L}(f)(X) = \\sum \\{ f(Y) \\mid Y \\subseteq X \\} $  作り方を考えると，$\\zeta_{U}$, $\\zeta_{L}$ には，逆変換が存在する． これらを，$\\mu_{U}$, $\\mu_L$ と書く．\n高速ゼータ変換，高速メビウス変換 以下のアルゴリズムによって， $(f(X) \\mid X \\subseteq A)$ が与えられた時に $\\alpha = \\zeta_U, \\zeta_L, \\mu_U, \\mu_L$ に対し， $(\\alpha(f)(X) \\mid X \\subseteq A)$ を，$O(|A| \\log|A|)$ で 計算できる．\n 配列 $P := [(X, f(X)) \\mid X \\subseteq A]$ 各 $x \\in A$ に対して以下によって $P$ を更新する．  各 $X \\subseteq A \\setminus \\{x\\}$ に対して $Y := X \\cup \\{x\\}$ とおいて， $(P[X], P[Y]) := (P[X] + u P[Y], v P[X] + P[Y])$    ただし，$u$, $v$ は，以下の値を使う\n $\\zeta_U$ \u0026hellip; $(u, v) = (1, 0)$ $\\zeta_L$ \u0026hellip; $(u, v) = (0, 1)$ $\\mu_U$ \u0026hellip; $(u, v) = (-1, 0)$ $\\mu_L$ \u0026hellip; $(u, v) = (0, -1)$  妥当性の説明は，「高速ゼータ変換」で検索すると，いろいろなところに出ています．\n解法 公式解説 そのままです．\n次のように定める．\n $T_j := \\{ i \\in [1, N] \\mid C_{ij} = 1 \\}\\qquad (j \\in [1, M])$ $f(S) := \\sum \\{ A_i \\mid i \\in S \\} \\qquad S \\subseteq [1, N]$ $g(S) := \\sum \\{ B_j \\mid T_j ⊆ S \\}\\qquad S \\subseteq [1, N]$  $f$ は，愚直に $O(N 2^N)$ で計算できる． $g$ は，$\\zeta_L$ を使って $O(NM + N 2^N)$ で計算できる．\nHall の定理を使うために，$j \\in [1, M]$ に対して $|H_j| = B_j$ なる互いに素な集合を用意して， $H := \\bigcup \\{H_j \\mid j \\in [1, M]\\}$ とする． $G := \\{(d, h) \\in E \\times H \\mid d \\in E_i, h \\in H_j, C_{i,j} = 1 \\}$ Hall の定理から，$E$ が上記の条件を満たすための必要十分条件は\n $f(E, S) \u0026lt; g(S)$ となる $S \\subseteq [1, N]$ が存在する  ことである．ただし，\n $f(E, S) := \\sum \\{ | E_i | \\mid i \\in S \\} \\qquad S \\subseteq [1, N]$  である．したがって，$f(S) \u0026gt; 0$ である 全部の $S \\subseteq [1, N]$ に対する $ f(S) - g(S) + 1 $ の最小値が，求める $X$ の値となる． (ただし，0以下の時にはそもそも$A$が分割できないので，$X=0$)．\n後半は，$X= 0$ なら個数は 1 なので，$X\u0026gt; 0$ とする．\n $F := \\{ S \\subseteq [1, N] \\mid f(S) - g(S) + 1 = X \\}$  とする．$S \\subseteq [1, N]$ に対し，\n $h(S)$ := $D$ から $X$ 個の要素を選ぶ方法のうち，選ばれた要素の添字の 集合がちょうど $S$ となるものの数  とする．求める答は\n $\\sum \\{ h(S) \\mid \\exists S' \\in F.\\; S \\subseteq S' \\}$  である．$S \\subseteq [1, N]$ が $\\exists S' \\in F.\\; S \\subseteq S'$ を満たすかどうかは， $F$ の特性関数を $\\zeta_U$ で変換することで分かる． また，$p := \\zeta_L(h)$ とおくと，\n $p[S] = \\bigcup \\{ D_i \\mid i \\in S \\}$ から X 個の要素を選ぶ方法の数 = $\\binom{f(S)}{X}$  である．したがって，$h$ は，$\\mu_L(p)$ で求めることができる．\nACコード https://atcoder.jp/contests/abc215/submissions/25289505 ","permalink":"https://yamate11.github.io/blog/posts/2021/08-23-cabbage-master/","summary":"公式解説そのままですけれど，予備知識を一応書きました．","title":"Cabbage Master - Atcoder Beginner Contest 215 H"},{"content":"xor畳み込み 長さ $2^K$ の数列 $X$, $Y$ があるとき， これらのxor畳み込みを，以下を満たす長さ $2^K$ の列 $Z$ として定める． ただし，$x \\oplus y$ は $x$ と $y$ の xor とする．\n $ Z_k = \\sum \\{ X_i Y_j \\mid i \\oplus j = k \\} $  以下では，$Z = X * Y$ と書く．\nアダマール変換 長さ $2^K$ の数列に作用するアダマール変換は，以下の行列 $H_K$ で定義される 1次変換である．\n$$ H_0 = 1 $$\n$$ H_{k + 1} = \\begin{bmatrix} H_k \u0026amp; H_k \\\\\nH_k \u0026amp; -H_k \\end{bmatrix} $$\n本来は，正規化のために定数倍するが， ここでは，結果を整数にするためにそうしていない．\n$ H_k H_k = 2^k I $ が成り立つので，$(H_k)^{-1} = 2^{-k} H_k$ である．\n畳み込みとアダマール変換 以下が成り立つことが，計算することで容易に分かる．\n$$ (H_K X) (H_K Y) = H_K (X * Y) $$\nただし，左辺は，成分ごとの積．したがって，xor 畳み込みは，下のように計算できる．\n$$ X * Y = 2^{-K} H_K ((H_K X) (H_K Y)) $$\nアダマール変換は，定義に従って $O(n \\log n)$ で計算できる．($n = 2^K$)\nメモリを賢く使って計算している例が kazuma8128\u0026#39;s blog に載っている．\nこれを使える問題 ABC212 H Nim Counting ","permalink":"https://yamate11.github.io/blog/posts/2021/08-10-xor-conv/","summary":"高速アダマール変換によって，xor畳み込みをする方法についての記事 (自分用のメモ) です．","title":"xor畳み込み"},{"content":"C++ での型の変換などのいろいろな変換方法を書いておきます．競技プログラミング用途です．ソース冒頭に次のように書いてあるものとします．\n#include \u0026lt;bits/stdc++.h\u0026gt;typedef long long int ll; using namespace std; 文字列→数値 std::stoi, std::stoll を使う．2進数などを読みたいときは，base を指定すれば良い．\nint stoi( const string\u0026amp; str, size_t* pos=0, int base=10 ); long long stoll( const string\u0026amp; str, size_t* pos=0, int base=10 ); 使用例\nstring s1 = \u0026#34;101\u0026#34;; ll x = stoll(s1); // x == 101  ll y = stoll(s1, 0, 2); // y == 5 似たような名前で std::strtoll などもあるが， これらは引数に const char* を取る． const string\u0026amp; を引数に取る stoll などの方が便利だろう．\n実数への変換は，std::stod, std::stold を使う．\ndouble stod( const string\u0026amp; str, size_t* pos = 0 ); long double stold( const string\u0026amp; str, size_t* pos = 0 ); 数値→文字列 std::to_string を用いる．\nstring to_string( int value ); string to_string( long long value ); string to_string( unsigned value ); string to_string( unsigned long long value ); string to_string( double value ); string to_string( long double value ); 16進表記文字列にしたいとか 8進にしたいとかいう場合には， 1つの関数を適用して終わりというわけにはいかないように思う． 次のような感じだろう．\nll value = 256; stringstream ss; ss \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; value; string s = ss.str(); // s == \u0026#34;100\u0026#34; 8進にするときには hex の代わりに oct を用いる．\n2進の場合はbitsetを用いる． 下の例では，value2 の2進表現が長さ8の文字列になる．\nll value2 = 30; string s2 = bitset\u0026lt;8\u0026gt;(value2).to_string(); // s2 == \u0026#34;00011110\u0026#34; 実数→整数 普通にキャストすれば良い場合も多いが，いろいろ罠がある．\ndouble d = -26.001; ll x = ll(d + 0.5); // x == -25 (!!) これは，dが負の場合には意図したようには動作しない． 0に向かって丸められてしまうからである． 次を用いる．\ndouble d = -26.001; ll x = llround(d); // x == -26 round関数などのsignature は以下のようになっている．\ndouble round ( double arg ); long double roundl( long double arg ); long lround ( double arg ); long lroundl( long double arg ); long long llround ( double arg ); long long llroundl( long double arg ); 定数の 1,000,000,007 などを書くのが面倒で，\nconst ll mod = 1e9 + 7; などと書いてしまうことがある．上の例は意図したように動くようであるが，\nconst ll big1 = 1e18; const ll big2 = 1e18 + 1; については，big1 も big2 も 同じ値になってしまう． (gccの場合) double の精度は十進で15桁くらい，long double は18桁くらいである．\n","permalink":"https://yamate11.github.io/blog/posts/2021/02-07-int-string-trans/","summary":"C++ での型の変換などのいろいろな変換方法です．","title":"文字列，数値変換"},{"content":"経緯 よく考えればもちろん作れるのだけれど，すぐ間違うのでメモをしておきます．\n公式 $d \\in \\mathbb{Z}$，$t \\in \\mathbb{R}$ とする．\n $d \\leq t \\iff d \\leq \\lfloor t \\rfloor$ $d \u0026lt; t \\iff d \u0026lt; \\lceil t \\rceil$ $t \\leq d \\iff \\lceil t \\rceil \\leq d$ $t \u0026lt; d \\iff \\lfloor t \\rfloor \u0026lt; d$  考え方 \\begin{eqnarray*} d\\leq t \u0026amp;\\iff\u0026amp; t \\in \\{ t \\mid d \\leq t \\} \\\\\n\u0026amp;\\iff\u0026amp; t \\in \\bigcup \\{ [e, e+1) \\mid e = d, d+1, \\ldots \\} \\\\\n\u0026amp;\\iff\u0026amp; \\bigvee \\{ t \\in [e, e+1) \\mid e = d, d+1, \\ldots \\} \\\\\n\u0026amp;\\iff\u0026amp; \\bigvee \\{ \\lfloor t \\rfloor = e \\mid e = d, d+1, \\ldots \\} \\\\\n\u0026amp;\\iff\u0026amp; d \\leq \\lfloor t \\rfloor \\hspace{20em} \\end{eqnarray*}\n同様に，\n\\begin{eqnarray*} d\u0026lt;t \u0026amp;\\iff\u0026amp; t \\in \\{ t \\mid d \u0026lt; t \\} \\\\\n\u0026amp;\\iff\u0026amp; \\bigvee \\{ t \\in (e-1, e] \\mid e = d+1, d+2, \\ldots \\} \\\\\n\u0026amp;\\iff\u0026amp; \\bigvee \\{ \\lceil t \\rceil = e \\mid e = d+1, d+2, \\ldots \\} \\\\\n\u0026amp;\\iff\u0026amp; d \u0026lt; \\lceil t \\rceil \\hspace{20em} \\end{eqnarray*}\n\\begin{eqnarray*} t \\leq d \u0026amp;\\iff\u0026amp; \\bigvee \\{ t \\in (e-1, e] \\mid e = d, d - 1, \\ldots \\} \\\\\n\u0026amp;\\iff\u0026amp; \\bigvee \\{ \\lceil t \\rceil = e \\mid e = d, d - 1, \\ldots \\} \\\\\n\u0026amp;\\iff\u0026amp; \\lceil t \\rceil \\leq d \\hspace{20em} \\end{eqnarray*}\n\\begin{eqnarray*} t \u0026lt; d \u0026amp;\\iff\u0026amp; \\bigvee \\{ t \\in [e, e+1) \\mid e = d - 1, d - 2, \\ldots \\} \\\\\n\u0026amp;\\iff\u0026amp; \\bigvee \\{ \\lfloor t \\rfloor = e \\mid e = d - 1, d - 2, \\ldots \\} \\\\\n\u0026amp;\\iff\u0026amp; \\lfloor t \\rfloor \u0026lt; d \\hspace{20em} \\end{eqnarray*}\n","permalink":"https://yamate11.github.io/blog/posts/2021/02-13-int-inequality-floor/","summary":"経緯 よく考えればもちろん作れるのだけれど，すぐ間違うのでメモをしておきます．\n公式 $d \\in \\mathbb{Z}$，$t \\in \\mathbb{R}$ とする．\n $d \\leq t \\iff d \\leq \\lfloor t \\rfloor$ $d \u0026lt; t \\iff d \u0026lt; \\lceil t \\rceil$ $t \\leq d \\iff \\lceil t \\rceil \\leq d$ $t \u0026lt; d \\iff \\lfloor t \\rfloor \u0026lt; d$  考え方 \\begin{eqnarray*} d\\leq t \u0026amp;\\iff\u0026amp; t \\in \\{ t \\mid d \\leq t \\} \\\\\n\u0026amp;\\iff\u0026amp; t \\in \\bigcup \\{ [e, e+1) \\mid e = d, d+1, \\ldots \\} \\\\","title":"整数・実数の大小比較とfloor, ceil"},{"content":"Atcoder Regular Contest 104 (ARC 104) E Random LIS に関する記事です．\n問題文へのリンク https://atcoder.jp/contests/arc104/tasks/arc104_e 経緯 過去問埋めで解いてみようとしましたが，全然わかりませんでした． 公式解説 を読んでもやっぱりわからず， けんちょんさんの解説 を読んで，なんとか理解することができました．\n解法 例えば，N = 4 として，数列 10 7 10 15 と数列 5 1 5 2000 は， 数値の差こそあれ，大小関係は同一である．これらを 1 0 1 2 というパターンとして 1つのグループとしてまとめることにする．以下を実行する．\n 全パターンを列挙する． 各パターンについて，  LISの長さを求める． そのパターンに属する数列の数を数える．    グループがいくつあるかは， Ordered Bell number として知られているということである．N = 6 の場合には，4683個． 丁寧に列挙することもできるであろうが，$6^6 = 46656$ であるから，0 から N-1 までの 数の N 個の並びから，不適なものを弾いても十分速い． 各グループに属する数列では，LIS の長さは同じであり，N \u0026lt;= 6 だからこれを求めるのは容易である． 各グループに属する数列の数を求めるのが主要なタスクとなる．\n$\\{0, 1\\} \\cup \\{A_i + 1\\mid i = 1, \\ldots, N\\}$ を昇順にソートして $p_0, p_1, .., p_M$ とし，$P_i$ を整数の半開区間 $[p_i, p_{i+1})$ とする．\nパターンを1つとる．パターン中に現れる数が $0, 1, \\ldots, D-1$ だとする． 各 $d \\in [0, D)$ について，これが現れる位置を $q_1, \\ldots, q_k$ としたとき，$\\min(A_{q_1}, \\ldots, A_{q_k})$ を $B_d$ とする． たとえば，パターン 2 2 2 0 1 1 については，$B_0 = A_3$, $B_1 = \\min(A_4, A_5)$, $B_2 = \\min(A_0, A_1, A_2)$ である． すると，パターンに属する数列の数は，数列 $( x_d | d \\in [0, D) )$ であって $x_d \\in [1, B_d + 1)$ を満たすものの数に等しいので，これを数えることにする．\n動的計画法による． 「長さ i の列 $( x_d | d \\in [0, i) )$ で $x_d \\in [1, B_d + 1)$ を満たし，$ x_{i-1} \\in P_j $ であるもの」の集合を $S_{i,j}$ とし，dp[i][j] を，$S_{i,j}$ の要素の数とする． 普通に dp[i][j] → dp[i+1][j'] の遷移を書こうとすると， j = j' の時にうまくいかない． そこで，次のことに注目する: 長さ i の列 $(x_d \\mid d \\in [0, i) )$ について，次の2つは同値である．\n $( x_d \\mid d \\in [0, i) ) \\in S_{i,j}$ $k \u0026lt; i$, $u \u0026lt; j$ が存在して，以下が成り立つ．  $(x_d \\mid d \\in [0, k) ) \\in S_{k, u}$ 各 $e \\in [k, i)$ に対して，$B_e + 1 \\geq p_{j+1}$ $i - k \\leq p_{j+1} - p_j$    そこで，以下のように遷移を定義することができる:\ndp[i][j] ← dp[k][u] * binom(p[j+1] - p[j], i - k) where * i \u0026gt; k and * j \u0026gt; u and * i - k \u0026lt;= p[j+1] - p[j] and * forall e in [k, i). B[e] + 1 \u0026gt;= p[j+1] ACコード https://atcoder.jp/contests/arc104/submissions/25160111 ","permalink":"https://yamate11.github.io/blog/posts/2021/08-19-random-lis/","summary":"Atcoder Regular Contest 104 (ARC 104) E Random LIS に関する記事です．\n問題文へのリンク https://atcoder.jp/contests/arc104/tasks/arc104_e 経緯 過去問埋めで解いてみようとしましたが，全然わかりませんでした． 公式解説 を読んでもやっぱりわからず， けんちょんさんの解説 を読んで，なんとか理解することができました．\n解法 例えば，N = 4 として，数列 10 7 10 15 と数列 5 1 5 2000 は， 数値の差こそあれ，大小関係は同一である．これらを 1 0 1 2 というパターンとして 1つのグループとしてまとめることにする．以下を実行する．\n 全パターンを列挙する． 各パターンについて，  LISの長さを求める． そのパターンに属する数列の数を数える．    グループがいくつあるかは， Ordered Bell number として知られているということである．N = 6 の場合には，4683個． 丁寧に列挙することもできるであろうが，$6^6 = 46656$ であるから，0 から N-1 までの 数の N 個の並びから，不適なものを弾いても十分速い． 各グループに属する数列では，LIS の長さは同じであり，N \u0026lt;= 6 だからこれを求めるのは容易である． 各グループに属する数列の数を求めるのが主要なタスクとなる．","title":"Random LIS - Atcoder Regular Contest 104 E"},{"content":"筆者の競プロ用のブログです．\n筆者 yamate11\n Twitter: _yamate11  AtCoder: yamate11  CodeForces: yamate11   Powered by Hugo and PaperMod\n","permalink":"https://yamate11.github.io/blog/pages/about/","summary":"筆者の競プロ用のブログです．\n筆者 yamate11\n Twitter: _yamate11  AtCoder: yamate11  CodeForces: yamate11   Powered by Hugo and PaperMod","title":"このサイトについて"},{"content":"発端 自分で書いた SCC (強連結成分分解) ライブラリを使っているのですが， これが，AC-library の SCC に比べて，4倍くらい遅いのです． どこが遅いのか調べてみたら，意外なところにもネックがありました．\n最初は，主に使っているアルゴリズムのせいだと思ったのです． 深さ優先探索を2回行うアルゴリズム (たとえばここ を参照) を使っていました． AC-library は，Tarjan のアルゴリズム を使っているようなので，合わせれば速くなるだろう，と思って 書きかえました．\nたしかに速くなったのですが，それでもまだAC-libraryより3倍ほど遅いです．\nvector\u0026lt;vector\u0026lt;*\u0026gt; \u0026gt; 部分に分けて測定してみたところ，どうも，グラフの情報を設定しているところも 遅い，ということが分かりました． こんな感じのコードなのですが:\nint N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; // N は頂点数, M は辺の数 vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; edges; for (int i = 0; i \u0026lt; M; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; // 0-indexed で入力されると仮定  edeges.emplace_back(u, v); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; fwd(N); // fwd[i] は，i から直接行ける頂点たち． // (1) for (auto [u, v] : edges) { fwd[u].push_back(v); } // (2) この，(1)から(2)までの部分で，結構時間を食っています． Tarjan のアルゴリズムを実行するのと同程度の時間がかかっているように見えました．\nCSR AC-library はそこをどう処理しているのか，と，見てみましたら， CSR なる構造体を使っていました． おそらく， Compressed Sparse Row のことだと思います． すべて1次元のベクトルでの処理になります．\nたとえば，{(0, 5), (0, 7), (1, 4), (2, 3), (2, 8)} を格納する場合には， まず，遷移先の {5, 7, 4, 3, 8} を vector\u0026lt;int\u0026gt; に格納します． それで，別の vector\u0026lt;int\u0026gt; に，{0, 2, 3, 5} を格納します． これは，遷移元が 0 の遷移先は [0, 2) に格納されており， 遷移元が1 の遷移先は [2, 3) に格納されており，遷移元が2の 遷移先は，[3, 5) に格納されている，ということを示しています．\nちょっと上のリンクで説明されているCSRより簡略になっていますが， 考え方は同じだと思います．\n性能比較 ここで，CSR と vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; を使った場合の SCC の性能比較を書くべきところですが， ちょっといろいろあって，まだできていないので， 代わりに木DPで試してみました．\nランダムに作成した木の辺を与えて，各ノードの子孫のノードの数を 数えるというプログラムです． 木のノード数を$2\\times 10^5$ 程度にしてみると，次のようになりました:\n   Sとして何を使うか vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; CSR     標準入力から vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; への読み込み 47ms 47ms (左と同じコード)   vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; から S への変換 48ms 31ms   S を使って子孫ノード数を数える 47ms 14ms    \u0026hellip;. あっと驚くほどには違っていませんね．羊頭狗肉でした．\n性能比較に使ったファイルは こちら です．(gen.py は，データ生成用スクリプト)\n","permalink":"https://yamate11.github.io/blog/posts/2021/08-15-perf-vect-vect/","summary":"発端 自分で書いた SCC (強連結成分分解) ライブラリを使っているのですが， これが，AC-library の SCC に比べて，4倍くらい遅いのです． どこが遅いのか調べてみたら，意外なところにもネックがありました．\n最初は，主に使っているアルゴリズムのせいだと思ったのです． 深さ優先探索を2回行うアルゴリズム (たとえばここ を参照) を使っていました． AC-library は，Tarjan のアルゴリズム を使っているようなので，合わせれば速くなるだろう，と思って 書きかえました．\nたしかに速くなったのですが，それでもまだAC-libraryより3倍ほど遅いです．\nvector\u0026lt;vector\u0026lt;*\u0026gt; \u0026gt; 部分に分けて測定してみたところ，どうも，グラフの情報を設定しているところも 遅い，ということが分かりました． こんな感じのコードなのですが:\nint N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; // N は頂点数, M は辺の数 vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; edges; for (int i = 0; i \u0026lt; M; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; // 0-indexed で入力されると仮定  edeges.emplace_back(u, v); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; fwd(N); // fwd[i] は，i から直接行ける頂点たち． // (1) for (auto [u, v] : edges) { fwd[u].","title":"vector\u003cvector\u003c*\u003e\u003e はあんまり速くない"},{"content":"JOI 2020/2021 二次予選 「イベント巡り (Event Hopping)」 に関する記事です． 公式解説 を読みきれなかったので\u0026hellip;.\n問題へのリンク https://atcoder.jp/contests/joi2021yo2/tasks/joi2021_yo2_c 解法 ちょっと不思議な感じで，小課題3 を (私の感覚では) 自然に解くと， それが満点解法にもなっているという\u0026hellip; (解説を読むまでわからなかったのですけれど)\nソートして，$S_i$ が昇順になっているとします． ナイーブに考えると，次の DP になります．\n dp[i][j] := i番目のイベントに参加する直前までに参加したイベントの 回数が j であるような方法がある (True/False)  遷移としては，dp[i][j] = True となる j について，\n 町 $P_i$ で行われるイベントで，時刻 $S_i + 1$ 以降最も早いものを i1 町 $3 - P_i$ で行われるイベントで， 時刻 $S_i + 1 + D + K(j + 1)$ 以降最も早いものを i2  として，\n dp[i1][j+1] := True dp[i2][j+1] := True  と設定することになります．でも，これは $\\Omega(N^2)$ なので，間に合いません．\n実は，回数を全部見る必要がなくて，各々のイベントに参加するまでに， 最も多くの回数のイベントに参加してきた方法だけ考えれば十分です． ただし，「ある時点までに多くの回数のイベントに参加した方が， 最終的なイベント参加回数が多い」ということは言えません． 次のような例があります．\n $D = 1$, $K = 100$ $S_1 = 1$, $P_1 = 1$ $S_2 = 1000$, $P_2 = 2$ $S_3 = 1150$, $P_3 = 1$ $S_4 = 1151$, $P_4 = 1$  町 1 から出発して イベント 1 に参加した直後に 2 に移る (方法A) と， イベント2 の直前に，今まで参加した回数は 1 です． 一方，町2から出発する (方法B) と，イベント2の直前に， 今まで参加した回数は 0 で，方法Aの方が多いです． しかし，方法B の方は，このあと イベント2, 3, 4 に参加して最終の回数が3回にできますが， 方法Aは，最終的に2回しか参加できません．\nしかし，以下は成り立ちます:\n補題 各イベント $i$ に対し，そのイベントに参加する前に参加できるイベント数の 最大値を $M(i)$ とする． 求める答を $X$ とする． 条件を満たしてイベントに参加していく方法 $e_0, \\ldots, e_{X-1}$ であって， 任意の $j = 0, \\ldots, X-1$ に対して，$M(e_j) = j$ となるものが存在する．\n補題が言えれば，DP として，以下のものをとれます:\n dp[i] := $M(i)$  遷移としては，$dp[i]$ が計算できたらば，上で述べた i1 と i2 を取って，\n dp[i1] := max(dp[i1], dp[i] + 1) dp[i2] := max(dp[i2], dp[i] + 1)  とすれば良いです．(仮想的に，十分遅く行われるN番目のイベントを考えて) dp[N] が求める答となります．このDPは，$O(N\\log N)$ で実行できます．\n補題の証明です．帰謬法によることにして，そのような方法がないとすると， $X$を達成するどの方法についても $M(e_j) \u0026gt; j$ となる $j$ があります． 各方法 $\\alpha$ についてそのような $j$ の最大値を$j_\\alpha$ とし， その最小値を与える $\\alpha$ を取ります． すなわち，$M(e_{j_\\alpha}) \u0026gt; j_\\alpha$ です． イベント $e_{j_\\alpha}$ が行われる町を $p$ として， イベント $e_{j_\\alpha + 1}$ が行われる町を $q$ とすると， $ p \\neq q $ であることに注意します． $M(e_{j_\\alpha})$ を与える方法$\\beta$ をとり， $\\beta$の$j_\\alpha$番目のイベント $e$ までの部分を $\\beta'$ とします． イベント $e$ が $q$ で行われる場合には，$\\beta'$ の後に， $q$ に $e_{j_\\alpha + 1}$ まで残り続けて，その後 $\\alpha$ と 同じに振る舞う方法を $\\gamma$ とします． イベント $e$ が $p$ で行われる場合には，$\\beta'$ の直後に$q$に 移り，その後$e_{j_\\alpha + 1}$ まで $q$ にいて，その後 $\\alpha$ と 同じに振る舞う方法を $\\gamma$ とします． いずれの場合にも，$\\gamma$ は $X$ を達成する方法であり， $j_\\gamma \u0026lt; j_\\alpha$ となり，矛盾しました．\nACコード https://atcoder.jp/contests/joi2021yo2/submissions/25099364 ","permalink":"https://yamate11.github.io/blog/posts/2021/08-16-event-hopping/","summary":"JOI 2020/2021 二次予選 「イベント巡り (Event Hopping)」 に関する記事です． 公式解説 を読みきれなかったので\u0026hellip;.\n問題へのリンク https://atcoder.jp/contests/joi2021yo2/tasks/joi2021_yo2_c 解法 ちょっと不思議な感じで，小課題3 を (私の感覚では) 自然に解くと， それが満点解法にもなっているという\u0026hellip; (解説を読むまでわからなかったのですけれど)\nソートして，$S_i$ が昇順になっているとします． ナイーブに考えると，次の DP になります．\n dp[i][j] := i番目のイベントに参加する直前までに参加したイベントの 回数が j であるような方法がある (True/False)  遷移としては，dp[i][j] = True となる j について，\n 町 $P_i$ で行われるイベントで，時刻 $S_i + 1$ 以降最も早いものを i1 町 $3 - P_i$ で行われるイベントで， 時刻 $S_i + 1 + D + K(j + 1)$ 以降最も早いものを i2  として，\n dp[i1][j+1] := True dp[i2][j+1] := True  と設定することになります．でも，これは $\\Omega(N^2)$ なので，間に合いません．","title":"イベント巡り (Event Hopping) - JOI 2020/2021 二次予選"},{"content":"Atcoder Beginner Contest 213 (ABC-213) H - Stroll の解法です．\n問題へのリンク \r解法 公式解説 を読んでもよくわからなかったのですが， Motsu_xeさんによる，オフライン・オンライン変換 の説明がわかりやすかったです． 以下の説明は，ほとんど，上の2つの記事に依っています．\n記法を定めます．\n $f(x, i) :=$ 地点$x$に距離$i$で到達する方法の数 $p(x, y, i) :=$ 地点 $x$ と地点 $y$ を結ぶ距離 $i$ の道の数 $X := \\{1, \\ldots, N\\}$  したがって，$f(1, T)$ が求める答です．次の関係が成り立ちます:\n $f(1, 0) = 1$ $f(y, 0) = 0\\quad(y \\neq 1)$ $f(x, i) = \\sum \\{ f(y, j) \\cdot p(x, y, i - j) \\mid y \\in X, j \\in [0, i) \\}$  最後の式は，一見，畳み込みですが，右辺にも $f$ が出てきてしまうので， ただちには FFT に渡せません．ここを 分割統治FFTなる手法で求めようという趣旨であるようです．\nさらに記法です．上の最後の式を少しいじります．\n $ s(x, i, l, m) := \\sum \\{ f(y, j) \\cdot p(x, y, i - j) \\mid y \\in X, j \\in [l, m) \\}$  見比べて，次が成り立ちます:\n $ f(x, i) = s(x, i, 0, i) $  DPで，dp[x, i] を計算していきます． 2つの手続き solve(l, r) と induce(l, m, r) を次のように定めます． a:b は，Python風に半開区間 [a,b) を表すものとします． 配列 v に対して，v[a:b] は，vの，添字a以上b未満の部分です．\nprocedure solve(l, r) { assume(forall i \\in [0,l), x \\in X. dp[x, i] == f(x, i)) assume(forall i \\in [l,r), x \\in X. dp[x, i] == s(x, i, 0, l)) if (l + 1 == r) return; m := floor((l + r) / 2); call solve(l, m); call induce(l, m, r); call solve(m, r); assert(forall i \\in [0,r), x \\in X. dp[x, i] == f(x, i)) } procedure induce(l, m, r) { assume(forall i \\in [0,m), x \\in X. dp[x, i] == f(x, i)) assert(forall i \\in [m,r), x \\in X. dp[x, i] == s(x, i, 0, l)) for (x,y such that p[x,y] is non-zero) { v1 = convolution(dp[x][l:m], p[x, y][0:r-l]) dp[y][m:r] += v1[m-l:r-l] v2 = convolution(dp[y][l:m], p[x, y][0:r-l]) dp[x][m:r] += v2[m-l:r-l] } assert(forall i \\in [0,m), x \\in X. dp[x, i] == f(x, i)) assert(forall i \\in [m,r), x \\in X. dp[x, i] == s(x, i, 1, m)) } $f(x, i) = s(x, i, 0, i)$ であることと， assume と assert の主張から， dp[x, i] == s(x, i, 0, g(i)) (for all x \\in X) となる関数 g が， solve と induce によって，以下のように変化することが分かります．\ninduce を実行する際に，dp[.][l:m] が f(.)[l:m] に一致しているので， (オフラインになって) ここに FFT が使える，ということになります．\n以下を実行すると，答が dp[1][T] に求められます．\nfor x in 1:(N+1) { dp[x, 0] := if x == 1 then 1 else 0 } solve(0, T + 1) 計算量については特に付け加えることはないので，参照している記事をご覧下さい．\nACコード https://atcoder.jp/contests/abc213/submissions/24966725 ","permalink":"https://yamate11.github.io/blog/posts/2021/08-11-stroll/","summary":"解けませんでした．オンライン・オフライン変換を調べて書きました．","title":"Stroll - Atcoder Beginner Contest 213 H"},{"content":"距離を求める際の，ダイクストラ, 0-1BFS, BFSのコーディング方法のまとめです．\n記法 ノードを表すデータ型を Node とする． int や long long や pair\u0026lt;int, int\u0026gt; など．\nダイクストラ  前提: ノード間の距離δ(x,y)が全部非負 距離の候補を優先度付きキューに入れていく． あるノードがキューから初めて取り出されたときにそのノードへの距離が確定する． 使用するデータと初期化  priority_queue のメソッドは，push(), emplace(), pop(), top() など．    using P = pair\u0026lt;ll, Node\u0026gt;; // 距離とノード priority_queue\u0026lt;P, vector\u0026lt;P\u0026gt;, greater\u0026lt;P\u0026gt;\u0026gt; pque; // 優先度付きキュー  // 値 (d, x) は，ノードxへ，長さdのパスがあることを示す． pque.emplace(0, initial_node); // 始点をキューに vector\u0026lt;ll\u0026gt; dist(N, LLONG_MAX); // 距離．始点以外は∞  // Node型 によっては，map\u0026lt;Node, ll\u0026gt; dist; など． dist[initial_node] = 0; // 始点の距離は0   ループ\n pque から取り出した (d, x) について，  dist[x] \u0026lt; d なら，もっと良い d があるということなので，単に捨てる． そうでなければこの d が x への最短距離であることが確定したので， 先に進む． x の 隣接ノード y について，newd = x + δ(x, y) が y への距離の候補なので以下を行う．  dist[y] \u0026lt;= newd なら，単に捨てる そうでなければ，先に進む． dist[y] を newd に更新する． (newd, y) を pque に入れる．        ゴール\n キューから取り出した時点で判断する． キューに入れる時点では，後からもっと短いものがくるかもしれない．    0-1 BFS  前提: ノード間の距離 δ(x,y) がどれも 0 または 1． 基本的にはダイクストラの考え方だが， 優先度付きキューの代わりに，両端キューが使える． 使用するデータと初期化  基本的には，ダイクストラと同じ． deque のメソッドは， { push | emplace | pop }_{ back | front }(), back(), front() など．    using P = pair\u0026lt;ll, Node\u0026gt;; // 距離とノード deque\u0026lt;P\u0026gt; deq; // 両端キュー  // 値 (d, x) は，ノードxへ，長さdのパスがあることを示す． deq.emplace_back(0, initial_node); // 始点をキューに vector\u0026lt;ll\u0026gt; dist(N, LLONG_MAX); // 距離．始点以外は∞  // Node型 によっては，map\u0026lt;Node, ll\u0026gt; dist; など． dist[initial_node] = 0; // 始点の距離は0   ループ\n 基本的にはダイクストラと同じ．違うのは，キューに入れるところだけ． deq から取り出した (d, x) について，  dist[x] \u0026lt; d なら，もっと良い d があったということなので， 単に捨てる． そうでなければこの d が x への最短距離であることが確定したので， 先に進む． x の 隣接ノード y について，newd = x + δ(x, y) が y への距離の候補なので以下を行う．  dist[y] \u0026lt;= newd なら，単に捨てる． そうでなければ，先に進む． dist[y] を newd に更新する． (newd, y) を deq に挿入する．  δ(x, y) = 0 なら，deq の左から挿入する． δ(x, y) = 1 なら，deq の右から挿入する．          ゴール\n ダイクストラと同じ．deq から取り出すときに判断する． (δ(x,y) = 0 なら入れるときに確定するが，気にしなくても良いであろう)    BFS  前提: ノード間の距離が全部1 ノードを初めて見たときに距離が確定する． FIFOキューには距離を入れる必要が無く，ノードだけで良い． 使用するデータと初期化  queue のメソッドは，push(), emplace(), pop(), front(), back() など．    queue\u0026lt;Node\u0026gt; que; // FIFOキュー  // キューに入っているノードは，  // 「自分の距離は確定したが，隣接ノードは未処理」のもの que.push(initial_node); // 始点をキューに vector\u0026lt;ll\u0026gt; dist(N, -1); // 距離．始点以外は未確定  // Node型 によっては，map\u0026lt;Node, ll\u0026gt; dist; など． dist[initial_node] = 0; // 始点の距離は0   ループ\n que から取り出したノード x の各隣接ノード y について，  dist[y] \u0026gt;= 0 (すでに距離が確定) の場合は，単に捨てる． 未確定ならば，先に進む． dist[y] に dist[x] + 1 を設定する． y をキューに入れる．      ゴール\n dist[] に値を設定するときに判断する．    ","permalink":"https://yamate11.github.io/blog/posts/2021/07-03-bfs-dijkstra/","summary":"距離を求める際の，ダイクストラ, 0-1BFS, BFSのコーディング方法のまとめです．\n記法 ノードを表すデータ型を Node とする． int や long long や pair\u0026lt;int, int\u0026gt; など．\nダイクストラ  前提: ノード間の距離δ(x,y)が全部非負 距離の候補を優先度付きキューに入れていく． あるノードがキューから初めて取り出されたときにそのノードへの距離が確定する． 使用するデータと初期化  priority_queue のメソッドは，push(), emplace(), pop(), top() など．    using P = pair\u0026lt;ll, Node\u0026gt;; // 距離とノード priority_queue\u0026lt;P, vector\u0026lt;P\u0026gt;, greater\u0026lt;P\u0026gt;\u0026gt; pque; // 優先度付きキュー  // 値 (d, x) は，ノードxへ，長さdのパスがあることを示す． pque.emplace(0, initial_node); // 始点をキューに vector\u0026lt;ll\u0026gt; dist(N, LLONG_MAX); // 距離．始点以外は∞  // Node型 によっては，map\u0026lt;Node, ll\u0026gt; dist; など． dist[initial_node] = 0; // 始点の距離は0   ループ","title":"距離: BFSとダイクストラ"},{"content":"キーエンスプログラミングコンテスト 2021 E - Greedy Ant に関する記事です．\n問題へのリンク https://atcoder.jp/contests/keyence2021/tasks/keyence2021 解法 公式解説 の通りではありますが，若干表現を変えます．\nすぬけ君が，蟻から遠い飴を取っても，蟻の行動には直ちには影響を与えません． そういう状況ではすぬけ君は「スキップ」することにして，後から蟻がその飴に近づいてきたとき (左右いずれかで蟻の最も近い飴になったとき) に取ることにしても，ゲームの意味が変わりません． つまり，次のようにゲームを言い変えることができます． (両端などの扱いはサボっています)\n初期化: // 蟻の初期位置を 2n + 1 とする． l := n // 蟻に最も近い左の飴の位置が 2l r := n + 1 // 蟻に最も近い右の飴の位置が 2r k := 0 // すぬけ君の「スキップ」回数 ループ: k += 1 while k \u0026gt; 0: match すぬけ君の選択(): case なし: break case 左: すぬけ君が 2l の飴を取る; l -= 1 case 右: すぬけ君が 2r の飴を取る; r += 1 k -= 1 蟻が，2l, 2r の飴のおいしい方を取る 取った方に応じて l -= 1 または r += 1 そこで， f(l,r,k) を，「上記 while の先頭位置で，l,r,k がこの値である時に，すぬけ君がこのあと取る得点の最大値」として 定義します． 次の漸化式が書けます．\nf(l, r, k) = max( none(l, r, k) , a[l] + f(l - 1, r, k - 1) , a[r] + f(l, r + 1, k - 1) ) ただし，a[l] \u0026gt; a[r] のとき，none(l, r, k) = f(l - 1, r, k + 1) そうでないとき， none(l, r, k) = f(l, r + 1, k + 1) f(n, n + 1, 1) が求める答です． fは，メモ化再帰で計算でき，時間計算量は O(N^3)です．\n経緯 コンテスト中も解けず，復習でも答を思い出せませんでした．blogに書くことで覚えられるか???\n","permalink":"https://yamate11.github.io/blog/posts/2021/07-22-greedy-ant/","summary":"キーエンスプログラミングコンテスト 2021 E - Greedy Ant に関する記事です．\n問題へのリンク https://atcoder.jp/contests/keyence2021/tasks/keyence2021 解法 公式解説 の通りではありますが，若干表現を変えます．\nすぬけ君が，蟻から遠い飴を取っても，蟻の行動には直ちには影響を与えません． そういう状況ではすぬけ君は「スキップ」することにして，後から蟻がその飴に近づいてきたとき (左右いずれかで蟻の最も近い飴になったとき) に取ることにしても，ゲームの意味が変わりません． つまり，次のようにゲームを言い変えることができます． (両端などの扱いはサボっています)\n初期化: // 蟻の初期位置を 2n + 1 とする． l := n // 蟻に最も近い左の飴の位置が 2l r := n + 1 // 蟻に最も近い右の飴の位置が 2r k := 0 // すぬけ君の「スキップ」回数 ループ: k += 1 while k \u0026gt; 0: match すぬけ君の選択(): case なし: break case 左: すぬけ君が 2l の飴を取る; l -= 1 case 右: すぬけ君が 2r の飴を取る; r += 1 k -= 1 蟻が，2l, 2r の飴のおいしい方を取る 取った方に応じて l -= 1 または r += 1 そこで， f(l,r,k) を，「上記 while の先頭位置で，l,r,k がこの値である時に，すぬけ君がこのあと取る得点の最大値」として 定義します． 次の漸化式が書けます．","title":"Greedy Ant - キーエンスプログラミングコンテスト2021 E"},{"content":"gcc (g++) の policy-based data structure の中にある tree (の競技プログラミングでの利用) に関する記事です．\nリンク  Policy-based Data Structure (GCC online docs) Codeforces admant\u0026#39;s blog   まとめ 以下の操作ができる set や map\n x を指定して，x より小さい要素がいくつあるか数える n を指定して，n 番目に小さい要素へのイテレータを取得する  先頭部分 #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;using namespace __gnu_pbds; 型の定義 例: pair\u0026lt;int, int\u0026gt; の集合 using pair_t = pair\u0026lt;int, int\u0026gt;; using ordered_set = tree\u0026lt; pair_t, null_type, less\u0026lt;pair_t\u0026gt;, rb_tree_tag, tree_order_statistics_node_update \u0026gt;; 例: string から int へのマップ using ordered_map = tree\u0026lt; string, int, less\u0026lt;string\u0026gt;, rb_tree_tag, tree_order_statistics_node_update \u0026gt;; 機能の呼び出し ordered_set os; os.insert(pair_t(0,0)); os.insert(pair_t(1,0)); os.insert(pair_t(1,1)); os.insert(pair_t(2,0)); os.insert(pair_t(2,1)); // order_of_key: 指定した値よりも小さい要素の数  assert(os.order_of_key(pair_t(-1,0)) == 0); assert(os.order_of_key(pair_t(0,0)) == 0); assert(os.order_of_key(pair_t(0,1)) == 1); assert(os.order_of_key(pair_t(1,0)) == 1); assert(os.order_of_key(pair_t(1,1)) == 2); assert(os.order_of_key(pair_t(100,0)) == 5); // find_by_order: 指定した位置の要素へのイテレータ  assert(*os.find_by_order(0) == pair_t(0,0)); assert(*os.find_by_order(2) == pair_t(1,1)); assert(*os.find_by_order(4) == pair_t(2,1)); assert(os.find_by_order(5) == os.end()); 注意  必ずしも速くないらしい．Fenwick tree なり segment tree の倍くらい遅いというレポートがある multiset や multimap に相当する機能はない (リンク )  ","permalink":"https://yamate11.github.io/blog/posts/2021/06-05-policy-based-ds/","summary":"gcc (g++) の policy-based data structure の中にある tree (の競技プログラミングでの利用) に関する記事です．\nリンク  Policy-based Data Structure (GCC online docs) Codeforces admant\u0026#39;s blog   まとめ 以下の操作ができる set や map\n x を指定して，x より小さい要素がいくつあるか数える n を指定して，n 番目に小さい要素へのイテレータを取得する  先頭部分 #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;using namespace __gnu_pbds; 型の定義 例: pair\u0026lt;int, int\u0026gt; の集合 using pair_t = pair\u0026lt;int, int\u0026gt;; using ordered_set = tree\u0026lt; pair_t, null_type, less\u0026lt;pair_t\u0026gt;, rb_tree_tag, tree_order_statistics_node_update \u0026gt;; 例: string から int へのマップ using ordered_map = tree\u0026lt; string, int, less\u0026lt;string\u0026gt;, rb_tree_tag, tree_order_statistics_node_update \u0026gt;; 機能の呼び出し ordered_set os; os.","title":"policy-based data structure の tree"},{"content":"燃やす埋める問題についての記事です．\n動機 燃やす埋める問題については，一度エントリを書いた のですが，そこにはともかく理解したことを全部書いたので，コンテスト中に参照しても把握するのがたいへん，という状況になってしまっています．そこで，コンテスト中に思い出したい最小限のことだけまとめることにしました．\n考え方    問題文中に「$p$ のとき$b$を受け取る」という記載があったら，「先に $b$ を受け取る．$\\neg p$ の時 $b$ を支払う」と読み替えて，すべて支払いをすると考える． グラフ全体の source ノードのラベルは True，sink ノードのラベルは False． ノード $p$ からノード $q$ への矢印に，重み $a$ がついているのは，「$p$が成り立つのに$q$が成り立たない場合，コスト $a$ を支払う」と読む． したがって，この図では，以下が表現されている  $p_8$ は成り立つ． $p_1$ が成り立たなかったら，$a_5$ 支払う． $p_7$ が成り立ったら，$a_3$ 支払う．   最小カットが，コスト最小の真偽割当．図の赤線だと，$p_1, \\ldots, p_6, p_8$ を真，$p_7, p_9$ を偽にする割当に相当し，この場合のコストは$a_2 + a_6$． 連言や選言のノードは，矢印を出せるか入れられるかが決まっている．下図を参照．不可の理由は，たとえば連言なら，$p$, $q$を真に，$p\\land q$ を偽にできてしまうから．(矢印の根本を真にできてしまうと不当な利益がある．矢印の根本を偽にできても嬉しくない)    ","permalink":"https://yamate11.github.io/blog/posts/2021/05-22-burn-bury/","summary":"燃やす埋める問題についての記事です．\n動機 燃やす埋める問題については，一度エントリを書いた のですが，そこにはともかく理解したことを全部書いたので，コンテスト中に参照しても把握するのがたいへん，という状況になってしまっています．そこで，コンテスト中に思い出したい最小限のことだけまとめることにしました．\n考え方    問題文中に「$p$ のとき$b$を受け取る」という記載があったら，「先に $b$ を受け取る．$\\neg p$ の時 $b$ を支払う」と読み替えて，すべて支払いをすると考える． グラフ全体の source ノードのラベルは True，sink ノードのラベルは False． ノード $p$ からノード $q$ への矢印に，重み $a$ がついているのは，「$p$が成り立つのに$q$が成り立たない場合，コスト $a$ を支払う」と読む． したがって，この図では，以下が表現されている  $p_8$ は成り立つ． $p_1$ が成り立たなかったら，$a_5$ 支払う． $p_7$ が成り立ったら，$a_3$ 支払う．   最小カットが，コスト最小の真偽割当．図の赤線だと，$p_1, \\ldots, p_6, p_8$ を真，$p_7, p_9$ を偽にする割当に相当し，この場合のコストは$a_2 + a_6$． 連言や選言のノードは，矢印を出せるか入れられるかが決まっている．下図を参照．不可の理由は，たとえば連言なら，$p$, $q$を真に，$p\\land q$ を偽にできてしまうから．(矢印の根本を真にできてしまうと不当な利益がある．矢印の根本を偽にできても嬉しくない)    ","title":"燃やす埋める問題"},{"content":"きたまさ法に関する記事です． よすぽさんの記事 を参照して書きました．\n問題設定 整数 $ d_0 , \\ldots, d_{ k - 1 }$ と $a_0, \\ldots, a_{k - 1}$ が与えられている． 漸化式 $ a_{n + k} = d_{0} a_{n} + \\cdots + d_{ k - 1 } a_{n + k - 1}$ で定義される数列の $a_n$ を $O( k^2 \\log n )$ で求める．\n行列 $$ A = \\begin{bmatrix} d_{ k - 1 } \u0026amp;\\cdots \u0026amp; \\cdots \u0026amp; d_{ 0 } \\\\\n1 \u0026amp; \u0026amp; \\Large{0} \u0026amp; 0 \\\\\n\u0026amp; \\ddots \u0026amp; \u0026amp; 0\\\\\n\\Large{0} \u0026amp; \u0026amp; 1 \u0026amp; 0 \\\\\n\\end{bmatrix} $$\nとすれば，\n$$ \\begin{bmatrix} a_n \\\\\n\\vdots \\\\\na_{ n - k + 1} \\end{bmatrix} = A^{ n - k + 1 } \\begin{bmatrix} a_{ k - 1 } \\\\\n\\vdots \\\\\na_{ 0 } \\end{bmatrix} $$\nなので，$A^n$ が計算できれば良い．あるいは，$A^n$ の最上行だけでも良い． 計算量が $O( k^2 \\log n)$ で押さえられて欲しいが， 普通の行列累乗だと$O( k^3 \\log n)$ になる．\n計算 $\\newcommand{\\bsww}{\\boldsymbol{w}}$ $\\newcommand{\\bsx}{\\boldsymbol{x}}$ $\\newcommand{\\bsy}{\\boldsymbol{y}}$ $\\newcommand{\\bsdd}{\\boldsymbol{d}}$ $\\bsy_i$ たちを行ベクトルとする．$\\bsdd = [d_{ k - 1 }, \\ldots, d_0]$ とする． また，$\\text{sft}([z_0, \\ldots, z_{ k - 1 }]) = [z_1, \\ldots, z_{ k - 1 }, 0]$ とする． 計算することによって以下がわかる:\n$$ A \\left[ \\begin{array}{c} \\bsy_1 \\\\ \\bsy_2 \\\\ \\vdots \\\\ \\bsy_k \\end{array}\\right] = \\left[ \\begin{array}{c} * \\\\ \\bsy_1 \\\\ \\vdots \\\\ \\bsy_{ k - 1 } \\end{array}\\right] ,\\quad \\left[\\begin{array}{c} \\bsy_1 \\\\ \\vdots \\\\ \\bsy_k \\end{array}\\right] A = \\left[\\begin{array}{c} y_{11}\\bsdd + \\text{sft}( \\bsy_{1} ) \\\\\n\\vdots \\\\\ny_{k1}\\bsdd + \\text{sft}( \\bsy_{k} ) \\\\\n\\end{array}\\right] \\tag{1}$$\nしたがって，$ A^n $ の最下行の行ベクトルを $\\bsx(n)$ と書くと，以下が成り立つ:\n$$ A^n = \\left[\\begin{array}{c} \\bsx( n + k - 1) \\\\\n\\vdots \\\\\n\\bsx( n ) \\\\\n\\end{array}\\right] \\tag{2} $$\n(1)の右の式より， $\\bsx(n)$ の第1成分を $x$ とすると， $$ \\bsx (n + 1) = x \\bsdd + \\text{sft}( \\bsx(n) ) \\tag{3}$$ であることが分かる． また，$A^n$ の列ベクトルを $\\bsww_1^T, \\ldots, \\bsww_k^T$ とし，\n$$ \\left[\\begin{array}{c} \\bsx(2n + k - 1) \\\\\n\\vdots \\\\\n\\bsx(2n) \\\\\n\\end{array}\\right] = A^{2n} = (A^{n})^{2} = \\left[\\begin{array}{c} \\bsx(n + k - 1) \\\\\n\\vdots \\\\\n\\bsx(n) \\\\\n\\end{array}\\right] \\left[\\begin{array}{c} ~ \\\\\n\\bsww_1^T \u0026amp; \\cdots \u0026amp; \\bsww_k^T \\\\\n~ \\\\\n\\end{array}\\right] $$\nと書いて，最下行を比較すると，\n$$ \\bsx(2n) = [ \\bsx(n)\\cdot \\bsww_1, \\ldots, \\bsx(n)\\cdot \\bsww_k ] \\tag{4}$$\nである．\n以上より，次の手順で $a_n$ を計算することができる．\n $a_n = \\bsx(n - k + 1 + k - 1) \\cdot [a_{ k - 1 }, \\cdots, a_{ 0 }]$ なので，$\\bsx(n)$ が求められれば良い． $n$ を，「$+1$」 と 「$\\times 2$」 で書く．たとえば，$n = 18$ なら，$n = ((1 \\times 2 \\times 2 \\times 2) + 1) \\times 2$． この内側から順に $\\bsx(n)$ を求めていく． $+1$ のときには，(3) を適用する．この計算量は，$O(k)$ $\\times 2$ のときには，まず (3) を $k - 1$ 回適用して，$\\bsx(n), \\ldots, \\bsx(n + k - 1)$ を求める． すると(2) より $A^{n}$ が決まるので，(4) の右辺が計算できる．この計算量は，$O(k^2)$  ","permalink":"https://yamate11.github.io/blog/posts/2021/04-30-kitamasa/","summary":"きたまさ法に関する記事です． よすぽさんの記事 を参照して書きました．\n問題設定 整数 $ d_0 , \\ldots, d_{ k - 1 }$ と $a_0, \\ldots, a_{k - 1}$ が与えられている． 漸化式 $ a_{n + k} = d_{0} a_{n} + \\cdots + d_{ k - 1 } a_{n + k - 1}$ で定義される数列の $a_n$ を $O( k^2 \\log n )$ で求める．\n行列 $$ A = \\begin{bmatrix} d_{ k - 1 } \u0026amp;\\cdots \u0026amp; \\cdots \u0026amp; d_{ 0 } \\\\\n1 \u0026amp; \u0026amp; \\Large{0} \u0026amp; 0 \\\\","title":"きたまさ法"},{"content":"二項係数 binom(n, r) を，小さい素数 p に対して mod p で求める方法に関する記事です．\n観察 p = 3 に関していくつか書いてみると次のようになっている．\n0 1 1 1 1 2 1 2 1 10 1 0 0 1 11 1 1 0 1 1 12 1 2 1 1 2 1 20 1 0 0 2 0 0 1 21 1 1 0 2 2 0 1 1 22 1 2 1 2 1 2 1 2 1 100 1 0 0 0 0 0 0 0 0 1 101 1 1 0 0 0 0 0 0 0 1 1 102 1 2 1 0 0 0 0 0 0 1 2 1 110 1 0 0 1 0 0 0 0 0 1 0 0 1 111 1 1 0 1 1 0 0 0 0 1 1 0 1 1 112 1 2 1 1 2 1 0 0 0 1 2 1 1 2 1 120 1 0 0 2 0 0 1 0 0 1 0 0 2 0 0 1 こんな感じの構造になっている:\n  例: p = 3 例として $p = 3$ の場合には， 上の図から，以下のように計算できる．ただし，$q \u0026lt; 3^k$．\n$$ \\begin{eqnarray} % \\binom00 \u0026amp;=\u0026amp; 1 \\\\\n% \\binom{3^k + q}{r} \u0026amp;=\u0026amp; \\begin{cases} \\displaystyle{\\binom{q}{r}} \u0026amp; \\text{if }\\; 0 \\leq r \\leq q \\\\\n\\displaystyle{\\binom{q}{r - 3^k}} \u0026amp; \\text{if }\\; 3^k \\leq r \\\\\n0 \u0026amp; \\text{if }\\; q \u0026lt; r \u0026lt; 3^k \\\\\n\\end{cases} \\\\\n% \\binom{2\\cdot 3^k + q}{r} \u0026amp;=\u0026amp; \\begin{cases} \\displaystyle{\\binom{q}{r}} \u0026amp; \\text{if }\\; 0 \\leq r \\leq q \\\\\n\\displaystyle{2\\binom{q}{r - 3^k}} \u0026amp; \\text{if }\\; 3^k \\leq r \\leq 2\\cdot 3^k + q \\\\\n\\displaystyle{\\binom{q}{r - 2\\cdot 3^k}} \u0026amp; \\text{if }\\; 2\\cdot 3^k \\leq r \\\\\n0 \u0026amp; \\text{if }\\; q \u0026lt; r \u0026lt; 3^k,\\; 3^k + q \u0026lt; r \u0026lt; 2\\cdot 3^k \\\\\n\\end{cases} \\\\\n% \\end{eqnarray} $$\n列 $s(n) := [\\binom{n}{r} \\mid 0 \\leq r \\leq n]$ が必要ならば，以下のように計算できる． $$ \\begin{eqnarray} s(0) \u0026amp;=\u0026amp; [1] \\\\\ns(3^k + q) \u0026amp;=\u0026amp; s(q) ⧺ z ⧺ s(q) \\\\\ns(2\\cdot 3^k + q) \u0026amp;=\u0026amp; s(q) ⧺ z ⧺ 2 \\cdot s(q) ⧺ z ⧺ s(q) \\end{eqnarray} $$ ただし，$z$ は，$0$ を $3^k - q - 1$ 個並べた列．\nbinom(n, r) 一般に，小さい素数$p$ に対しては，以下のようになる．\n$n = c\\cdot p^k + q$，$1 \\leq c \u0026lt; p$，$q \u0026lt; p^k$，$r = d\\cdot p^k + t$，$0 \\leq d \u0026lt; p$，$t \u0026lt; p^k$ とすると，\n$$ \\begin{eqnarray} \\binom{0}{0} \u0026amp;=\u0026amp; 1 \\\\\n\\binom{n}{r} = \\binom{c\\cdot p^k + q}{d\\cdot p^k + t} \u0026amp;=\u0026amp; \\begin{cases} \\displaystyle{\\binom{c}{d}\\binom{q}{t}} \u0026amp; \\text{if }\\; 0 \\leq t \\leq q \\\\\n0 \u0026amp; \\text{if }\\; q \u0026lt; t \\\\\n\\end{cases} \\\\\n\\end{eqnarray} $$\n$\\binom{n}{r}$ の時間計算量は $O(\\log n)$．\n列 $s(n) := [\\binom{n}{r} \\mid 0 \\leq r \\leq n]$ が必要ならば，以下のように計算できる． 記号は上と同様． $$ \\newcommand{\\mybinom}[2]{\\displaystyle{\\binom{#1}{#2}}} \\begin{eqnarray} s(0) \u0026amp;=\u0026amp; [1] \\\\\ns(n) = s(c\\cdot p^k + q) \u0026amp;=\u0026amp; \\mybinom{c}{0}s(q) ⧺ z ⧺ \\mybinom{c}{1}s(q) ⧺ z ⧺ \\cdots ⧺ \\mybinom{c}{c}s(q) \\\\\n\\end{eqnarray} $$ $z$は，$0$ を $p^k - q - 1$ 個並べた列． $s(n)$ の時間計算量は $O(n)$．\nAtCoder AtCoder ARC117 C - Tricolor Pyramid で，上の手順が使える．ただし，解説 の方法の方が思いつきやすいし，(列を求めるだけだから) 計算量は同じ．\n","permalink":"https://yamate11.github.io/blog/posts/2021/04-27-binom-mod/","summary":"二項係数 binom(n, r) を，小さい素数 p に対して mod p で求める方法に関する記事です．\n観察 p = 3 に関していくつか書いてみると次のようになっている．\n0 1 1 1 1 2 1 2 1 10 1 0 0 1 11 1 1 0 1 1 12 1 2 1 1 2 1 20 1 0 0 2 0 0 1 21 1 1 0 2 2 0 1 1 22 1 2 1 2 1 2 1 2 1 100 1 0 0 0 0 0 0 0 0 1 101 1 1 0 0 0 0 0 0 0 1 1 102 1 2 1 0 0 0 0 0 0 1 2 1 110 1 0 0 1 0 0 0 0 0 1 0 0 1 111 1 1 0 1 1 0 0 0 0 1 1 0 1 1 112 1 2 1 1 2 1 0 0 0 1 2 1 1 2 1 120 1 0 0 2 0 0 1 0 0 1 0 0 2 0 0 1 こんな感じの構造になっている:","title":"binom(n, r) を小さい素数pに対して mod p で求める"},{"content":"Lagrange補間に関する記事です．\n要約 $$ f(x) = \\sum_{i = 0}^{k}\\frac{ f(i) }{ (-1)^{k - i} \\; i ! \\; (k - i) ! } \\cdot \\frac{ 1 }{ x - i } \\cdot \\prod_{j=0}^{k} ( x - j ) $$\n詳細 \\( k \\) 次多項式 $f(x)$ について，$x = 0, \\ldots, k$ の値が，$f(0) = v_0, \\ldots, f(k) = v_k$ と分かっているときに， $f(x)$ (の各係数) を決める方法． 連立方程式を解く方法だと，逆行列を計算する必要があるから，\\( \\Omega( k^3 ) \\) になってしまうが， Lagrange補間だと，$O(k^2)$ で済む．\n$I = \\{0, \\ldots, k\\}$, $I_i = I \\setminus \\{ i \\}$ とする．$i = 0, \\ldots, k$ について，$k$ 次の多項式 $g_i(x)$ を， 次で定義する．\n$$g_i(x) = \\frac{ \\prod \\{ x - j \\mid j \\in I_i \\} }{ \\prod \\{ i - j \\mid j \\in I_i \\} } $$\n$j = 0, \\ldots, k$ について，\n$$ g_i (j) = \\begin{cases} 1 \u0026amp; \\text{ if } i =j \\\\\n0 \u0026amp; \\text{ if } i \\neq j \\end{cases}$$\nであることに注意すると，\n$$ f(x) = \\sum_{i = 0}^{k} g_i(x)v_i $$\nとなることがわかる (左右両辺とも $k$ 次多項式で，$k+1$ 個の値が一致する)．\n$ g_i(x) $ の分母を $c_i$ と書くと，\n$$ c_i = (-1)^{k - i} \\; i ! \\; (k - i) ! $$\nであるから，これらは，事前に $k$ までの階乗を $O(k)$ で計算しておけば，$O(1)$ で求められる．\n$g_i(x)$ の分子は，\n$$ \\frac{1}{x - i}\\cdot\\prod_{j=0}^{k} (x-j) $$\nであるから，まず $\\prod_{j=0}^{k} (x-j)$ を $O(k^2)$ で計算しておけば，各$i$について$O(k)$で，全体で$O(k^2)$で 計算できる．\nAtCoder AtCoder ABC137 F - Polynomial Construction は， Lagrange補間を用いて解ける． ただし，解説 に書かれている方法の方が簡単．\n","permalink":"https://yamate11.github.io/blog/posts/2021/04-22-lagrange/","summary":"Lagrange補間に関する記事です．\n要約 $$ f(x) = \\sum_{i = 0}^{k}\\frac{ f(i) }{ (-1)^{k - i} \\; i ! \\; (k - i) ! } \\cdot \\frac{ 1 }{ x - i } \\cdot \\prod_{j=0}^{k} ( x - j ) $$\n詳細 \\( k \\) 次多項式 $f(x)$ について，$x = 0, \\ldots, k$ の値が，$f(0) = v_0, \\ldots, f(k) = v_k$ と分かっているときに， $f(x)$ (の各係数) を決める方法． 連立方程式を解く方法だと，逆行列を計算する必要があるから，\\( \\Omega( k^3 ) \\) になってしまうが， Lagrange補間だと，$O(k^2)$ で済む．\n$I = \\{0, \\ldots, k\\}$, $I_i = I \\setminus \\{ i \\}$ とする．$i = 0, \\ldots, k$ について，$k$ 次の多項式 $g_i(x)$ を， 次で定義する．","title":"Lagrange補間"},{"content":"行列木定理についての記事です． これを使う問題が，第二回日本最強プログラマー学生選手権 の G - Spanning Tree として出題されました．\n定理 自己ループのない無向グラフ $G$ がある．頂点を $1, \\ldots, N$ とする． 対称 $N\\times N$ 行列 $A = (a_{ij})$ を，次で定める:\n $a_{ii} = $ 頂点$i$の出次数 $a_{ij} = - ( i \\text{と} j \\text{を結ぶ辺の数} )$  このとき，A のすべての余因子は等しく，G の全域木の数と一致する．\n例   上のグラフでは，\n$$ A = \\begin{bmatrix} 3 \u0026amp; -1 \u0026amp; 0 \u0026amp; -2 \\\\\n-1 \u0026amp; 3 \u0026amp; -1 \u0026amp; -1 \\\\\n0 \u0026amp; -1 \u0026amp; 2 \u0026amp; -1 \\\\\n-2 \u0026amp; -1 \u0026amp; -1 \u0026amp; 4 \\end{bmatrix} $$\n$(4,4)-$余因子行列は\n$$ M_{4,4} = \\begin{bmatrix} 3 \u0026amp; -1 \u0026amp; 0 \\\\\n-1 \u0026amp; 3 \u0026amp; -1 \\\\\n0 \u0026amp; -1 \u0026amp; 2\n\\end{bmatrix} $$\nこの行列式の値 13 が，グラフの全域木の数である．\n","permalink":"https://yamate11.github.io/blog/posts/2021/04-18-kirchhoff/","summary":"行列木定理についての記事です． これを使う問題が，第二回日本最強プログラマー学生選手権 の G - Spanning Tree として出題されました．\n定理 自己ループのない無向グラフ $G$ がある．頂点を $1, \\ldots, N$ とする． 対称 $N\\times N$ 行列 $A = (a_{ij})$ を，次で定める:\n $a_{ii} = $ 頂点$i$の出次数 $a_{ij} = - ( i \\text{と} j \\text{を結ぶ辺の数} )$  このとき，A のすべての余因子は等しく，G の全域木の数と一致する．\n例   上のグラフでは，\n$$ A = \\begin{bmatrix} 3 \u0026amp; -1 \u0026amp; 0 \u0026amp; -2 \\\\\n-1 \u0026amp; 3 \u0026amp; -1 \u0026amp; -1 \\\\\n0 \u0026amp; -1 \u0026amp; 2 \u0026amp; -1 \\\\","title":"行列木定理"},{"content":"CodeForces Round #431 (Div.2) E - Goodbye Souvenir についての記事です．\n問題へのリンク https://codeforces.com/contest/849/problem/E 経緯 Yoika さんが主催している Morningforces というバーチャルコンテスト で出て，解けませんでした． 公式解説 を読んだのですが，最後に出てくる座標圧縮云々がよく分かりませんでした．\n問題概要 整数列 $a = a_1, \\ldots, a_k $ に対して，$m(a)$ を，$a$ に現れる各数 $x$ に対して，$x$ が最後に現れる位置と最初に現れる位置との差の総和として定義する．例えば，$m(1, 2, 3, 1, 3, 2, 1) = (7-1) + (6-2) + (5- 3) = 12$．最初に長さ n の整数列 a が与えられる．各要素は1以上n以下．次の2種類のクエリ (全部で$m$個) を処理せよ．$ 1 \\leq n, m \\leq 100,000$．\n p, x が与えられて，aのp番目の要素をxに書き換える． l, r が与えられて，$ m(a[l:r]) $ を求める．  解法 ということで，実装手段を除いては公式解説をなぞっています．\n$x$ が出てくる位置を $p_1, \\ldots, p_k$ と書くと，$x$ による寄与は $ (p_2 - p_1) + \\cdots + ( p_k - p_{ k - 1 } ) $ である． ある数が位置 s に現れ，次には位置 t に現れるという状況の時，2次元平面内の 点 $(t, s)$ に値 $ t - s $ を割り振ることにする． すると，位置 p から q までの a の部分列での値は，2次元平面内の長方形 $ [ p, q + 1) \\times [p, n + 1) $ に割り振られた値の総和に等しい．\nつまり，長方形 $ [1, n + 1) \\times [1, n + 1) $ に対して，以下の操作が高速に行えれば良い．\n 1点に値を割り振る． 部分長方形に割り振られた値の総和を求める．  セグメント木と同じ考え方でできる． 通常のセグメント木は1次元で区間を2分割していくが， 2次元になっても，長方形を4分割することにすれば原理は同じ． ただし，最初に全部のセルを作ろうとすると $ \\Omega ( n^2 )$ 必要なので間に合わない． そこで，ノードは必要になったときだけ生成する． 下のコードを見れば， 普通のセグメント木と同じように書けることが分かると思う． どちらのクエリも $O(\\log n)$ で処理できるので， 全体で計算量は $ O(m\\log n) $ となる．\nACコード https://codeforces.com/contest/849/submission/104679665 ","permalink":"https://yamate11.github.io/blog/posts/2021/01-18-goodbye-souvenir/","summary":"CodeForces Round #431 (Div.2) E - Goodbye Souvenir についての記事です．\n問題へのリンク https://codeforces.com/contest/849/problem/E 経緯 Yoika さんが主催している Morningforces というバーチャルコンテスト で出て，解けませんでした． 公式解説 を読んだのですが，最後に出てくる座標圧縮云々がよく分かりませんでした．\n問題概要 整数列 $a = a_1, \\ldots, a_k $ に対して，$m(a)$ を，$a$ に現れる各数 $x$ に対して，$x$ が最後に現れる位置と最初に現れる位置との差の総和として定義する．例えば，$m(1, 2, 3, 1, 3, 2, 1) = (7-1) + (6-2) + (5- 3) = 12$．最初に長さ n の整数列 a が与えられる．各要素は1以上n以下．次の2種類のクエリ (全部で$m$個) を処理せよ．$ 1 \\leq n, m \\leq 100,000$．\n p, x が与えられて，aのp番目の要素をxに書き換える． l, r が与えられて，$ m(a[l:r]) $ を求める．  解法 ということで，実装手段を除いては公式解説をなぞっています．","title":"CodeForces Round #431 (Div.2) E - Goodbye Souvenir"},{"content":"C++ での乱数の使い方のメモです．\n典型的なコード ll n; cin \u0026gt;\u0026gt; n; random_device rand_dev; mt19937 rng(rand_dev()); uniform_int_distribution\u0026lt;ll\u0026gt; dist(1, n); for (ll i = 0; i \u0026lt; 10; i++) cout \u0026lt;\u0026lt; dist(rng) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; クラス random_device  マニュアル  オブジェクトは乱数発生器．non-deterministic な乱数を生成する． operator() を実行すると，unsigned int の乱数が返り，状態が進む． 実行は高価である可能性がある．  クラス mt19937  マニュアル  32bitメルセンヌツィッター乱数発生器 64bitメルセンヌツィッター乱数発生器 の mt19937_64 というクラスもある． o.operator() を実行すると，uint_fast32_t の乱数が返り，状態が進む． コンストラクタに seed を渡す． デフォルトコンストラクタは引数をとらず，seed = 5489u を用いる．したがって，次のように書けば，どの実行でも同じ値が生成される．  mt19937 rng; クラス uniform_int_distribution  マニュアル  乱数分布を一様分布とする．constructor に a, b を指定すると，a以上b以下の一様分布． T は int や ll など．デフォルトは int． operator() は，引数に乱数発生器を取り，一様分布を生成する． 他の乱数分布クラスとコンストラクタの例:  uniform_real_distribution\u0026lt;double\u0026gt; dist1(a, b); normal_distribution\u0026lt;double\u0026gt; dist2(mean, stddev); ","permalink":"https://yamate11.github.io/blog/posts/2021/01-13-random/","summary":"C++ での乱数の使い方のメモです．\n典型的なコード ll n; cin \u0026gt;\u0026gt; n; random_device rand_dev; mt19937 rng(rand_dev()); uniform_int_distribution\u0026lt;ll\u0026gt; dist(1, n); for (ll i = 0; i \u0026lt; 10; i++) cout \u0026lt;\u0026lt; dist(rng) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; クラス random_device  マニュアル  オブジェクトは乱数発生器．non-deterministic な乱数を生成する． operator() を実行すると，unsigned int の乱数が返り，状態が進む． 実行は高価である可能性がある．  クラス mt19937  マニュアル  32bitメルセンヌツィッター乱数発生器 64bitメルセンヌツィッター乱数発生器 の mt19937_64 というクラスもある． o.operator() を実行すると，uint_fast32_t の乱数が返り，状態が進む． コンストラクタに seed を渡す． デフォルトコンストラクタは引数をとらず，seed = 5489u を用いる．したがって，次のように書けば，どの実行でも同じ値が生成される．  mt19937 rng; クラス uniform_int_distribution  マニュアル  乱数分布を一様分布とする．constructor に a, b を指定すると，a以上b以下の一様分布． T は int や ll など．デフォルトは int． operator() は，引数に乱数発生器を取り，一様分布を生成する． 他の乱数分布クラスとコンストラクタの例:  uniform_real_distribution\u0026lt;double\u0026gt; dist1(a, b); normal_distribution\u0026lt;double\u0026gt; dist2(mean, stddev); ","title":"乱数の作り方"},{"content":"AtCoder Regular Contest (ARC) 056 D - サケノミ についての記事です．\n問題へのリンク  状況 解けないだけではなく，答を見てもなかなかわからなかったので，整理するために書いています．下記を参考にしています．\n 公式解説  kmjpさんのブログ   解法 時刻 $2j+1$ にドリンクを飲むような飲み方全部に関する，時刻 $2j+1$ 時点での美味しさの総和の最大値を $x(j)$ とする． 時刻 $2i$ に全部のグラスが空だったとき，半開区間 $(2i, 2j]$ に属する時刻に注がれるドリンクの美味しさの総和を $y(i, j)$ とすると， $x(j) = \\max \\{ x(i) + y(i, j) \\mid i \u0026lt; j \\} $ である．ここで，$z(i, j) = x(i) + y(i, j)$ と書くことにする．時刻 $j$ に注がれるドリンク全体の集合を $P$ とし，$ p \\in P $ に対して時刻 $2j$ の一回前にドリンク $p$ が注がれる時刻を $l_p$ とする (時刻 j が初回なら，$l_p = 0$ とする)．すると，次が成り立つ．\n $x(j) = z(j,j) = \\max \\{ z(i,j) \\mid i \u0026lt; j \\}$ $z(i,j) - z(i, j-1) = \\sum \\{ w_p \\mid p \\in P,; i \\in [l_p, j) \\}$  したがって，ベクトル $ v_j = ( z(i,j) \\mid i \u0026lt; j ) $ を $j$ に関して遅延伝搬セグメント木 (区間和，区間最大値) で更新していくことができ，$O(M \\log M)$ (ここに $M = \\sum \\{ M_i \\mid i \\leq N \\}$ )で計算できる．答は最終時刻 $T$ に対する $x(T) = z(T, T)$ である．\nその他 似たような問題を見たことがあるような気がして探してみると，EDPC の W. Intervals とほぼ同じでした．こちらの方が古いですが．何度やっても解けません．\n","permalink":"https://yamate11.github.io/blog/posts/2021/01-06-sakenomi/","summary":"AtCoder Regular Contest (ARC) 056 D - サケノミ についての記事です．\n問題へのリンク  状況 解けないだけではなく，答を見てもなかなかわからなかったので，整理するために書いています．下記を参考にしています．\n 公式解説  kmjpさんのブログ   解法 時刻 $2j+1$ にドリンクを飲むような飲み方全部に関する，時刻 $2j+1$ 時点での美味しさの総和の最大値を $x(j)$ とする． 時刻 $2i$ に全部のグラスが空だったとき，半開区間 $(2i, 2j]$ に属する時刻に注がれるドリンクの美味しさの総和を $y(i, j)$ とすると， $x(j) = \\max \\{ x(i) + y(i, j) \\mid i \u0026lt; j \\} $ である．ここで，$z(i, j) = x(i) + y(i, j)$ と書くことにする．時刻 $j$ に注がれるドリンク全体の集合を $P$ とし，$ p \\in P $ に対して時刻 $2j$ の一回前にドリンク $p$ が注がれる時刻を $l_p$ とする (時刻 j が初回なら，$l_p = 0$ とする)．すると，次が成り立つ．","title":"AtCoder Regular Contest 056 D - サケノミ"}]