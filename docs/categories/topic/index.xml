<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>topic on yamate11のブログ</title>
    <link>https://yamate11.github.io/blog/categories/topic/</link>
    <description>Recent content in topic on yamate11のブログ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 12 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://yamate11.github.io/blog/categories/topic/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>xor畳み込み</title>
      <link>https://yamate11.github.io/blog/posts/2021/08-10-xor-conv/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/08-10-xor-conv/</guid>
      <description>高速アダマール変換によって，xor畳み込みをする方法についての記事 (自分用のメモ) です．
xor畳み込み 長さ $2^K$ の数列 $X$, $Y$ があるとき， これらのxor畳み込みを，以下を満たす長さ $2^K$ の列 $Z$ として定める． ただし，$x \oplus y$ は $x$ と $y$ の xor とする．
 $ Z_k = \sum \{ X_i Y_j \mid i \oplus j = k \} $  以下では，$Z = X * Y$ と書く．
アダマール変換 長さ $2^K$ の数列に作用するアダマール変換は，以下の行列 $H_K$ で定義される 1次変換である．
$$ H_0 = 1 $$
$$ H_{k + 1} = \begin{bmatrix} H_k &amp;amp; H_k \\</description>
    </item>
    
    <item>
      <title>距離: BFSとダイクストラ</title>
      <link>https://yamate11.github.io/blog/posts/2021/07-03-bfs-dijkstra/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/07-03-bfs-dijkstra/</guid>
      <description>距離を求める際の，ダイクストラ, 0-1BFS, BFSのコーディング方法のまとめです．
記法 ノードを表すデータ型を Node とする． int や long long や pair&amp;lt;int, int&amp;gt; など．
ダイクストラ  前提: ノード間の距離δ(x,y)が全部非負 距離の候補を優先度付きキューに入れていく． あるノードがキューから初めて取り出されたときにそのノードへの距離が確定する． 使用するデータと初期化  priority_queue のメソッドは，push(), emplace(), pop(), top() など．    using P = pair&amp;lt;ll, Node&amp;gt;; // 距離とノード priority_queue&amp;lt;P, vector&amp;lt;P&amp;gt;, greater&amp;lt;P&amp;gt;&amp;gt; pque; // 優先度付きキュー  // 値 (d, x) は，ノードxへ，長さdのパスがあることを示す． pque.emplace(0, initial_node); // 始点をキューに vector&amp;lt;ll&amp;gt; dist(N, LLONG_MAX); // 距離．始点以外は∞  // Node型 によっては，map&amp;lt;Node, ll&amp;gt; dist; など． dist[initial_node] = 0; // 始点の距離は0   ループ</description>
    </item>
    
    <item>
      <title>キーエンスプログラミングコンテスト2021 E - Greedy Ant</title>
      <link>https://yamate11.github.io/blog/posts/2021/07-22-greedy-ant/</link>
      <pubDate>Thu, 22 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/07-22-greedy-ant/</guid>
      <description>キーエンスプログラミングコンテスト 2021 E - Greedy Ant に関する記事です．
問題へのリンク https://atcoder.jp/contests/keyence2021/tasks/keyence2021 解法 公式解説 の通りではありますが，若干表現を変えます．
すぬけ君が，蟻から遠い飴を取っても，蟻の行動には直ちには影響を与えません． そういう状況ではすぬけ君は「スキップ」することにして，後から蟻がその飴に近づいてきたとき (左右いずれかで蟻の最も近い飴になったとき) に取ることにしても，ゲームの意味が変わりません． つまり，次のようにゲームを言い変えることができます． (両端などの扱いはサボっています)
初期化: // 蟻の初期位置を 2n + 1 とする． l := n // 蟻に最も近い左の飴の位置が 2l r := n + 1 // 蟻に最も近い右の飴の位置が 2r k := 0 // すぬけ君の「スキップ」回数 ループ: k += 1 while k &amp;gt; 0: match すぬけ君の選択(): case なし: break case 左: すぬけ君が 2l の飴を取る; l -= 1 case 右: すぬけ君が 2r の飴を取る; r += 1 k -= 1 蟻が，2l, 2r の飴のおいしい方を取る 取った方に応じて l -= 1 または r += 1 そこで， f(l,r,k) を，「上記 while の先頭位置で，l,r,k がこの値である時に，すぬけ君がこのあと取る得点の最大値」として 定義します． 次の漸化式が書けます．</description>
    </item>
    
    <item>
      <title>桁DPのコーディング</title>
      <link>https://yamate11.github.io/blog/posts/2021/07-06-digitdp/</link>
      <pubDate>Tue, 06 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/07-06-digitdp/</guid>
      <description>桁DPのコーディングに関する記事です． N 以下の整数である条件を満たすものを数えます．
参照 以下のoptさんの記事 をもとにして，少し追加しています:
コーディングの方針  配るDP 上位桁を 0-padding した状態で考える  有効な桁が始まっているかどうかが必要なこともあるが，その場合にはそれを表すフラグを導入する． 0以上N以下を数えることになるので，必要なら最後に調整．   代入は1回  その桁に表れうる数 (0..9 とか 0..1 とか) をループで回し，「この数を付け加えた時の格納先」を考える 格納先の添字を表す変数を，格納元で初期化して適宜変更する．    // N は各桁数値のベクトルで表現．ds[0] が最上位桁． // もちろん，問題文の都合で string でも良い． // 本来は ds[0] を一の位にして， // ループを ds.size() - 1 から 0 まで回した方が自然かもしれない vector&amp;lt;ll&amp;gt;&amp;amp; ds; // DP表は，最初の次元を上限に等しいかどうかのフラグにする． // 0 ... 上限値． 1 ... 上限値より小さいと確定 auto tbl_init = vector(2, vector(??, vector(??, 0LL))); auto tbl = tbl_init; tbl[0][?</description>
    </item>
    
    <item>
      <title>policy-based data structure の tree</title>
      <link>https://yamate11.github.io/blog/posts/2021/06-05-policy-based-ds/</link>
      <pubDate>Sat, 05 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/06-05-policy-based-ds/</guid>
      <description>gcc (g++) の policy-based data structure の中にある tree (の競技プログラミングでの利用) に関する記事です．
リンク  Policy-based Data Structure (GCC online docs) Codeforces admant&amp;#39;s blog   まとめ 以下の操作ができる set や map
 x を指定して，x より小さい要素がいくつあるか数える n を指定して，n 番目に小さい要素へのイテレータを取得する  先頭部分 #include &amp;lt;ext/pb_ds/assoc_container.hpp&amp;gt;#include &amp;lt;ext/pb_ds/tree_policy.hpp&amp;gt;using namespace __gnu_pbds; 型の定義 例: pair&amp;lt;int, int&amp;gt; の集合 using pair_t = pair&amp;lt;int, int&amp;gt;; using ordered_set = tree&amp;lt; pair_t, null_type, less&amp;lt;pair_t&amp;gt;, rb_tree_tag, tree_order_statistics_node_update &amp;gt;; 例: string から int へのマップ using ordered_map = tree&amp;lt; string, int, less&amp;lt;string&amp;gt;, rb_tree_tag, tree_order_statistics_node_update &amp;gt;; 機能の呼び出し ordered_set os; os.</description>
    </item>
    
    <item>
      <title>燃やす埋める問題</title>
      <link>https://yamate11.github.io/blog/posts/2021/05-22-burn-bury/</link>
      <pubDate>Sat, 22 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/05-22-burn-bury/</guid>
      <description>燃やす埋める問題についての記事です．
動機 燃やす埋める問題については，一度エントリを書いた のですが，そこにはともかく理解したことを全部書いたので，コンテスト中に参照しても把握するのがたいへん，という状況になってしまっています．そこで，コンテスト中に思い出したい最小限のことだけまとめることにしました．
考え方    問題文中に「$p$ のとき$b$を受け取る」という記載があったら，「先に $b$ を受け取る．$\neg p$ の時 $b$ を支払う」と読み替えて，すべて支払いをすると考える． グラフ全体の source ノードのラベルは True，sink ノードのラベルは False． ノード $p$ からノード $q$ への矢印に，重み $a$ がついているのは，「$p$が成り立つのに$q$が成り立たない場合，コスト $a$ を支払う」と読む． したがって，この図では，以下が表現されている  $p_8$ は成り立つ． $p_1$ が成り立たなかったら，$a_5$ 支払う． $p_7$ が成り立ったら，$a_3$ 支払う．   最小カットが，コスト最小の真偽割当．図の赤線だと，$p_1, \ldots, p_6, p_8$ を真，$p_7, p_9$ を偽にする割当に相当し，この場合のコストは$a_2 + a_6$． 連言や選言のノードは，矢印を出せるか入れられるかが決まっている．下図を参照．不可の理由は，たとえば連言なら，$p$, $q$を真に，$p\land q$ を偽にできてしまうから．(矢印の根本を真にできてしまうと不当な利益がある．矢印の根本を偽にできても嬉しくない)    </description>
    </item>
    
    <item>
      <title>きたまさ法</title>
      <link>https://yamate11.github.io/blog/posts/2021/04-30-kitamasa/</link>
      <pubDate>Fri, 30 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/04-30-kitamasa/</guid>
      <description>きたまさ法に関する記事です． よすぽさんの記事 を参照して書きました．
問題設定 整数 $ d_0 , \ldots, d_{ k - 1 }$ と $a_0, \ldots, a_{k - 1}$ が与えられている． 漸化式 $ a_{n + k} = d_{0} a_{n} + \cdots + d_{ k - 1 } a_{n + k - 1}$ で定義される数列の $a_n$ を $O( k^2 \log n )$ で求める．
行列 $$ A = \begin{bmatrix} d_{ k - 1 } &amp;amp;\cdots &amp;amp; \cdots &amp;amp; d_{ 0 } \\
1 &amp;amp; &amp;amp; \Large{0} &amp;amp; 0 \\</description>
    </item>
    
    <item>
      <title>binom(n, r) を小さい素数pに対して mod p で求める</title>
      <link>https://yamate11.github.io/blog/posts/2021/04-27-binom-mod/</link>
      <pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/04-27-binom-mod/</guid>
      <description>二項係数 binom(n, r) を，小さい素数 p に対して mod p で求める方法に関する記事です．
観察 p = 3 に関していくつか書いてみると次のようになっている．
0 1 1 1 1 2 1 2 1 10 1 0 0 1 11 1 1 0 1 1 12 1 2 1 1 2 1 20 1 0 0 2 0 0 1 21 1 1 0 2 2 0 1 1 22 1 2 1 2 1 2 1 2 1 100 1 0 0 0 0 0 0 0 0 1 101 1 1 0 0 0 0 0 0 0 1 1 102 1 2 1 0 0 0 0 0 0 1 2 1 110 1 0 0 1 0 0 0 0 0 1 0 0 1 111 1 1 0 1 1 0 0 0 0 1 1 0 1 1 112 1 2 1 1 2 1 0 0 0 1 2 1 1 2 1 120 1 0 0 2 0 0 1 0 0 1 0 0 2 0 0 1 こんな感じの構造になっている:</description>
    </item>
    
    <item>
      <title>Lagrange補間</title>
      <link>https://yamate11.github.io/blog/posts/2021/04-22-lagrange/</link>
      <pubDate>Thu, 22 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/04-22-lagrange/</guid>
      <description>Lagrange補間に関する記事です．
要約 $$ f(x) = \sum_{i = 0}^{k}\frac{ f(i) }{ (-1)^{k - i} \; i ! \; (k - i) ! } \cdot \frac{ 1 }{ x - i } \cdot \prod_{j=0}^{k} ( x - j ) $$
詳細 \( k \) 次多項式 $f(x)$ について，$x = 0, \ldots, k$ の値が，$f(0) = v_0, \ldots, f(k) = v_k$ と分かっているときに， $f(x)$ (の各係数) を決める方法． 連立方程式を解く方法だと，逆行列を計算する必要があるから，\( \Omega( k^3 ) \) になってしまうが， Lagrange補間だと，$O(k^2)$ で済む．
$I = \{0, \ldots, k\}$, $I_i = I \setminus \{ i \}$ とする．$i = 0, \ldots, k$ について，$k$ 次の多項式 $g_i(x)$ を， 次で定義する．</description>
    </item>
    
    <item>
      <title>行列木定理</title>
      <link>https://yamate11.github.io/blog/posts/2021/04-18-kirchhoff/</link>
      <pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/04-18-kirchhoff/</guid>
      <description>行列木定理についての記事です． これを使う問題が，第二回日本最強プログラマー学生選手権 の G - Spanning Tree として出題されました．
定理 自己ループのない無向グラフ $G$ がある．頂点を $1, \ldots, N$ とする． 対称 $N\times N$ 行列 $A = (a_{ij})$ を，次で定める:
 $a_{ii} = $ 頂点$i$の出次数 $a_{ij} = - ( i \text{と} j \text{を結ぶ辺の数} )$  このとき，A のすべての余因子は等しく，G の全域木の数と一致する．
例   上のグラフでは，
$$ A = \begin{bmatrix} 3 &amp;amp; -1 &amp;amp; 0 &amp;amp; -2 \\
-1 &amp;amp; 3 &amp;amp; -1 &amp;amp; -1 \\
0 &amp;amp; -1 &amp;amp; 2 &amp;amp; -1 \\</description>
    </item>
    
    <item>
      <title>整数・実数の不等号とfloor, ceil</title>
      <link>https://yamate11.github.io/blog/posts/2021/02-13-int-inequality-floor/</link>
      <pubDate>Sat, 13 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/02-13-int-inequality-floor/</guid>
      <description>経緯 よく考えればもちろん作れるのだけれど，すぐ間違うのでメモをしておきます．
公式 $d \in \mathbb{Z}$，$t \in \mathbb{R}$ とする．
 $d &amp;lt; t \iff d &amp;lt; \lceil t \rceil$ $d \leq t \iff d \leq \lfloor t \rfloor$ $d &amp;gt; t \iff d &amp;gt; \lfloor t \rfloor$ $d \geq t \iff d \geq \lceil t \rceil$  </description>
    </item>
    
    <item>
      <title>文字列，数値変換</title>
      <link>https://yamate11.github.io/blog/posts/2021/02-07-int-string-trans/</link>
      <pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/02-07-int-string-trans/</guid>
      <description>C++ での型の変換などのいろいろな変換方法を書いておきます．
文字列→数値 std::stoi, std::stoll を使う．2進数などを読みたいときは，base を指定すれば良い．
int stoi( const string&amp;amp; str, size_t* pos=0, int base=10 ); long long stoll( const string&amp;amp; str, size_t* pos=0, int base=10 ); 似たような名前で std::strtoll などがあるが，そちらは引数に const char* を取るので，stoll の方が便利だろう．
実数への変換は，std::stod, std::stold を使う．
double stod( const string&amp;amp; str, size_t* pos = 0 ); long double stold( const string&amp;amp; str, size_t* pos = 0 ); 数値→文字列 std::to_string を用いる．
string to_string( int value ); string to_string( long long value ); string to_string( unsigned value ); string to_string( unsigned long long value ); string to_string( double value ); string to_string( long double value ); 16進にしたいとか8進にしたいとかだと，関数一発というわけにはいかないように思う．</description>
    </item>
    
    <item>
      <title>乱数の作り方</title>
      <link>https://yamate11.github.io/blog/posts/2021/01-13-random/</link>
      <pubDate>Wed, 13 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/01-13-random/</guid>
      <description>C++ での乱数の使い方のメモです．
典型的なコード ll n; cin &amp;gt;&amp;gt; n; random_device rand_dev; mt19937 rng(rand_dev()); uniform_int_distribution&amp;lt;ll&amp;gt; dist(1, n); for (ll i = 0; i &amp;lt; 10; i++) cout &amp;lt;&amp;lt; dist(rng) &amp;lt;&amp;lt; &amp;#34; &amp;#34;; cout &amp;lt;&amp;lt; endl; クラス random_device  マニュアル  オブジェクトは乱数発生器．non-deterministic な乱数を生成する． operator() を実行すると，unsigned int の乱数が返り，状態が進む． 実行は高価である可能性がある．  クラス mt19937  マニュアル  32bitメルセンヌツィッター乱数発生器 64bitメルセンヌツィッター乱数発生器 の mt19937_64 というクラスもある． o.operator() を実行すると，uint_fast32_t の乱数が返り，状態が進む． コンストラクタに seed を渡す． デフォルトコンストラクタは引数をとらず，seed = 5489u を用いる．したがって，次のように書けば，どの実行でも同じ値が生成される．  mt19937 rng; クラス uniform_int_distribution  マニュアル  乱数分布を一様分布とする．constructor に a, b を指定すると，a以上b以下の一様分布． T は int や ll など．デフォルトは int． operator() は，引数に乱数発生器を取り，一様分布を生成する． 他の乱数分布クラスとコンストラクタの例:  uniform_real_distribution&amp;lt;double&amp;gt; dist1(a, b); normal_distribution&amp;lt;double&amp;gt; dist2(mean, stddev); </description>
    </item>
    
  </channel>
</rss>
