<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>solution on yamate11のブログ</title>
    <link>https://yamate11.github.io/blog/categories/solution/</link>
    <description>Recent content in solution on yamate11のブログ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 13 Oct 2021 21:25:49 +0900</lastBuildDate><atom:link href="https://yamate11.github.io/blog/categories/solution/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>222 -- AtCoder Beginner Contest 222 G</title>
      <link>https://yamate11.github.io/blog/posts/2021/10-13-abc222-g-222/</link>
      <pubDate>Wed, 13 Oct 2021 21:25:49 +0900</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/10-13-abc222-g-222/</guid>
      <description>エクサウィザーズプログラミングコンテスト2021 (AtCoder Beginner Contest 222 - ABC 222) G - 222 を解説ACしました．公式解説そのままですが，予備知識のところを self-contained になるように書きました．</description>
    </item>
    
    <item>
      <title>ABC 222 参加記</title>
      <link>https://yamate11.github.io/blog/posts/2021/10-09-abc222/</link>
      <pubDate>Sat, 09 Oct 2021 23:31:47 +0900</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/10-09-abc222/</guid>
      <description>ABC222 に参加して，ABCDE 5完 498位でした．参加記です．</description>
    </item>
    
    <item>
      <title>ABC 221 参加記</title>
      <link>https://yamate11.github.io/blog/posts/2021/10-03-abc221/</link>
      <pubDate>Sun, 03 Oct 2021 18:00:39 +0900</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/10-03-abc221/</guid>
      <description>ABC221に参加して，ABCDEF 6完2ペナルティでした．その記録です．</description>
    </item>
    
    <item>
      <title>Red and Blue Lamps - AtCoder Beginner Contest 218 H</title>
      <link>https://yamate11.github.io/blog/posts/2021/09-13-abc218-h-red-and-blue-lamps/</link>
      <pubDate>Mon, 13 Sep 2021 08:11:41 +0900</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/09-13-abc218-h-red-and-blue-lamps/</guid>
      <description>公式解説にある貪欲法の証明を詳しく書きました．</description>
    </item>
    
    <item>
      <title>Shapes -- AtCoder Beginner Contest 218 C</title>
      <link>https://yamate11.github.io/blog/posts/2021/09-12-abc218-shapes/</link>
      <pubDate>Sun, 12 Sep 2021 15:03:35 +0900</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/09-12-abc218-shapes/</guid>
      <description>重実装への対処は，どうしたらよいのでしょうか?</description>
    </item>
    
    <item>
      <title>Snuketoon - ABC217 H</title>
      <link>https://yamate11.github.io/blog/posts/2021/09-05-abc217-h-snuketoon/</link>
      <pubDate>Sun, 05 Sep 2021 10:44:32 +0900</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/09-05-abc217-h-snuketoon/</guid>
      <description>slope trick というのは忘れていましたが，そもそもHまで到達しませんでした．この記事は公式解説そのままです．</description>
    </item>
    
    <item>
      <title>01Sequence - ABC216 G</title>
      <link>https://yamate11.github.io/blog/posts/2021/08-30-abc216g-01sequence/</link>
      <pubDate>Mon, 30 Aug 2021 10:09:03 +0900</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/08-30-abc216g-01sequence/</guid>
      <description>公式解説とは違う (より効率の悪い) 方法で解きました．</description>
    </item>
    
    <item>
      <title>Three Permutations - ABC 214 G</title>
      <link>https://yamate11.github.io/blog/posts/2021/08-27-abc214g-three-permutations/</link>
      <pubDate>Fri, 27 Aug 2021 19:04:12 +0900</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/08-27-abc214g-three-permutations/</guid>
      <description>調べた結果分かった解法を記述します．いろいろ勉強になりました．</description>
    </item>
    
    <item>
      <title>Pass to Next - ARC 124 E</title>
      <link>https://yamate11.github.io/blog/posts/2021/08-27-arc124e/</link>
      <pubDate>Fri, 27 Aug 2021 14:51:59 +0900</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/08-27-arc124e/</guid>
      <description>解けませんでした．解説を読んでも分からなかったので，自分なりの説明です．</description>
    </item>
    
    <item>
      <title>Shorten ABC - AtCoder Regular Contest 110 E</title>
      <link>https://yamate11.github.io/blog/posts/2021/08-26-shorten-abc/</link>
      <pubDate>Thu, 26 Aug 2021 06:08:51 +0900</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/08-26-shorten-abc/</guid>
      <description>解説AC です．公式解説も皆さんの解説もたくさん参考にしています．</description>
    </item>
    
    <item>
      <title>Snack - Atcoder Regular Contest 125 E</title>
      <link>https://yamate11.github.io/blog/posts/2021/08-24-snack/</link>
      <pubDate>Tue, 24 Aug 2021 17:57:58 +0900</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/08-24-snack/</guid>
      <description>Atcoder Regular Contest 125 E Snack の解法です．公式解説そのままです．</description>
    </item>
    
    <item>
      <title>Cabbage Master - Atcoder Beginner Contest 215 H</title>
      <link>https://yamate11.github.io/blog/posts/2021/08-23-cabbage-master/</link>
      <pubDate>Mon, 23 Aug 2021 16:35:21 +0900</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/08-23-cabbage-master/</guid>
      <description>Atcoder Beginner Contest 215 (ABC215) H Cabbage Master に関する記事です．公式解説そのままですけれど，予備知識を一応書きました．</description>
    </item>
    
    <item>
      <title>Random LIS - Atcoder Regular Contest 104 E</title>
      <link>https://yamate11.github.io/blog/posts/2021/08-19-random-lis/</link>
      <pubDate>Thu, 19 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/08-19-random-lis/</guid>
      <description>Atcoder Regular Contest 104 (ARC 104) E Random LIS に関する記事です．
問題文へのリンク https://atcoder.jp/contests/arc104/tasks/arc104_e 経緯 過去問埋めで解いてみようとしましたが，全然わかりませんでした． 公式解説 を読んでもやっぱりわからず， けんちょんさんの解説 を読んで，なんとか理解することができました．
解法 例えば，N = 4 として，数列 10 7 10 15 と数列 5 1 5 2000 は， 数値の差こそあれ，大小関係は同一である．これらを 1 0 1 2 というパターンとして 1つのグループとしてまとめることにする．以下を実行する．
 全パターンを列挙する． 各パターンについて，  LISの長さを求める． そのパターンに属する数列の数を数える．    グループがいくつあるかは， Ordered Bell number として知られているということである．N = 6 の場合には，4683個． 丁寧に列挙することもできるであろうが，$6^6 = 46656$ であるから，0 から N-1 までの 数の N 個の並びから，不適なものを弾いても十分速い． 各グループに属する数列では，LIS の長さは同じであり，N &amp;lt;= 6 だからこれを求めるのは容易である． 各グループに属する数列の数を求めるのが主要なタスクとなる．</description>
    </item>
    
    <item>
      <title>イベント巡り (Event Hopping) - JOI 2020/2021 二次予選</title>
      <link>https://yamate11.github.io/blog/posts/2021/08-16-event-hopping/</link>
      <pubDate>Mon, 16 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/08-16-event-hopping/</guid>
      <description>JOI 2020/2021 二次予選 「イベント巡り (Event Hopping)」 に関する記事です． 公式解説 を読みきれなかったので&amp;hellip;.
問題へのリンク https://atcoder.jp/contests/joi2021yo2/tasks/joi2021_yo2_c 解法 ちょっと不思議な感じで，小課題3 を (私の感覚では) 自然に解くと， それが満点解法にもなっているという&amp;hellip; (解説を読むまでわからなかったのですけれど)
ソートして，$S_i$ が昇順になっているとします． ナイーブに考えると，次の DP になります．
 dp[i][j] := i番目のイベントに参加する直前までに参加したイベントの 回数が j であるような方法がある (True/False)  遷移としては，dp[i][j] = True となる j について，
 町 $P_i$ で行われるイベントで，時刻 $S_i + 1$ 以降最も早いものを i1 町 $3 - P_i$ で行われるイベントで， 時刻 $S_i + 1 + D + K(j + 1)$ 以降最も早いものを i2  として，
 dp[i1][j+1] := True dp[i2][j+1] := True  と設定することになります．でも，これは $\Omega(N^2)$ なので，間に合いません．</description>
    </item>
    
    <item>
      <title>Stroll - Atcoder Beginner Contest 213 H</title>
      <link>https://yamate11.github.io/blog/posts/2021/08-11-stroll/</link>
      <pubDate>Wed, 11 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/08-11-stroll/</guid>
      <description>解けませんでした．オンライン・オフライン変換を調べて書きました．</description>
    </item>
    
    <item>
      <title>Greedy Ant - キーエンスプログラミングコンテスト2021 E</title>
      <link>https://yamate11.github.io/blog/posts/2021/07-22-greedy-ant/</link>
      <pubDate>Thu, 22 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/07-22-greedy-ant/</guid>
      <description>キーエンスプログラミングコンテスト 2021 E - Greedy Ant に関する記事です．
問題へのリンク https://atcoder.jp/contests/keyence2021/tasks/keyence2021 解法 公式解説 の通りではありますが，若干表現を変えます．
すぬけ君が，蟻から遠い飴を取っても，蟻の行動には直ちには影響を与えません． そういう状況ではすぬけ君は「スキップ」することにして，後から蟻がその飴に近づいてきたとき (左右いずれかで蟻の最も近い飴になったとき) に取ることにしても，ゲームの意味が変わりません． つまり，次のようにゲームを言い変えることができます． (両端などの扱いはサボっています)
初期化: // 蟻の初期位置を 2n + 1 とする． l := n // 蟻に最も近い左の飴の位置が 2l r := n + 1 // 蟻に最も近い右の飴の位置が 2r k := 0 // すぬけ君の「スキップ」回数 ループ: k += 1 while k &amp;gt; 0: match すぬけ君の選択(): case なし: break case 左: すぬけ君が 2l の飴を取る; l -= 1 case 右: すぬけ君が 2r の飴を取る; r += 1 k -= 1 蟻が，2l, 2r の飴のおいしい方を取る 取った方に応じて l -= 1 または r += 1 そこで， f(l,r,k) を，「上記 while の先頭位置で，l,r,k がこの値である時に，すぬけ君がこのあと取る得点の最大値」として 定義します． 次の漸化式が書けます．</description>
    </item>
    
    <item>
      <title>CodeForces Round #431 (Div.2) E - Goodbye Souvenir</title>
      <link>https://yamate11.github.io/blog/posts/2021/01-18-goodbye-souvenir/</link>
      <pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/01-18-goodbye-souvenir/</guid>
      <description>CodeForces Round #431 (Div.2) E - Goodbye Souvenir についての記事です．
問題へのリンク https://codeforces.com/contest/849/problem/E 経緯 Yoika さんが主催している Morningforces というバーチャルコンテスト で出て，解けませんでした． 公式解説 を読んだのですが，最後に出てくる座標圧縮云々がよく分かりませんでした．
問題概要 整数列 $a = a_1, \ldots, a_k $ に対して，$m(a)$ を，$a$ に現れる各数 $x$ に対して，$x$ が最後に現れる位置と最初に現れる位置との差の総和として定義する．例えば，$m(1, 2, 3, 1, 3, 2, 1) = (7-1) + (6-2) + (5- 3) = 12$．最初に長さ n の整数列 a が与えられる．各要素は1以上n以下．次の2種類のクエリ (全部で$m$個) を処理せよ．$ 1 \leq n, m \leq 100,000$．
 p, x が与えられて，aのp番目の要素をxに書き換える． l, r が与えられて，$ m(a[l:r]) $ を求める．  解法 ということで，実装手段を除いては公式解説をなぞっています．</description>
    </item>
    
    <item>
      <title>AtCoder Regular Contest 056 D - サケノミ</title>
      <link>https://yamate11.github.io/blog/posts/2021/01-06-sakenomi/</link>
      <pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/01-06-sakenomi/</guid>
      <description>AtCoder Regular Contest (ARC) 056 D - サケノミ についての記事です．
問題へのリンク  状況 解けないだけではなく，答を見てもなかなかわからなかったので，整理するために書いています．下記を参考にしています．
 公式解説  kmjpさんのブログ   解法 時刻 $2j+1$ にドリンクを飲むような飲み方全部に関する，時刻 $2j+1$ 時点での美味しさの総和の最大値を $x(j)$ とする． 時刻 $2i$ に全部のグラスが空だったとき，半開区間 $(2i, 2j]$ に属する時刻に注がれるドリンクの美味しさの総和を $y(i, j)$ とすると， $x(j) = \max \{ x(i) + y(i, j) \mid i &amp;lt; j \} $ である．ここで，$z(i, j) = x(i) + y(i, j)$ と書くことにする．時刻 $j$ に注がれるドリンク全体の集合を $P$ とし，$ p \in P $ に対して時刻 $2j$ の一回前にドリンク $p$ が注がれる時刻を $l_p$ とする (時刻 j が初回なら，$l_p = 0$ とする)．すると，次が成り立つ．</description>
    </item>
    
  </channel>
</rss>
