<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>solution on yamate11のブログ</title>
    <link>https://yamate11.github.io/blog/categories/solution/</link>
    <description>Recent content in solution on yamate11のブログ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 24 Aug 2021 17:57:58 +0900</lastBuildDate><atom:link href="https://yamate11.github.io/blog/categories/solution/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Snack - Atcoder Regular Contest 125 E</title>
      <link>https://yamate11.github.io/blog/posts/2021/08-24-snack/</link>
      <pubDate>Tue, 24 Aug 2021 17:57:58 +0900</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/08-24-snack/</guid>
      <description>Atcoder Regular Contest 125 E Snack の解法です．公式解説そのままです．</description>
    </item>
    
    <item>
      <title>Cabbage Master - Atcoder Beginner Contest 215 H</title>
      <link>https://yamate11.github.io/blog/posts/2021/08-23-cabbage-master/</link>
      <pubDate>Mon, 23 Aug 2021 16:35:21 +0900</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/08-23-cabbage-master/</guid>
      <description>Atcoder Beginner Contest 215 (ABC215) H Cabbage Master に関する記事です．公式解説そのままですけれど，予備知識を一応書きました．</description>
    </item>
    
    <item>
      <title>Random LIS - Atcoder Regular Contest 104 E</title>
      <link>https://yamate11.github.io/blog/posts/2021/08-19-random-lis/</link>
      <pubDate>Thu, 19 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/08-19-random-lis/</guid>
      <description>Atcoder Regular Contest 104 (ARC 104) E Random LIS に関する記事です．
問題文へのリンク https://atcoder.jp/contests/arc104/tasks/arc104_e 経緯 過去問埋めで解いてみようとしましたが，全然わかりませんでした． 公式解説 を読んでもやっぱりわからず， けんちょんさんの解説 を読んで，なんとか理解することができました．
解法 例えば，N = 4 として，数列 10 7 10 15 と数列 5 1 5 2000 は， 数値の差こそあれ，大小関係は同一である．これらを 1 0 1 2 というパターンとして 1つのグループとしてまとめることにする．以下を実行する．
 全パターンを列挙する． 各パターンについて，  LISの長さを求める． そのパターンに属する数列の数を数える．    グループがいくつあるかは， Ordered Bell number として知られているということである．N = 6 の場合には，4683個． 丁寧に列挙することもできるであろうが，$6^6 = 46656$ であるから，0 から N-1 までの 数の N 個の並びから，不適なものを弾いても十分速い． 各グループに属する数列では，LIS の長さは同じであり，N &amp;lt;= 6 だからこれを求めるのは容易である． 各グループに属する数列の数を求めるのが主要なタスクとなる．</description>
    </item>
    
    <item>
      <title>イベント巡り (Event Hopping) - JOI 2020/2021 二次予選</title>
      <link>https://yamate11.github.io/blog/posts/2021/08-16-event-hopping/</link>
      <pubDate>Mon, 16 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/08-16-event-hopping/</guid>
      <description>JOI 2020/2021 二次予選 「イベント巡り (Event Hopping)」 に関する記事です． 公式解説 を読みきれなかったので&amp;hellip;.
問題へのリンク https://atcoder.jp/contests/joi2021yo2/tasks/joi2021_yo2_c 解法 ちょっと不思議な感じで，小課題3 を (私の感覚では) 自然に解くと， それが満点解法にもなっているという&amp;hellip; (解説を読むまでわからなかったのですけれど)
ソートして，$S_i$ が昇順になっているとします． ナイーブに考えると，次の DP になります．
 dp[i][j] := i番目のイベントに参加する直前までに参加したイベントの 回数が j であるような方法がある (True/False)  遷移としては，dp[i][j] = True となる j について，
 町 $P_i$ で行われるイベントで，時刻 $S_i + 1$ 以降最も早いものを i1 町 $3 - P_i$ で行われるイベントで， 時刻 $S_i + 1 + D + K(j + 1)$ 以降最も早いものを i2  として，
 dp[i1][j+1] := True dp[i2][j+1] := True  と設定することになります．でも，これは $\Omega(N^2)$ なので，間に合いません．</description>
    </item>
    
    <item>
      <title>Atcoder Beginner Contest 213 H - Stroll</title>
      <link>https://yamate11.github.io/blog/posts/2021/08-11-stroll/</link>
      <pubDate>Wed, 11 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/08-11-stroll/</guid>
      <description>Atcoder Beginner Contest 213 (ABC-213) H - Stroll に関する記事です．
問題へのリンク 解法 公式解説 を読んでもよくわからなかったのですが， Motsu_xeさんによる，オフライン・オンライン変換 の説明がわかりやすかったです． 以下の説明は，ほとんど，上の2つの記事に依っています．
記法を定めます．
 $f(x, i) :=$ 地点$x$に距離$i$で到達する方法の数 $p(x, y, i) :=$ 地点 $x$ と地点 $y$ を結ぶ距離 $i$ の道の数 $X := \{1, \ldots, N\}$  したがって，$f(1, T)$ が求める答です．次の関係が成り立ちます:
 $f(1, 0) = 1$ $f(y, 0) = 0\quad(y \neq 1)$ $f(x, i) = \sum \{ f(y, j) \cdot p(x, y, i - j) \mid y \in X, j \in [0, i) \}$  最後の式は，一見，畳み込みですが，右辺にも $f$ が出てきてしまうので， ただちには FFT に渡せません．ここを 分割統治FFTなる手法で求めようという趣旨であるようです．</description>
    </item>
    
    <item>
      <title>Greedy Ant - キーエンスプログラミングコンテスト2021 E</title>
      <link>https://yamate11.github.io/blog/posts/2021/07-22-greedy-ant/</link>
      <pubDate>Thu, 22 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/07-22-greedy-ant/</guid>
      <description>キーエンスプログラミングコンテスト 2021 E - Greedy Ant に関する記事です．
問題へのリンク https://atcoder.jp/contests/keyence2021/tasks/keyence2021 解法 公式解説 の通りではありますが，若干表現を変えます．
すぬけ君が，蟻から遠い飴を取っても，蟻の行動には直ちには影響を与えません． そういう状況ではすぬけ君は「スキップ」することにして，後から蟻がその飴に近づいてきたとき (左右いずれかで蟻の最も近い飴になったとき) に取ることにしても，ゲームの意味が変わりません． つまり，次のようにゲームを言い変えることができます． (両端などの扱いはサボっています)
初期化: // 蟻の初期位置を 2n + 1 とする． l := n // 蟻に最も近い左の飴の位置が 2l r := n + 1 // 蟻に最も近い右の飴の位置が 2r k := 0 // すぬけ君の「スキップ」回数 ループ: k += 1 while k &amp;gt; 0: match すぬけ君の選択(): case なし: break case 左: すぬけ君が 2l の飴を取る; l -= 1 case 右: すぬけ君が 2r の飴を取る; r += 1 k -= 1 蟻が，2l, 2r の飴のおいしい方を取る 取った方に応じて l -= 1 または r += 1 そこで， f(l,r,k) を，「上記 while の先頭位置で，l,r,k がこの値である時に，すぬけ君がこのあと取る得点の最大値」として 定義します． 次の漸化式が書けます．</description>
    </item>
    
    <item>
      <title>CodeForces Round #431 (Div.2) E - Goodbye Souvenir</title>
      <link>https://yamate11.github.io/blog/posts/2021/01-18-goodbye-souvenir/</link>
      <pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/01-18-goodbye-souvenir/</guid>
      <description>CodeForces Round #431 (Div.2) E - Goodbye Souvenir についての記事です．
問題へのリンク https://codeforces.com/contest/849/problem/E 経緯 Yoika さんが主催している Morningforces というバーチャルコンテスト で出て，解けませんでした． 公式解説 を読んだのですが，最後に出てくる座標圧縮云々がよく分かりませんでした．
問題概要 整数列 $a = a_1, \ldots, a_k $ に対して，$m(a)$ を，$a$ に現れる各数 $x$ に対して，$x$ が最後に現れる位置と最初に現れる位置との差の総和として定義する．例えば，$m(1, 2, 3, 1, 3, 2, 1) = (7-1) + (6-2) + (5- 3) = 12$．最初に長さ n の整数列 a が与えられる．各要素は1以上n以下．次の2種類のクエリ (全部で$m$個) を処理せよ．$ 1 \leq n, m \leq 100,000$．
 p, x が与えられて，aのp番目の要素をxに書き換える． l, r が与えられて，$ m(a[l:r]) $ を求める．  解法 ということで，実装手段を除いては公式解説をなぞっています．</description>
    </item>
    
    <item>
      <title>AtCoder Regular Contest 056 D - サケノミ</title>
      <link>https://yamate11.github.io/blog/posts/2021/01-06-sakenomi/</link>
      <pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yamate11.github.io/blog/posts/2021/01-06-sakenomi/</guid>
      <description>AtCoder Regular Contest (ARC) 056 D - サケノミ についての記事です．
問題へのリンク  状況 解けないだけではなく，答を見てもなかなかわからなかったので，整理するために書いています．下記を参考にしています．
 公式解説  kmjpさんのブログ   解法 時刻 $2j+1$ にドリンクを飲むような飲み方全部に関する，時刻 $2j+1$ 時点での美味しさの総和の最大値を $x(j)$ とする． 時刻 $2i$ に全部のグラスが空だったとき，半開区間 $(2i, 2j]$ に属する時刻に注がれるドリンクの美味しさの総和を $y(i, j)$ とすると， $x(j) = \max \{ x(i) + y(i, j) \mid i &amp;lt; j \} $ である．ここで，$z(i, j) = x(i) + y(i, j)$ と書くことにする．時刻 $j$ に注がれるドリンク全体の集合を $P$ とし，$ p \in P $ に対して時刻 $2j$ の一回前にドリンク $p$ が注がれる時刻を $l_p$ とする (時刻 j が初回なら，$l_p = 0$ とする)．すると，次が成り立つ．</description>
    </item>
    
  </channel>
</rss>
